
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Site
 * 
 */
export type Site = $Result.DefaultSelection<Prisma.$SitePayload>
/**
 * Model SocialAmenity
 * 
 */
export type SocialAmenity = $Result.DefaultSelection<Prisma.$SocialAmenityPayload>
/**
 * Model announcements
 * 
 */
export type announcements = $Result.DefaultSelection<Prisma.$announcementsPayload>
/**
 * Model blocks
 * 
 */
export type blocks = $Result.DefaultSelection<Prisma.$blocksPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model individuals
 * 
 */
export type individuals = $Result.DefaultSelection<Prisma.$individualsPayload>
/**
 * Model company_employees
 * 
 */
export type company_employees = $Result.DefaultSelection<Prisma.$company_employeesPayload>
/**
 * Model complaints
 * 
 */
export type complaints = $Result.DefaultSelection<Prisma.$complaintsPayload>
/**
 * Model employee_site_access
 * 
 */
export type employee_site_access = $Result.DefaultSelection<Prisma.$employee_site_accessPayload>
/**
 * Model invitations
 * 
 */
export type invitations = $Result.DefaultSelection<Prisma.$invitationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model MasterUser
 * 
 */
export type MasterUser = $Result.DefaultSelection<Prisma.$MasterUserPayload>
/**
 * Model AdminComplaint
 * 
 */
export type AdminComplaint = $Result.DefaultSelection<Prisma.$AdminComplaintPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY_MANAGER: 'COMPANY_MANAGER',
  COMPANY_EMPLOYEE: 'COMPANY_EMPLOYEE',
  SITE_USER: 'SITE_USER'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const Category: {
  MAINTENANCE: 'MAINTENANCE',
  COMPLAINT: 'COMPLAINT',
  REQUEST: 'REQUEST',
  OTHER: 'OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ResidentType: {
  OWNER: 'OWNER',
  HIRER: 'HIRER'
};

export type ResidentType = (typeof ResidentType)[keyof typeof ResidentType]


export const Status: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const MasterRole: {
  MASTER_ADMIN: 'MASTER_ADMIN',
  DEVELOPER: 'DEVELOPER',
  PRODUCT_OWNER: 'PRODUCT_OWNER',
  BOOKKEEPER: 'BOOKKEEPER',
  SUPPORT: 'SUPPORT'
};

export type MasterRole = (typeof MasterRole)[keyof typeof MasterRole]


export const AdminComplaintCategory: {
  TECHNICAL_SUPPORT: 'TECHNICAL_SUPPORT',
  RESTORE: 'RESTORE',
  REQUEST: 'REQUEST',
  FEATURE_REQUEST: 'FEATURE_REQUEST',
  GENERAL: 'GENERAL',
  OTHER: 'OTHER'
};

export type AdminComplaintCategory = (typeof AdminComplaintCategory)[keyof typeof AdminComplaintCategory]

}

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ResidentType = $Enums.ResidentType

export const ResidentType: typeof $Enums.ResidentType

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type MasterRole = $Enums.MasterRole

export const MasterRole: typeof $Enums.MasterRole

export type AdminComplaintCategory = $Enums.AdminComplaintCategory

export const AdminComplaintCategory: typeof $Enums.AdminComplaintCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialAmenity`: Exposes CRUD operations for the **SocialAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialAmenities
    * const socialAmenities = await prisma.socialAmenity.findMany()
    * ```
    */
  get socialAmenity(): Prisma.SocialAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcements`: Exposes CRUD operations for the **announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.announcementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individuals`: Exposes CRUD operations for the **individuals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Individuals
    * const individuals = await prisma.individuals.findMany()
    * ```
    */
  get individuals(): Prisma.individualsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_employees`: Exposes CRUD operations for the **company_employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_employees
    * const company_employees = await prisma.company_employees.findMany()
    * ```
    */
  get company_employees(): Prisma.company_employeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaints`: Exposes CRUD operations for the **complaints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaints.findMany()
    * ```
    */
  get complaints(): Prisma.complaintsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee_site_access`: Exposes CRUD operations for the **employee_site_access** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_site_accesses
    * const employee_site_accesses = await prisma.employee_site_access.findMany()
    * ```
    */
  get employee_site_access(): Prisma.employee_site_accessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitations`: Exposes CRUD operations for the **invitations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitations.findMany()
    * ```
    */
  get invitations(): Prisma.invitationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterUser`: Exposes CRUD operations for the **MasterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterUsers
    * const masterUsers = await prisma.masterUser.findMany()
    * ```
    */
  get masterUser(): Prisma.MasterUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminComplaint`: Exposes CRUD operations for the **AdminComplaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminComplaints
    * const adminComplaints = await prisma.adminComplaint.findMany()
    * ```
    */
  get adminComplaint(): Prisma.AdminComplaintDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Site: 'Site',
    SocialAmenity: 'SocialAmenity',
    announcements: 'announcements',
    blocks: 'blocks',
    companies: 'companies',
    individuals: 'individuals',
    company_employees: 'company_employees',
    complaints: 'complaints',
    employee_site_access: 'employee_site_access',
    invitations: 'invitations',
    payments: 'payments',
    MasterUser: 'MasterUser',
    AdminComplaint: 'AdminComplaint'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "admin" | "site" | "socialAmenity" | "announcements" | "blocks" | "companies" | "individuals" | "company_employees" | "complaints" | "employee_site_access" | "invitations" | "payments" | "masterUser" | "adminComplaint"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Site: {
        payload: Prisma.$SitePayload<ExtArgs>
        fields: Prisma.SiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findFirst: {
            args: Prisma.SiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findMany: {
            args: Prisma.SiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          create: {
            args: Prisma.SiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          createMany: {
            args: Prisma.SiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          delete: {
            args: Prisma.SiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          update: {
            args: Prisma.SiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          deleteMany: {
            args: Prisma.SiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          upsert: {
            args: Prisma.SiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          aggregate: {
            args: Prisma.SiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite>
          }
          groupBy: {
            args: Prisma.SiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCountAggregateOutputType> | number
          }
        }
      }
      SocialAmenity: {
        payload: Prisma.$SocialAmenityPayload<ExtArgs>
        fields: Prisma.SocialAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          findFirst: {
            args: Prisma.SocialAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          findMany: {
            args: Prisma.SocialAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>[]
          }
          create: {
            args: Prisma.SocialAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          createMany: {
            args: Prisma.SocialAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>[]
          }
          delete: {
            args: Prisma.SocialAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          update: {
            args: Prisma.SocialAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          deleteMany: {
            args: Prisma.SocialAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>[]
          }
          upsert: {
            args: Prisma.SocialAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAmenityPayload>
          }
          aggregate: {
            args: Prisma.SocialAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialAmenity>
          }
          groupBy: {
            args: Prisma.SocialAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<SocialAmenityCountAggregateOutputType> | number
          }
        }
      }
      announcements: {
        payload: Prisma.$announcementsPayload<ExtArgs>
        fields: Prisma.announcementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.announcementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.announcementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findFirst: {
            args: Prisma.announcementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.announcementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findMany: {
            args: Prisma.announcementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          create: {
            args: Prisma.announcementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          createMany: {
            args: Prisma.announcementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.announcementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          delete: {
            args: Prisma.announcementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          update: {
            args: Prisma.announcementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          deleteMany: {
            args: Prisma.announcementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.announcementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.announcementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          upsert: {
            args: Prisma.announcementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.announcementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.announcementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      blocks: {
        payload: Prisma.$blocksPayload<ExtArgs>
        fields: Prisma.blocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blocksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blocksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findFirst: {
            args: Prisma.blocksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blocksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findMany: {
            args: Prisma.blocksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          create: {
            args: Prisma.blocksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          createMany: {
            args: Prisma.blocksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blocksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          delete: {
            args: Prisma.blocksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          update: {
            args: Prisma.blocksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          deleteMany: {
            args: Prisma.blocksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blocksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blocksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          upsert: {
            args: Prisma.blocksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.blocksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.blocksCountArgs<ExtArgs>
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      individuals: {
        payload: Prisma.$individualsPayload<ExtArgs>
        fields: Prisma.individualsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.individualsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.individualsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          findFirst: {
            args: Prisma.individualsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.individualsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          findMany: {
            args: Prisma.individualsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>[]
          }
          create: {
            args: Prisma.individualsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          createMany: {
            args: Prisma.individualsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.individualsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>[]
          }
          delete: {
            args: Prisma.individualsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          update: {
            args: Prisma.individualsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          deleteMany: {
            args: Prisma.individualsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.individualsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.individualsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>[]
          }
          upsert: {
            args: Prisma.individualsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          aggregate: {
            args: Prisma.IndividualsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndividuals>
          }
          groupBy: {
            args: Prisma.individualsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndividualsGroupByOutputType>[]
          }
          count: {
            args: Prisma.individualsCountArgs<ExtArgs>
            result: $Utils.Optional<IndividualsCountAggregateOutputType> | number
          }
        }
      }
      company_employees: {
        payload: Prisma.$company_employeesPayload<ExtArgs>
        fields: Prisma.company_employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findFirst: {
            args: Prisma.company_employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findMany: {
            args: Prisma.company_employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          create: {
            args: Prisma.company_employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          createMany: {
            args: Prisma.company_employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_employeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          delete: {
            args: Prisma.company_employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          update: {
            args: Prisma.company_employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          deleteMany: {
            args: Prisma.company_employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_employeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          upsert: {
            args: Prisma.company_employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          aggregate: {
            args: Prisma.Company_employeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_employees>
          }
          groupBy: {
            args: Prisma.company_employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_employeesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesCountAggregateOutputType> | number
          }
        }
      }
      complaints: {
        payload: Prisma.$complaintsPayload<ExtArgs>
        fields: Prisma.complaintsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.complaintsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.complaintsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findFirst: {
            args: Prisma.complaintsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.complaintsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findMany: {
            args: Prisma.complaintsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          create: {
            args: Prisma.complaintsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          createMany: {
            args: Prisma.complaintsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.complaintsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          delete: {
            args: Prisma.complaintsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          update: {
            args: Prisma.complaintsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          deleteMany: {
            args: Prisma.complaintsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.complaintsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.complaintsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          upsert: {
            args: Prisma.complaintsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          aggregate: {
            args: Prisma.ComplaintsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaints>
          }
          groupBy: {
            args: Prisma.complaintsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsGroupByOutputType>[]
          }
          count: {
            args: Prisma.complaintsCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsCountAggregateOutputType> | number
          }
        }
      }
      employee_site_access: {
        payload: Prisma.$employee_site_accessPayload<ExtArgs>
        fields: Prisma.employee_site_accessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employee_site_accessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employee_site_accessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findFirst: {
            args: Prisma.employee_site_accessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employee_site_accessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findMany: {
            args: Prisma.employee_site_accessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          create: {
            args: Prisma.employee_site_accessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          createMany: {
            args: Prisma.employee_site_accessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employee_site_accessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          delete: {
            args: Prisma.employee_site_accessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          update: {
            args: Prisma.employee_site_accessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          deleteMany: {
            args: Prisma.employee_site_accessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employee_site_accessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employee_site_accessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          upsert: {
            args: Prisma.employee_site_accessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          aggregate: {
            args: Prisma.Employee_site_accessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_site_access>
          }
          groupBy: {
            args: Prisma.employee_site_accessGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessGroupByOutputType>[]
          }
          count: {
            args: Prisma.employee_site_accessCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessCountAggregateOutputType> | number
          }
        }
      }
      invitations: {
        payload: Prisma.$invitationsPayload<ExtArgs>
        fields: Prisma.invitationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invitationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invitationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findFirst: {
            args: Prisma.invitationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invitationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findMany: {
            args: Prisma.invitationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          create: {
            args: Prisma.invitationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          createMany: {
            args: Prisma.invitationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invitationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          delete: {
            args: Prisma.invitationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          update: {
            args: Prisma.invitationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          deleteMany: {
            args: Prisma.invitationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invitationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invitationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          upsert: {
            args: Prisma.invitationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          aggregate: {
            args: Prisma.InvitationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitations>
          }
          groupBy: {
            args: Prisma.invitationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invitationsCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      MasterUser: {
        payload: Prisma.$MasterUserPayload<ExtArgs>
        fields: Prisma.MasterUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          findFirst: {
            args: Prisma.MasterUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          findMany: {
            args: Prisma.MasterUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>[]
          }
          create: {
            args: Prisma.MasterUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          createMany: {
            args: Prisma.MasterUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MasterUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>[]
          }
          delete: {
            args: Prisma.MasterUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          update: {
            args: Prisma.MasterUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          deleteMany: {
            args: Prisma.MasterUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MasterUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>[]
          }
          upsert: {
            args: Prisma.MasterUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterUserPayload>
          }
          aggregate: {
            args: Prisma.MasterUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterUser>
          }
          groupBy: {
            args: Prisma.MasterUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterUserCountArgs<ExtArgs>
            result: $Utils.Optional<MasterUserCountAggregateOutputType> | number
          }
        }
      }
      AdminComplaint: {
        payload: Prisma.$AdminComplaintPayload<ExtArgs>
        fields: Prisma.AdminComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          findFirst: {
            args: Prisma.AdminComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          findMany: {
            args: Prisma.AdminComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>[]
          }
          create: {
            args: Prisma.AdminComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          createMany: {
            args: Prisma.AdminComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminComplaintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>[]
          }
          delete: {
            args: Prisma.AdminComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          update: {
            args: Prisma.AdminComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          deleteMany: {
            args: Prisma.AdminComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminComplaintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>[]
          }
          upsert: {
            args: Prisma.AdminComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminComplaintPayload>
          }
          aggregate: {
            args: Prisma.AdminComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminComplaint>
          }
          groupBy: {
            args: Prisma.AdminComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<AdminComplaintCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    site?: SiteOmit
    socialAmenity?: SocialAmenityOmit
    announcements?: announcementsOmit
    blocks?: blocksOmit
    companies?: companiesOmit
    individuals?: individualsOmit
    company_employees?: company_employeesOmit
    complaints?: complaintsOmit
    employee_site_access?: employee_site_accessOmit
    invitations?: invitationsOmit
    payments?: paymentsOmit
    masterUser?: MasterUserOmit
    adminComplaint?: AdminComplaintOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    complaints: number
    payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | UserCountOutputTypeCountComplaintsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    sites_created: number
    adminComplaints: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites_created?: boolean | AdminCountOutputTypeCountSites_createdArgs
    adminComplaints?: boolean | AdminCountOutputTypeCountAdminComplaintsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdminComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminComplaintWhereInput
  }


  /**
   * Count Type SiteCountOutputType
   */

  export type SiteCountOutputType = {
    announcements: number
    blocks: number
    complaints: number
    employee_site_access: number
    socialAmenities: number
    users: number
  }

  export type SiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | SiteCountOutputTypeCountAnnouncementsArgs
    blocks?: boolean | SiteCountOutputTypeCountBlocksArgs
    complaints?: boolean | SiteCountOutputTypeCountComplaintsArgs
    employee_site_access?: boolean | SiteCountOutputTypeCountEmployee_site_accessArgs
    socialAmenities?: boolean | SiteCountOutputTypeCountSocialAmenitiesArgs
    users?: boolean | SiteCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCountOutputType
     */
    select?: SiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountSocialAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialAmenityWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type BlocksCountOutputType
   */

  export type BlocksCountOutputType = {
    users: number
  }

  export type BlocksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BlocksCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocksCountOutputType
     */
    select?: BlocksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    admins: number
    company_employees: number
    invitations: number
    sites: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | CompaniesCountOutputTypeCountAdminsArgs
    company_employees?: boolean | CompaniesCountOutputTypeCountCompany_employeesArgs
    invitations?: boolean | CompaniesCountOutputTypeCountInvitationsArgs
    sites?: boolean | CompaniesCountOutputTypeCountSitesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }


  /**
   * Count Type Company_employeesCountOutputType
   */

  export type Company_employeesCountOutputType = {
    employee_site_access: number
  }

  export type Company_employeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_site_access?: boolean | Company_employeesCountOutputTypeCountEmployee_site_accessArgs
  }

  // Custom InputTypes
  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company_employeesCountOutputType
     */
    select?: Company_employeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
    reset_code: string | null
    reset_code_expiry: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
    reset_code: string | null
    reset_code_expiry: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    full_name: number
    phone_number: number
    password: number
    apartment_no: number
    created_at: number
    updated_at: number
    siteId: number
    code_expiry: number
    phone_verification_code: number
    account_status: number
    deleted_at: number
    last_login: number
    plates: number
    resident_count: number
    resident_type: number
    block_id: number
    is_password_set: number
    reset_code: number
    reset_code_expiry: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
    reset_code?: true
    reset_code_expiry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
    reset_code?: true
    reset_code_expiry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
    reset_code?: true
    reset_code_expiry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    full_name: string
    phone_number: string
    password: string | null
    apartment_no: string | null
    created_at: Date
    updated_at: Date
    siteId: number
    code_expiry: Date | null
    phone_verification_code: string | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean
    reset_code: string | null
    reset_code_expiry: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "phone_number" | "password" | "apartment_no" | "created_at" | "updated_at" | "siteId" | "code_expiry" | "phone_verification_code" | "account_status" | "deleted_at" | "last_login" | "plates" | "resident_count" | "resident_type" | "block_id" | "is_password_set" | "reset_code" | "reset_code_expiry", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      complaints: Prisma.$complaintsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs> | null
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      phone_number: string
      password: string | null
      apartment_no: string | null
      created_at: Date
      updated_at: Date
      siteId: number
      code_expiry: Date | null
      phone_verification_code: string | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
      plates: string | null
      resident_count: number | null
      resident_type: $Enums.ResidentType | null
      block_id: number | null
      is_password_set: boolean
      reset_code: string | null
      reset_code_expiry: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends User$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends User$blocksArgs<ExtArgs> = {}>(args?: Subset<T, User$blocksArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly apartment_no: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly siteId: FieldRef<"User", 'Int'>
    readonly code_expiry: FieldRef<"User", 'DateTime'>
    readonly phone_verification_code: FieldRef<"User", 'String'>
    readonly account_status: FieldRef<"User", 'AccountStatus'>
    readonly deleted_at: FieldRef<"User", 'DateTime'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly plates: FieldRef<"User", 'String'>
    readonly resident_count: FieldRef<"User", 'Int'>
    readonly resident_type: FieldRef<"User", 'ResidentType'>
    readonly block_id: FieldRef<"User", 'Int'>
    readonly is_password_set: FieldRef<"User", 'Boolean'>
    readonly reset_code: FieldRef<"User", 'String'>
    readonly reset_code_expiry: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.complaints
   */
  export type User$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * User.blocks
   */
  export type User$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    individualId: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    individualId: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    company_code: string | null
    companyId: number | null
    individualId: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    company_code: string | null
    companyId: number | null
    individualId: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password: number
    account_type: number
    company_name: number
    created_at: number
    updated_at: number
    tokenExpiry: number
    verificationToken: number
    is_verified: number
    resetToken: number
    resetTokenExpiry: number
    account_status: number
    deleted_at: number
    last_login: number
    company_code: number
    companyId: number
    individualId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    companyId?: true
    individualId?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    companyId?: true
    individualId?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    company_code?: true
    companyId?: true
    individualId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    company_code?: true
    companyId?: true
    individualId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    company_code?: true
    companyId?: true
    individualId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name: string | null
    created_at: Date
    updated_at: Date
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    company_code: string | null
    companyId: number | null
    individualId: number | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    company_code?: boolean
    companyId?: boolean
    individualId?: boolean
    company?: boolean | Admin$companyArgs<ExtArgs>
    company_employees?: boolean | Admin$company_employeesArgs<ExtArgs>
    individual?: boolean | Admin$individualArgs<ExtArgs>
    sites_created?: boolean | Admin$sites_createdArgs<ExtArgs>
    adminComplaints?: boolean | Admin$adminComplaintsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    company_code?: boolean
    companyId?: boolean
    individualId?: boolean
    company?: boolean | Admin$companyArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    company_code?: boolean
    companyId?: boolean
    individualId?: boolean
    company?: boolean | Admin$companyArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    company_code?: boolean
    companyId?: boolean
    individualId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password" | "account_type" | "company_name" | "created_at" | "updated_at" | "tokenExpiry" | "verificationToken" | "is_verified" | "resetToken" | "resetTokenExpiry" | "account_status" | "deleted_at" | "last_login" | "company_code" | "companyId" | "individualId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Admin$companyArgs<ExtArgs>
    company_employees?: boolean | Admin$company_employeesArgs<ExtArgs>
    individual?: boolean | Admin$individualArgs<ExtArgs>
    sites_created?: boolean | Admin$sites_createdArgs<ExtArgs>
    adminComplaints?: boolean | Admin$adminComplaintsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Admin$companyArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Admin$companyArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      company: Prisma.$companiesPayload<ExtArgs> | null
      company_employees: Prisma.$company_employeesPayload<ExtArgs> | null
      individual: Prisma.$individualsPayload<ExtArgs> | null
      sites_created: Prisma.$SitePayload<ExtArgs>[]
      adminComplaints: Prisma.$AdminComplaintPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      password: string
      account_type: $Enums.AccountType
      company_name: string | null
      created_at: Date
      updated_at: Date
      tokenExpiry: Date | null
      verificationToken: string | null
      is_verified: boolean
      resetToken: string | null
      resetTokenExpiry: Date | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
      company_code: string | null
      companyId: number | null
      individualId: number | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Admin$companyArgs<ExtArgs> = {}>(args?: Subset<T, Admin$companyArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company_employees<T extends Admin$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$company_employeesArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    individual<T extends Admin$individualArgs<ExtArgs> = {}>(args?: Subset<T, Admin$individualArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sites_created<T extends Admin$sites_createdArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sites_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminComplaints<T extends Admin$adminComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$adminComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly full_name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly account_type: FieldRef<"Admin", 'AccountType'>
    readonly company_name: FieldRef<"Admin", 'String'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
    readonly updated_at: FieldRef<"Admin", 'DateTime'>
    readonly tokenExpiry: FieldRef<"Admin", 'DateTime'>
    readonly verificationToken: FieldRef<"Admin", 'String'>
    readonly is_verified: FieldRef<"Admin", 'Boolean'>
    readonly resetToken: FieldRef<"Admin", 'String'>
    readonly resetTokenExpiry: FieldRef<"Admin", 'DateTime'>
    readonly account_status: FieldRef<"Admin", 'AccountStatus'>
    readonly deleted_at: FieldRef<"Admin", 'DateTime'>
    readonly last_login: FieldRef<"Admin", 'DateTime'>
    readonly company_code: FieldRef<"Admin", 'String'>
    readonly companyId: FieldRef<"Admin", 'Int'>
    readonly individualId: FieldRef<"Admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.company
   */
  export type Admin$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * Admin.company_employees
   */
  export type Admin$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
  }

  /**
   * Admin.individual
   */
  export type Admin$individualArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    where?: individualsWhereInput
  }

  /**
   * Admin.sites_created
   */
  export type Admin$sites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Admin.adminComplaints
   */
  export type Admin$adminComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    where?: AdminComplaintWhereInput
    orderBy?: AdminComplaintOrderByWithRelationInput | AdminComplaintOrderByWithRelationInput[]
    cursor?: AdminComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminComplaintScalarFieldEnum | AdminComplaintScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Site
   */

  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SiteSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SiteMinAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SiteMaxAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    site_id: number
    site_name: number
    site_address: number
    created_at: number
    updated_at: number
    adminId: number
    apartment_count: number
    block_count: number
    company_id: number
    deleted_at: number
    site_status: number
    _all: number
  }


  export type SiteAvgAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SiteSumAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SiteMinAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
    _all?: true
  }

  export type SiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithAggregationInput | SiteOrderByWithAggregationInput[]
    by: SiteScalarFieldEnum[] | SiteScalarFieldEnum
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _avg?: SiteAvgAggregateInputType
    _sum?: SiteSumAggregateInputType
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }

  export type SiteGroupByOutputType = {
    id: number
    site_id: string
    site_name: string
    site_address: string
    created_at: Date
    updated_at: Date
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    announcements?: boolean | Site$announcementsArgs<ExtArgs>
    blocks?: boolean | Site$blocksArgs<ExtArgs>
    complaints?: boolean | Site$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | Site$employee_site_accessArgs<ExtArgs>
    individuals?: boolean | Site$individualsArgs<ExtArgs>
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
    socialAmenities?: boolean | Site$socialAmenitiesArgs<ExtArgs>
    users?: boolean | Site$usersArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectScalar = {
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
  }

  export type SiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "site_id" | "site_name" | "site_address" | "created_at" | "updated_at" | "adminId" | "apartment_count" | "block_count" | "company_id" | "deleted_at" | "site_status", ExtArgs["result"]["site"]>
  export type SiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | Site$announcementsArgs<ExtArgs>
    blocks?: boolean | Site$blocksArgs<ExtArgs>
    complaints?: boolean | Site$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | Site$employee_site_accessArgs<ExtArgs>
    individuals?: boolean | Site$individualsArgs<ExtArgs>
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
    socialAmenities?: boolean | Site$socialAmenitiesArgs<ExtArgs>
    users?: boolean | Site$usersArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }
  export type SiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }

  export type $SitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Site"
    objects: {
      announcements: Prisma.$announcementsPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs>[]
      complaints: Prisma.$complaintsPayload<ExtArgs>[]
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
      individuals: Prisma.$individualsPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs> | null
      socialAmenities: Prisma.$SocialAmenityPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_id: string
      site_name: string
      site_address: string
      created_at: Date
      updated_at: Date
      adminId: number | null
      apartment_count: number | null
      block_count: number | null
      company_id: number | null
      deleted_at: Date | null
      site_status: $Enums.AccountStatus
    }, ExtArgs["result"]["site"]>
    composites: {}
  }

  type SiteGetPayload<S extends boolean | null | undefined | SiteDefaultArgs> = $Result.GetResult<Prisma.$SitePayload, S>

  type SiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Site'], meta: { name: 'Site' } }
    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteFindUniqueArgs>(args: SelectSubset<T, SiteFindUniqueArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Site that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteFindFirstArgs>(args?: SelectSubset<T, SiteFindFirstArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteFindManyArgs>(args?: SelectSubset<T, SiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
     */
    create<T extends SiteCreateArgs>(args: SelectSubset<T, SiteCreateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCreateManyArgs>(args?: SelectSubset<T, SiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {SiteCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
     */
    delete<T extends SiteDeleteArgs>(args: SelectSubset<T, SiteDeleteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteUpdateArgs>(args: SelectSubset<T, SiteUpdateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteDeleteManyArgs>(args?: SelectSubset<T, SiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteUpdateManyArgs>(args: SelectSubset<T, SiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {SiteUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
     */
    upsert<T extends SiteUpsertArgs>(args: SelectSubset<T, SiteUpsertArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Site model
   */
  readonly fields: SiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcements<T extends Site$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Site$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends Site$blocksArgs<ExtArgs> = {}>(args?: Subset<T, Site$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Site$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Site$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee_site_access<T extends Site$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, Site$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    individuals<T extends Site$individualsArgs<ExtArgs> = {}>(args?: Subset<T, Site$individualsArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends Site$adminArgs<ExtArgs> = {}>(args?: Subset<T, Site$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends Site$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Site$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    socialAmenities<T extends Site$socialAmenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Site$socialAmenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Site$usersArgs<ExtArgs> = {}>(args?: Subset<T, Site$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Site model
   */
  interface SiteFieldRefs {
    readonly id: FieldRef<"Site", 'Int'>
    readonly site_id: FieldRef<"Site", 'String'>
    readonly site_name: FieldRef<"Site", 'String'>
    readonly site_address: FieldRef<"Site", 'String'>
    readonly created_at: FieldRef<"Site", 'DateTime'>
    readonly updated_at: FieldRef<"Site", 'DateTime'>
    readonly adminId: FieldRef<"Site", 'Int'>
    readonly apartment_count: FieldRef<"Site", 'Int'>
    readonly block_count: FieldRef<"Site", 'Int'>
    readonly company_id: FieldRef<"Site", 'Int'>
    readonly deleted_at: FieldRef<"Site", 'DateTime'>
    readonly site_status: FieldRef<"Site", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * Site findUnique
   */
  export type SiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findFirst
   */
  export type SiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findMany
   */
  export type SiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site create
   */
  export type SiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }

  /**
   * Site createMany
   */
  export type SiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Site createManyAndReturn
   */
  export type SiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site update
   */
  export type SiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
  }

  /**
   * Site updateManyAndReturn
   */
  export type SiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site upsert
   */
  export type SiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }

  /**
   * Site delete
   */
  export type SiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to delete.
     */
    limit?: number
  }

  /**
   * Site.announcements
   */
  export type Site$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    cursor?: announcementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Site.blocks
   */
  export type Site$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    cursor?: blocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Site.complaints
   */
  export type Site$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Site.employee_site_access
   */
  export type Site$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * Site.individuals
   */
  export type Site$individualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    where?: individualsWhereInput
  }

  /**
   * Site.admin
   */
  export type Site$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Site.companies
   */
  export type Site$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * Site.socialAmenities
   */
  export type Site$socialAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    where?: SocialAmenityWhereInput
    orderBy?: SocialAmenityOrderByWithRelationInput | SocialAmenityOrderByWithRelationInput[]
    cursor?: SocialAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialAmenityScalarFieldEnum | SocialAmenityScalarFieldEnum[]
  }

  /**
   * Site.users
   */
  export type Site$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Site without action
   */
  export type SiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
  }


  /**
   * Model SocialAmenity
   */

  export type AggregateSocialAmenity = {
    _count: SocialAmenityCountAggregateOutputType | null
    _avg: SocialAmenityAvgAggregateOutputType | null
    _sum: SocialAmenitySumAggregateOutputType | null
    _min: SocialAmenityMinAggregateOutputType | null
    _max: SocialAmenityMaxAggregateOutputType | null
  }

  export type SocialAmenityAvgAggregateOutputType = {
    siteId: number | null
  }

  export type SocialAmenitySumAggregateOutputType = {
    siteId: number | null
  }

  export type SocialAmenityMinAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialAmenityMaxAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialAmenityCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    description: number
    status: number
    hours: number
    rules: number
    extra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialAmenityAvgAggregateInputType = {
    siteId?: true
  }

  export type SocialAmenitySumAggregateInputType = {
    siteId?: true
  }

  export type SocialAmenityMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialAmenityMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialAmenityCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialAmenity to aggregate.
     */
    where?: SocialAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAmenities to fetch.
     */
    orderBy?: SocialAmenityOrderByWithRelationInput | SocialAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialAmenities
    **/
    _count?: true | SocialAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialAmenityMaxAggregateInputType
  }

  export type GetSocialAmenityAggregateType<T extends SocialAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialAmenity[P]>
      : GetScalarType<T[P], AggregateSocialAmenity[P]>
  }




  export type SocialAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialAmenityWhereInput
    orderBy?: SocialAmenityOrderByWithAggregationInput | SocialAmenityOrderByWithAggregationInput[]
    by: SocialAmenityScalarFieldEnum[] | SocialAmenityScalarFieldEnum
    having?: SocialAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialAmenityCountAggregateInputType | true
    _avg?: SocialAmenityAvgAggregateInputType
    _sum?: SocialAmenitySumAggregateInputType
    _min?: SocialAmenityMinAggregateInputType
    _max?: SocialAmenityMaxAggregateInputType
  }

  export type SocialAmenityGroupByOutputType = {
    id: string
    siteId: number
    name: string
    description: string | null
    status: string
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date
    updatedAt: Date
    _count: SocialAmenityCountAggregateOutputType | null
    _avg: SocialAmenityAvgAggregateOutputType | null
    _sum: SocialAmenitySumAggregateOutputType | null
    _min: SocialAmenityMinAggregateOutputType | null
    _max: SocialAmenityMaxAggregateOutputType | null
  }

  type GetSocialAmenityGroupByPayload<T extends SocialAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], SocialAmenityGroupByOutputType[P]>
        }
      >
    >


  export type SocialAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAmenity"]>

  export type SocialAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAmenity"]>

  export type SocialAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAmenity"]>

  export type SocialAmenitySelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "name" | "description" | "status" | "hours" | "rules" | "extra" | "createdAt" | "updatedAt", ExtArgs["result"]["socialAmenity"]>
  export type SocialAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SocialAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type SocialAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $SocialAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialAmenity"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: number
      name: string
      description: string | null
      status: string
      hours: string | null
      rules: string | null
      extra: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialAmenity"]>
    composites: {}
  }

  type SocialAmenityGetPayload<S extends boolean | null | undefined | SocialAmenityDefaultArgs> = $Result.GetResult<Prisma.$SocialAmenityPayload, S>

  type SocialAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialAmenityCountAggregateInputType | true
    }

  export interface SocialAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialAmenity'], meta: { name: 'SocialAmenity' } }
    /**
     * Find zero or one SocialAmenity that matches the filter.
     * @param {SocialAmenityFindUniqueArgs} args - Arguments to find a SocialAmenity
     * @example
     * // Get one SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialAmenityFindUniqueArgs>(args: SelectSubset<T, SocialAmenityFindUniqueArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialAmenityFindUniqueOrThrowArgs} args - Arguments to find a SocialAmenity
     * @example
     * // Get one SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityFindFirstArgs} args - Arguments to find a SocialAmenity
     * @example
     * // Get one SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialAmenityFindFirstArgs>(args?: SelectSubset<T, SocialAmenityFindFirstArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityFindFirstOrThrowArgs} args - Arguments to find a SocialAmenity
     * @example
     * // Get one SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialAmenities
     * const socialAmenities = await prisma.socialAmenity.findMany()
     * 
     * // Get first 10 SocialAmenities
     * const socialAmenities = await prisma.socialAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialAmenityWithIdOnly = await prisma.socialAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialAmenityFindManyArgs>(args?: SelectSubset<T, SocialAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialAmenity.
     * @param {SocialAmenityCreateArgs} args - Arguments to create a SocialAmenity.
     * @example
     * // Create one SocialAmenity
     * const SocialAmenity = await prisma.socialAmenity.create({
     *   data: {
     *     // ... data to create a SocialAmenity
     *   }
     * })
     * 
     */
    create<T extends SocialAmenityCreateArgs>(args: SelectSubset<T, SocialAmenityCreateArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialAmenities.
     * @param {SocialAmenityCreateManyArgs} args - Arguments to create many SocialAmenities.
     * @example
     * // Create many SocialAmenities
     * const socialAmenity = await prisma.socialAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialAmenityCreateManyArgs>(args?: SelectSubset<T, SocialAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialAmenities and returns the data saved in the database.
     * @param {SocialAmenityCreateManyAndReturnArgs} args - Arguments to create many SocialAmenities.
     * @example
     * // Create many SocialAmenities
     * const socialAmenity = await prisma.socialAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialAmenities and only return the `id`
     * const socialAmenityWithIdOnly = await prisma.socialAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialAmenity.
     * @param {SocialAmenityDeleteArgs} args - Arguments to delete one SocialAmenity.
     * @example
     * // Delete one SocialAmenity
     * const SocialAmenity = await prisma.socialAmenity.delete({
     *   where: {
     *     // ... filter to delete one SocialAmenity
     *   }
     * })
     * 
     */
    delete<T extends SocialAmenityDeleteArgs>(args: SelectSubset<T, SocialAmenityDeleteArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialAmenity.
     * @param {SocialAmenityUpdateArgs} args - Arguments to update one SocialAmenity.
     * @example
     * // Update one SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialAmenityUpdateArgs>(args: SelectSubset<T, SocialAmenityUpdateArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialAmenities.
     * @param {SocialAmenityDeleteManyArgs} args - Arguments to filter SocialAmenities to delete.
     * @example
     * // Delete a few SocialAmenities
     * const { count } = await prisma.socialAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialAmenityDeleteManyArgs>(args?: SelectSubset<T, SocialAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialAmenities
     * const socialAmenity = await prisma.socialAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialAmenityUpdateManyArgs>(args: SelectSubset<T, SocialAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialAmenities and returns the data updated in the database.
     * @param {SocialAmenityUpdateManyAndReturnArgs} args - Arguments to update many SocialAmenities.
     * @example
     * // Update many SocialAmenities
     * const socialAmenity = await prisma.socialAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialAmenities and only return the `id`
     * const socialAmenityWithIdOnly = await prisma.socialAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialAmenity.
     * @param {SocialAmenityUpsertArgs} args - Arguments to update or create a SocialAmenity.
     * @example
     * // Update or create a SocialAmenity
     * const socialAmenity = await prisma.socialAmenity.upsert({
     *   create: {
     *     // ... data to create a SocialAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialAmenity we want to update
     *   }
     * })
     */
    upsert<T extends SocialAmenityUpsertArgs>(args: SelectSubset<T, SocialAmenityUpsertArgs<ExtArgs>>): Prisma__SocialAmenityClient<$Result.GetResult<Prisma.$SocialAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityCountArgs} args - Arguments to filter SocialAmenities to count.
     * @example
     * // Count the number of SocialAmenities
     * const count = await prisma.socialAmenity.count({
     *   where: {
     *     // ... the filter for the SocialAmenities we want to count
     *   }
     * })
    **/
    count<T extends SocialAmenityCountArgs>(
      args?: Subset<T, SocialAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialAmenityAggregateArgs>(args: Subset<T, SocialAmenityAggregateArgs>): Prisma.PrismaPromise<GetSocialAmenityAggregateType<T>>

    /**
     * Group by SocialAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialAmenityGroupByArgs['orderBy'] }
        : { orderBy?: SocialAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialAmenity model
   */
  readonly fields: SocialAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialAmenity model
   */
  interface SocialAmenityFieldRefs {
    readonly id: FieldRef<"SocialAmenity", 'String'>
    readonly siteId: FieldRef<"SocialAmenity", 'Int'>
    readonly name: FieldRef<"SocialAmenity", 'String'>
    readonly description: FieldRef<"SocialAmenity", 'String'>
    readonly status: FieldRef<"SocialAmenity", 'String'>
    readonly hours: FieldRef<"SocialAmenity", 'String'>
    readonly rules: FieldRef<"SocialAmenity", 'String'>
    readonly extra: FieldRef<"SocialAmenity", 'String'>
    readonly createdAt: FieldRef<"SocialAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialAmenity findUnique
   */
  export type SocialAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter, which SocialAmenity to fetch.
     */
    where: SocialAmenityWhereUniqueInput
  }

  /**
   * SocialAmenity findUniqueOrThrow
   */
  export type SocialAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter, which SocialAmenity to fetch.
     */
    where: SocialAmenityWhereUniqueInput
  }

  /**
   * SocialAmenity findFirst
   */
  export type SocialAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter, which SocialAmenity to fetch.
     */
    where?: SocialAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAmenities to fetch.
     */
    orderBy?: SocialAmenityOrderByWithRelationInput | SocialAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialAmenities.
     */
    cursor?: SocialAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialAmenities.
     */
    distinct?: SocialAmenityScalarFieldEnum | SocialAmenityScalarFieldEnum[]
  }

  /**
   * SocialAmenity findFirstOrThrow
   */
  export type SocialAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter, which SocialAmenity to fetch.
     */
    where?: SocialAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAmenities to fetch.
     */
    orderBy?: SocialAmenityOrderByWithRelationInput | SocialAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialAmenities.
     */
    cursor?: SocialAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialAmenities.
     */
    distinct?: SocialAmenityScalarFieldEnum | SocialAmenityScalarFieldEnum[]
  }

  /**
   * SocialAmenity findMany
   */
  export type SocialAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter, which SocialAmenities to fetch.
     */
    where?: SocialAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAmenities to fetch.
     */
    orderBy?: SocialAmenityOrderByWithRelationInput | SocialAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialAmenities.
     */
    cursor?: SocialAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAmenities.
     */
    skip?: number
    distinct?: SocialAmenityScalarFieldEnum | SocialAmenityScalarFieldEnum[]
  }

  /**
   * SocialAmenity create
   */
  export type SocialAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialAmenity.
     */
    data: XOR<SocialAmenityCreateInput, SocialAmenityUncheckedCreateInput>
  }

  /**
   * SocialAmenity createMany
   */
  export type SocialAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialAmenities.
     */
    data: SocialAmenityCreateManyInput | SocialAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialAmenity createManyAndReturn
   */
  export type SocialAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many SocialAmenities.
     */
    data: SocialAmenityCreateManyInput | SocialAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialAmenity update
   */
  export type SocialAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialAmenity.
     */
    data: XOR<SocialAmenityUpdateInput, SocialAmenityUncheckedUpdateInput>
    /**
     * Choose, which SocialAmenity to update.
     */
    where: SocialAmenityWhereUniqueInput
  }

  /**
   * SocialAmenity updateMany
   */
  export type SocialAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialAmenities.
     */
    data: XOR<SocialAmenityUpdateManyMutationInput, SocialAmenityUncheckedUpdateManyInput>
    /**
     * Filter which SocialAmenities to update
     */
    where?: SocialAmenityWhereInput
    /**
     * Limit how many SocialAmenities to update.
     */
    limit?: number
  }

  /**
   * SocialAmenity updateManyAndReturn
   */
  export type SocialAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * The data used to update SocialAmenities.
     */
    data: XOR<SocialAmenityUpdateManyMutationInput, SocialAmenityUncheckedUpdateManyInput>
    /**
     * Filter which SocialAmenities to update
     */
    where?: SocialAmenityWhereInput
    /**
     * Limit how many SocialAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialAmenity upsert
   */
  export type SocialAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialAmenity to update in case it exists.
     */
    where: SocialAmenityWhereUniqueInput
    /**
     * In case the SocialAmenity found by the `where` argument doesn't exist, create a new SocialAmenity with this data.
     */
    create: XOR<SocialAmenityCreateInput, SocialAmenityUncheckedCreateInput>
    /**
     * In case the SocialAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialAmenityUpdateInput, SocialAmenityUncheckedUpdateInput>
  }

  /**
   * SocialAmenity delete
   */
  export type SocialAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
    /**
     * Filter which SocialAmenity to delete.
     */
    where: SocialAmenityWhereUniqueInput
  }

  /**
   * SocialAmenity deleteMany
   */
  export type SocialAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialAmenities to delete
     */
    where?: SocialAmenityWhereInput
    /**
     * Limit how many SocialAmenities to delete.
     */
    limit?: number
  }

  /**
   * SocialAmenity without action
   */
  export type SocialAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAmenity
     */
    select?: SocialAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAmenity
     */
    omit?: SocialAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAmenityInclude<ExtArgs> | null
  }


  /**
   * Model announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _avg: AnnouncementsAvgAggregateOutputType | null
    _sum: AnnouncementsSumAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementsSumAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    created_at: number
    updated_at: number
    siteId: number
    start_date: number
    end_date: number
    _all: number
  }


  export type AnnouncementsAvgAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementsSumAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to aggregate.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type announcementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithAggregationInput | announcementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: announcementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _avg?: AnnouncementsAvgAggregateInputType
    _sum?: AnnouncementsSumAggregateInputType
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: number
    title: string
    content: string
    created_at: Date
    updated_at: Date
    siteId: number
    start_date: Date
    end_date: Date
    _count: AnnouncementsCountAggregateOutputType | null
    _avg: AnnouncementsAvgAggregateOutputType | null
    _sum: AnnouncementsSumAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends announcementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type announcementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
  }

  export type announcementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "created_at" | "updated_at" | "siteId" | "start_date" | "end_date", ExtArgs["result"]["announcements"]>
  export type announcementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type announcementsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type announcementsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $announcementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "announcements"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      created_at: Date
      updated_at: Date
      siteId: number
      start_date: Date
      end_date: Date
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type announcementsGetPayload<S extends boolean | null | undefined | announcementsDefaultArgs> = $Result.GetResult<Prisma.$announcementsPayload, S>

  type announcementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<announcementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface announcementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['announcements'], meta: { name: 'announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {announcementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends announcementsFindUniqueArgs>(args: SelectSubset<T, announcementsFindUniqueArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {announcementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends announcementsFindUniqueOrThrowArgs>(args: SelectSubset<T, announcementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends announcementsFindFirstArgs>(args?: SelectSubset<T, announcementsFindFirstArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends announcementsFindFirstOrThrowArgs>(args?: SelectSubset<T, announcementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends announcementsFindManyArgs>(args?: SelectSubset<T, announcementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {announcementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends announcementsCreateArgs>(args: SelectSubset<T, announcementsCreateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {announcementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends announcementsCreateManyArgs>(args?: SelectSubset<T, announcementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {announcementsCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends announcementsCreateManyAndReturnArgs>(args?: SelectSubset<T, announcementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcements.
     * @param {announcementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends announcementsDeleteArgs>(args: SelectSubset<T, announcementsDeleteArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {announcementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends announcementsUpdateArgs>(args: SelectSubset<T, announcementsUpdateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {announcementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends announcementsDeleteManyArgs>(args?: SelectSubset<T, announcementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends announcementsUpdateManyArgs>(args: SelectSubset<T, announcementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {announcementsUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends announcementsUpdateManyAndReturnArgs>(args: SelectSubset<T, announcementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcements.
     * @param {announcementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends announcementsUpsertArgs>(args: SelectSubset<T, announcementsUpsertArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementsCountArgs>(
      args?: Subset<T, announcementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends announcementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: announcementsGroupByArgs['orderBy'] }
        : { orderBy?: announcementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, announcementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the announcements model
   */
  readonly fields: announcementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__announcementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the announcements model
   */
  interface announcementsFieldRefs {
    readonly id: FieldRef<"announcements", 'Int'>
    readonly title: FieldRef<"announcements", 'String'>
    readonly content: FieldRef<"announcements", 'String'>
    readonly created_at: FieldRef<"announcements", 'DateTime'>
    readonly updated_at: FieldRef<"announcements", 'DateTime'>
    readonly siteId: FieldRef<"announcements", 'Int'>
    readonly start_date: FieldRef<"announcements", 'DateTime'>
    readonly end_date: FieldRef<"announcements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * announcements findUnique
   */
  export type announcementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findUniqueOrThrow
   */
  export type announcementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findFirst
   */
  export type announcementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findFirstOrThrow
   */
  export type announcementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findMany
   */
  export type announcementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements create
   */
  export type announcementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The data needed to create a announcements.
     */
    data: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
  }

  /**
   * announcements createMany
   */
  export type announcementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements createManyAndReturn
   */
  export type announcementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * announcements update
   */
  export type announcementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The data needed to update a announcements.
     */
    data: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
    /**
     * Choose, which announcements to update.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements updateMany
   */
  export type announcementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements updateManyAndReturn
   */
  export type announcementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * announcements upsert
   */
  export type announcementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The filter to search for the announcements to update in case it exists.
     */
    where: announcementsWhereUniqueInput
    /**
     * In case the announcements found by the `where` argument doesn't exist, create a new announcements with this data.
     */
    create: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
    /**
     * In case the announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
  }

  /**
   * announcements delete
   */
  export type announcementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter which announcements to delete.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements deleteMany
   */
  export type announcementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to delete
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to delete.
     */
    limit?: number
  }

  /**
   * announcements without action
   */
  export type announcementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
  }


  /**
   * Model blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    id: number | null
    site_id: number | null
    block_number: number | null
    apartment_count: number | null
  }

  export type BlocksSumAggregateOutputType = {
    id: number | null
    site_id: number | null
    block_number: number | null
    apartment_count: number | null
  }

  export type BlocksMinAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
    block_number: number | null
    deleted_at: Date | null
    updated_at: Date | null
    apartment_count: number | null
  }

  export type BlocksMaxAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
    block_number: number | null
    deleted_at: Date | null
    updated_at: Date | null
    apartment_count: number | null
  }

  export type BlocksCountAggregateOutputType = {
    id: number
    block_name: number
    site_id: number
    created_at: number
    block_number: number
    deleted_at: number
    updated_at: number
    apartment_count: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    id?: true
    site_id?: true
    block_number?: true
    apartment_count?: true
  }

  export type BlocksSumAggregateInputType = {
    id?: true
    site_id?: true
    block_number?: true
    apartment_count?: true
  }

  export type BlocksMinAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
    block_number?: true
    deleted_at?: true
    updated_at?: true
    apartment_count?: true
  }

  export type BlocksMaxAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
    block_number?: true
    deleted_at?: true
    updated_at?: true
    apartment_count?: true
  }

  export type BlocksCountAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
    block_number?: true
    deleted_at?: true
    updated_at?: true
    apartment_count?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to aggregate.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type blocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithAggregationInput | blocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    id: number
    block_name: string
    site_id: number
    created_at: Date
    block_number: number | null
    deleted_at: Date | null
    updated_at: Date
    apartment_count: number | null
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends blocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    block_number?: boolean
    deleted_at?: boolean
    updated_at?: boolean
    apartment_count?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    block_number?: boolean
    deleted_at?: boolean
    updated_at?: boolean
    apartment_count?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    block_number?: boolean
    deleted_at?: boolean
    updated_at?: boolean
    apartment_count?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectScalar = {
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    block_number?: boolean
    deleted_at?: boolean
    updated_at?: boolean
    apartment_count?: boolean
  }

  export type blocksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block_name" | "site_id" | "created_at" | "block_number" | "deleted_at" | "updated_at" | "apartment_count", ExtArgs["result"]["blocks"]>
  export type blocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type blocksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type blocksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $blocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blocks"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block_name: string
      site_id: number
      created_at: Date
      block_number: number | null
      deleted_at: Date | null
      updated_at: Date
      apartment_count: number | null
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }

  type blocksGetPayload<S extends boolean | null | undefined | blocksDefaultArgs> = $Result.GetResult<Prisma.$blocksPayload, S>

  type blocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blocksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface blocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blocks'], meta: { name: 'blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blocksFindUniqueArgs>(args: SelectSubset<T, blocksFindUniqueArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs>(args: SelectSubset<T, blocksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blocksFindFirstArgs>(args?: SelectSubset<T, blocksFindFirstArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs>(args?: SelectSubset<T, blocksFindFirstOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blocksWithIdOnly = await prisma.blocks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blocksFindManyArgs>(args?: SelectSubset<T, blocksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
     */
    create<T extends blocksCreateArgs>(args: SelectSubset<T, blocksCreateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blocksCreateManyArgs>(args?: SelectSubset<T, blocksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {blocksCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blocksCreateManyAndReturnArgs>(args?: SelectSubset<T, blocksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
     */
    delete<T extends blocksDeleteArgs>(args: SelectSubset<T, blocksDeleteArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blocksUpdateArgs>(args: SelectSubset<T, blocksUpdateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blocksDeleteManyArgs>(args?: SelectSubset<T, blocksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blocksUpdateManyArgs>(args: SelectSubset<T, blocksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {blocksUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blocksUpdateManyAndReturnArgs>(args: SelectSubset<T, blocksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
     */
    upsert<T extends blocksUpsertArgs>(args: SelectSubset<T, blocksUpsertArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blocksGroupByArgs['orderBy'] }
        : { orderBy?: blocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blocks model
   */
  readonly fields: blocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends blocks$usersArgs<ExtArgs> = {}>(args?: Subset<T, blocks$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blocks model
   */
  interface blocksFieldRefs {
    readonly id: FieldRef<"blocks", 'Int'>
    readonly block_name: FieldRef<"blocks", 'String'>
    readonly site_id: FieldRef<"blocks", 'Int'>
    readonly created_at: FieldRef<"blocks", 'DateTime'>
    readonly block_number: FieldRef<"blocks", 'Int'>
    readonly deleted_at: FieldRef<"blocks", 'DateTime'>
    readonly updated_at: FieldRef<"blocks", 'DateTime'>
    readonly apartment_count: FieldRef<"blocks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * blocks findUnique
   */
  export type blocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findFirst
   */
  export type blocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findMany
   */
  export type blocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks create
   */
  export type blocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to create a blocks.
     */
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }

  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blocks createManyAndReturn
   */
  export type blocksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks update
   */
  export type blocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to update a blocks.
     */
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
  }

  /**
   * blocks updateManyAndReturn
   */
  export type blocksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks upsert
   */
  export type blocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The filter to search for the blocks to update in case it exists.
     */
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     */
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }

  /**
   * blocks delete
   */
  export type blocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter which blocks to delete.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to delete.
     */
    limit?: number
  }

  /**
   * blocks.users
   */
  export type blocks$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * blocks without action
   */
  export type blocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    expiry_date: Date | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    expiry_date: Date | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    company_name: number
    company_code: number
    account_status: number
    created_at: number
    updated_at: number
    deleted_at: number
    expiry_date: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: number
    company_name: string
    company_code: string
    account_status: $Enums.AccountStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    expiry_date: Date | null
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
    admins?: boolean | companies$adminsArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "company_code" | "account_status" | "created_at" | "updated_at" | "deleted_at" | "expiry_date", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | companies$adminsArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>[]
      company_employees: Prisma.$company_employeesPayload<ExtArgs>[]
      invitations: Prisma.$invitationsPayload<ExtArgs>[]
      sites: Prisma.$SitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_name: string
      company_code: string
      account_status: $Enums.AccountStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      expiry_date: Date | null
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends companies$adminsArgs<ExtArgs> = {}>(args?: Subset<T, companies$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_employees<T extends companies$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends companies$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, companies$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sites<T extends companies$sitesArgs<ExtArgs> = {}>(args?: Subset<T, companies$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'Int'>
    readonly company_name: FieldRef<"companies", 'String'>
    readonly company_code: FieldRef<"companies", 'String'>
    readonly account_status: FieldRef<"companies", 'AccountStatus'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
    readonly deleted_at: FieldRef<"companies", 'DateTime'>
    readonly expiry_date: FieldRef<"companies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.admins
   */
  export type companies$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * companies.company_employees
   */
  export type companies$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    cursor?: company_employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * companies.invitations
   */
  export type companies$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    cursor?: invitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * companies.sites
   */
  export type companies$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model individuals
   */

  export type AggregateIndividuals = {
    _count: IndividualsCountAggregateOutputType | null
    _avg: IndividualsAvgAggregateOutputType | null
    _sum: IndividualsSumAggregateOutputType | null
    _min: IndividualsMinAggregateOutputType | null
    _max: IndividualsMaxAggregateOutputType | null
  }

  export type IndividualsAvgAggregateOutputType = {
    id: number | null
    site_id: number | null
    admin_id: number | null
  }

  export type IndividualsSumAggregateOutputType = {
    id: number | null
    site_id: number | null
    admin_id: number | null
  }

  export type IndividualsMinAggregateOutputType = {
    id: number | null
    site_id: number | null
    admin_id: number | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    expiry_date: Date | null
  }

  export type IndividualsMaxAggregateOutputType = {
    id: number | null
    site_id: number | null
    admin_id: number | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    expiry_date: Date | null
  }

  export type IndividualsCountAggregateOutputType = {
    id: number
    site_id: number
    admin_id: number
    account_status: number
    created_at: number
    updated_at: number
    deleted_at: number
    expiry_date: number
    _all: number
  }


  export type IndividualsAvgAggregateInputType = {
    id?: true
    site_id?: true
    admin_id?: true
  }

  export type IndividualsSumAggregateInputType = {
    id?: true
    site_id?: true
    admin_id?: true
  }

  export type IndividualsMinAggregateInputType = {
    id?: true
    site_id?: true
    admin_id?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
  }

  export type IndividualsMaxAggregateInputType = {
    id?: true
    site_id?: true
    admin_id?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
  }

  export type IndividualsCountAggregateInputType = {
    id?: true
    site_id?: true
    admin_id?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    expiry_date?: true
    _all?: true
  }

  export type IndividualsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which individuals to aggregate.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned individuals
    **/
    _count?: true | IndividualsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndividualsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndividualsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndividualsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndividualsMaxAggregateInputType
  }

  export type GetIndividualsAggregateType<T extends IndividualsAggregateArgs> = {
        [P in keyof T & keyof AggregateIndividuals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividuals[P]>
      : GetScalarType<T[P], AggregateIndividuals[P]>
  }




  export type individualsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: individualsWhereInput
    orderBy?: individualsOrderByWithAggregationInput | individualsOrderByWithAggregationInput[]
    by: IndividualsScalarFieldEnum[] | IndividualsScalarFieldEnum
    having?: individualsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndividualsCountAggregateInputType | true
    _avg?: IndividualsAvgAggregateInputType
    _sum?: IndividualsSumAggregateInputType
    _min?: IndividualsMinAggregateInputType
    _max?: IndividualsMaxAggregateInputType
  }

  export type IndividualsGroupByOutputType = {
    id: number
    site_id: number | null
    admin_id: number
    account_status: $Enums.AccountStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    expiry_date: Date | null
    _count: IndividualsCountAggregateOutputType | null
    _avg: IndividualsAvgAggregateOutputType | null
    _sum: IndividualsSumAggregateOutputType | null
    _min: IndividualsMinAggregateOutputType | null
    _max: IndividualsMaxAggregateOutputType | null
  }

  type GetIndividualsGroupByPayload<T extends individualsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndividualsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndividualsGroupByOutputType[P]>
            : GetScalarType<T[P], IndividualsGroupByOutputType[P]>
        }
      >
    >


  export type individualsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    admin_id?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }, ExtArgs["result"]["individuals"]>

  export type individualsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    admin_id?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }, ExtArgs["result"]["individuals"]>

  export type individualsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    admin_id?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }, ExtArgs["result"]["individuals"]>

  export type individualsSelectScalar = {
    id?: boolean
    site_id?: boolean
    admin_id?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    expiry_date?: boolean
  }

  export type individualsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "site_id" | "admin_id" | "account_status" | "created_at" | "updated_at" | "deleted_at" | "expiry_date", ExtArgs["result"]["individuals"]>
  export type individualsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }
  export type individualsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }
  export type individualsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    site?: boolean | individuals$siteArgs<ExtArgs>
  }

  export type $individualsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "individuals"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_id: number | null
      admin_id: number
      account_status: $Enums.AccountStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      expiry_date: Date | null
    }, ExtArgs["result"]["individuals"]>
    composites: {}
  }

  type individualsGetPayload<S extends boolean | null | undefined | individualsDefaultArgs> = $Result.GetResult<Prisma.$individualsPayload, S>

  type individualsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<individualsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndividualsCountAggregateInputType | true
    }

  export interface individualsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['individuals'], meta: { name: 'individuals' } }
    /**
     * Find zero or one Individuals that matches the filter.
     * @param {individualsFindUniqueArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends individualsFindUniqueArgs>(args: SelectSubset<T, individualsFindUniqueArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Individuals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {individualsFindUniqueOrThrowArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends individualsFindUniqueOrThrowArgs>(args: SelectSubset<T, individualsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Individuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindFirstArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends individualsFindFirstArgs>(args?: SelectSubset<T, individualsFindFirstArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Individuals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindFirstOrThrowArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends individualsFindFirstOrThrowArgs>(args?: SelectSubset<T, individualsFindFirstOrThrowArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Individuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Individuals
     * const individuals = await prisma.individuals.findMany()
     * 
     * // Get first 10 Individuals
     * const individuals = await prisma.individuals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const individualsWithIdOnly = await prisma.individuals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends individualsFindManyArgs>(args?: SelectSubset<T, individualsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Individuals.
     * @param {individualsCreateArgs} args - Arguments to create a Individuals.
     * @example
     * // Create one Individuals
     * const Individuals = await prisma.individuals.create({
     *   data: {
     *     // ... data to create a Individuals
     *   }
     * })
     * 
     */
    create<T extends individualsCreateArgs>(args: SelectSubset<T, individualsCreateArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Individuals.
     * @param {individualsCreateManyArgs} args - Arguments to create many Individuals.
     * @example
     * // Create many Individuals
     * const individuals = await prisma.individuals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends individualsCreateManyArgs>(args?: SelectSubset<T, individualsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Individuals and returns the data saved in the database.
     * @param {individualsCreateManyAndReturnArgs} args - Arguments to create many Individuals.
     * @example
     * // Create many Individuals
     * const individuals = await prisma.individuals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Individuals and only return the `id`
     * const individualsWithIdOnly = await prisma.individuals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends individualsCreateManyAndReturnArgs>(args?: SelectSubset<T, individualsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Individuals.
     * @param {individualsDeleteArgs} args - Arguments to delete one Individuals.
     * @example
     * // Delete one Individuals
     * const Individuals = await prisma.individuals.delete({
     *   where: {
     *     // ... filter to delete one Individuals
     *   }
     * })
     * 
     */
    delete<T extends individualsDeleteArgs>(args: SelectSubset<T, individualsDeleteArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Individuals.
     * @param {individualsUpdateArgs} args - Arguments to update one Individuals.
     * @example
     * // Update one Individuals
     * const individuals = await prisma.individuals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends individualsUpdateArgs>(args: SelectSubset<T, individualsUpdateArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Individuals.
     * @param {individualsDeleteManyArgs} args - Arguments to filter Individuals to delete.
     * @example
     * // Delete a few Individuals
     * const { count } = await prisma.individuals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends individualsDeleteManyArgs>(args?: SelectSubset<T, individualsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Individuals
     * const individuals = await prisma.individuals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends individualsUpdateManyArgs>(args: SelectSubset<T, individualsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Individuals and returns the data updated in the database.
     * @param {individualsUpdateManyAndReturnArgs} args - Arguments to update many Individuals.
     * @example
     * // Update many Individuals
     * const individuals = await prisma.individuals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Individuals and only return the `id`
     * const individualsWithIdOnly = await prisma.individuals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends individualsUpdateManyAndReturnArgs>(args: SelectSubset<T, individualsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Individuals.
     * @param {individualsUpsertArgs} args - Arguments to update or create a Individuals.
     * @example
     * // Update or create a Individuals
     * const individuals = await prisma.individuals.upsert({
     *   create: {
     *     // ... data to create a Individuals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Individuals we want to update
     *   }
     * })
     */
    upsert<T extends individualsUpsertArgs>(args: SelectSubset<T, individualsUpsertArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsCountArgs} args - Arguments to filter Individuals to count.
     * @example
     * // Count the number of Individuals
     * const count = await prisma.individuals.count({
     *   where: {
     *     // ... the filter for the Individuals we want to count
     *   }
     * })
    **/
    count<T extends individualsCountArgs>(
      args?: Subset<T, individualsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndividualsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndividualsAggregateArgs>(args: Subset<T, IndividualsAggregateArgs>): Prisma.PrismaPromise<GetIndividualsAggregateType<T>>

    /**
     * Group by Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends individualsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: individualsGroupByArgs['orderBy'] }
        : { orderBy?: individualsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, individualsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndividualsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the individuals model
   */
  readonly fields: individualsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for individuals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__individualsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends individuals$siteArgs<ExtArgs> = {}>(args?: Subset<T, individuals$siteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the individuals model
   */
  interface individualsFieldRefs {
    readonly id: FieldRef<"individuals", 'Int'>
    readonly site_id: FieldRef<"individuals", 'Int'>
    readonly admin_id: FieldRef<"individuals", 'Int'>
    readonly account_status: FieldRef<"individuals", 'AccountStatus'>
    readonly created_at: FieldRef<"individuals", 'DateTime'>
    readonly updated_at: FieldRef<"individuals", 'DateTime'>
    readonly deleted_at: FieldRef<"individuals", 'DateTime'>
    readonly expiry_date: FieldRef<"individuals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * individuals findUnique
   */
  export type individualsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where: individualsWhereUniqueInput
  }

  /**
   * individuals findUniqueOrThrow
   */
  export type individualsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where: individualsWhereUniqueInput
  }

  /**
   * individuals findFirst
   */
  export type individualsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of individuals.
     */
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }

  /**
   * individuals findFirstOrThrow
   */
  export type individualsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of individuals.
     */
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }

  /**
   * individuals findMany
   */
  export type individualsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }

  /**
   * individuals create
   */
  export type individualsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The data needed to create a individuals.
     */
    data: XOR<individualsCreateInput, individualsUncheckedCreateInput>
  }

  /**
   * individuals createMany
   */
  export type individualsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many individuals.
     */
    data: individualsCreateManyInput | individualsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * individuals createManyAndReturn
   */
  export type individualsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * The data used to create many individuals.
     */
    data: individualsCreateManyInput | individualsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * individuals update
   */
  export type individualsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The data needed to update a individuals.
     */
    data: XOR<individualsUpdateInput, individualsUncheckedUpdateInput>
    /**
     * Choose, which individuals to update.
     */
    where: individualsWhereUniqueInput
  }

  /**
   * individuals updateMany
   */
  export type individualsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update individuals.
     */
    data: XOR<individualsUpdateManyMutationInput, individualsUncheckedUpdateManyInput>
    /**
     * Filter which individuals to update
     */
    where?: individualsWhereInput
    /**
     * Limit how many individuals to update.
     */
    limit?: number
  }

  /**
   * individuals updateManyAndReturn
   */
  export type individualsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * The data used to update individuals.
     */
    data: XOR<individualsUpdateManyMutationInput, individualsUncheckedUpdateManyInput>
    /**
     * Filter which individuals to update
     */
    where?: individualsWhereInput
    /**
     * Limit how many individuals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * individuals upsert
   */
  export type individualsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The filter to search for the individuals to update in case it exists.
     */
    where: individualsWhereUniqueInput
    /**
     * In case the individuals found by the `where` argument doesn't exist, create a new individuals with this data.
     */
    create: XOR<individualsCreateInput, individualsUncheckedCreateInput>
    /**
     * In case the individuals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<individualsUpdateInput, individualsUncheckedUpdateInput>
  }

  /**
   * individuals delete
   */
  export type individualsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter which individuals to delete.
     */
    where: individualsWhereUniqueInput
  }

  /**
   * individuals deleteMany
   */
  export type individualsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which individuals to delete
     */
    where?: individualsWhereInput
    /**
     * Limit how many individuals to delete.
     */
    limit?: number
  }

  /**
   * individuals.site
   */
  export type individuals$siteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
  }

  /**
   * individuals without action
   */
  export type individualsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the individuals
     */
    omit?: individualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: individualsInclude<ExtArgs> | null
  }


  /**
   * Model company_employees
   */

  export type AggregateCompany_employees = {
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  export type Company_employeesAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
    deleted_at: Date | null
  }

  export type Company_employeesMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
    deleted_at: Date | null
  }

  export type Company_employeesCountAggregateOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: number
    status: number
    deleted_at: number
    _all: number
  }


  export type Company_employeesAvgAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesSumAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesMinAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
    deleted_at?: true
  }

  export type Company_employeesMaxAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
    deleted_at?: true
  }

  export type Company_employeesCountAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
    deleted_at?: true
    _all?: true
  }

  export type Company_employeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to aggregate.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_employees
    **/
    _count?: true | Company_employeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_employeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_employeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_employeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_employeesMaxAggregateInputType
  }

  export type GetCompany_employeesAggregateType<T extends Company_employeesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_employees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_employees[P]>
      : GetScalarType<T[P], AggregateCompany_employees[P]>
  }




  export type company_employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithAggregationInput | company_employeesOrderByWithAggregationInput[]
    by: Company_employeesScalarFieldEnum[] | Company_employeesScalarFieldEnum
    having?: company_employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_employeesCountAggregateInputType | true
    _avg?: Company_employeesAvgAggregateInputType
    _sum?: Company_employeesSumAggregateInputType
    _min?: Company_employeesMinAggregateInputType
    _max?: Company_employeesMaxAggregateInputType
  }

  export type Company_employeesGroupByOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: Date
    status: $Enums.AccountStatus
    deleted_at: Date | null
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  type GetCompany_employeesGroupByPayload<T extends company_employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_employeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_employeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
        }
      >
    >


  export type company_employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    deleted_at?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    deleted_at?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    deleted_at?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectScalar = {
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    deleted_at?: boolean
  }

  export type company_employeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "company_id" | "joined_at" | "status" | "deleted_at", ExtArgs["result"]["company_employees"]>
  export type company_employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_employees"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      company_id: number
      joined_at: Date
      status: $Enums.AccountStatus
      deleted_at: Date | null
    }, ExtArgs["result"]["company_employees"]>
    composites: {}
  }

  type company_employeesGetPayload<S extends boolean | null | undefined | company_employeesDefaultArgs> = $Result.GetResult<Prisma.$company_employeesPayload, S>

  type company_employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_employeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_employeesCountAggregateInputType | true
    }

  export interface company_employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_employees'], meta: { name: 'company_employees' } }
    /**
     * Find zero or one Company_employees that matches the filter.
     * @param {company_employeesFindUniqueArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_employeesFindUniqueArgs>(args: SelectSubset<T, company_employeesFindUniqueArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_employeesFindUniqueOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_employeesFindFirstArgs>(args?: SelectSubset<T, company_employeesFindFirstArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_employees
     * const company_employees = await prisma.company_employees.findMany()
     * 
     * // Get first 10 Company_employees
     * const company_employees = await prisma.company_employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_employeesFindManyArgs>(args?: SelectSubset<T, company_employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_employees.
     * @param {company_employeesCreateArgs} args - Arguments to create a Company_employees.
     * @example
     * // Create one Company_employees
     * const Company_employees = await prisma.company_employees.create({
     *   data: {
     *     // ... data to create a Company_employees
     *   }
     * })
     * 
     */
    create<T extends company_employeesCreateArgs>(args: SelectSubset<T, company_employeesCreateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_employees.
     * @param {company_employeesCreateManyArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_employeesCreateManyArgs>(args?: SelectSubset<T, company_employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_employees and returns the data saved in the database.
     * @param {company_employeesCreateManyAndReturnArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_employeesCreateManyAndReturnArgs>(args?: SelectSubset<T, company_employeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_employees.
     * @param {company_employeesDeleteArgs} args - Arguments to delete one Company_employees.
     * @example
     * // Delete one Company_employees
     * const Company_employees = await prisma.company_employees.delete({
     *   where: {
     *     // ... filter to delete one Company_employees
     *   }
     * })
     * 
     */
    delete<T extends company_employeesDeleteArgs>(args: SelectSubset<T, company_employeesDeleteArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_employees.
     * @param {company_employeesUpdateArgs} args - Arguments to update one Company_employees.
     * @example
     * // Update one Company_employees
     * const company_employees = await prisma.company_employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_employeesUpdateArgs>(args: SelectSubset<T, company_employeesUpdateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_employees.
     * @param {company_employeesDeleteManyArgs} args - Arguments to filter Company_employees to delete.
     * @example
     * // Delete a few Company_employees
     * const { count } = await prisma.company_employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_employeesDeleteManyArgs>(args?: SelectSubset<T, company_employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_employeesUpdateManyArgs>(args: SelectSubset<T, company_employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees and returns the data updated in the database.
     * @param {company_employeesUpdateManyAndReturnArgs} args - Arguments to update many Company_employees.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_employeesUpdateManyAndReturnArgs>(args: SelectSubset<T, company_employeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_employees.
     * @param {company_employeesUpsertArgs} args - Arguments to update or create a Company_employees.
     * @example
     * // Update or create a Company_employees
     * const company_employees = await prisma.company_employees.upsert({
     *   create: {
     *     // ... data to create a Company_employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_employees we want to update
     *   }
     * })
     */
    upsert<T extends company_employeesUpsertArgs>(args: SelectSubset<T, company_employeesUpsertArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesCountArgs} args - Arguments to filter Company_employees to count.
     * @example
     * // Count the number of Company_employees
     * const count = await prisma.company_employees.count({
     *   where: {
     *     // ... the filter for the Company_employees we want to count
     *   }
     * })
    **/
    count<T extends company_employeesCountArgs>(
      args?: Subset<T, company_employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_employeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_employeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_employeesAggregateArgs>(args: Subset<T, Company_employeesAggregateArgs>): Prisma.PrismaPromise<GetCompany_employeesAggregateType<T>>

    /**
     * Group by Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_employeesGroupByArgs['orderBy'] }
        : { orderBy?: company_employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_employeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_employees model
   */
  readonly fields: company_employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee_site_access<T extends company_employees$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, company_employees$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_employees model
   */
  interface company_employeesFieldRefs {
    readonly id: FieldRef<"company_employees", 'Int'>
    readonly admin_id: FieldRef<"company_employees", 'Int'>
    readonly company_id: FieldRef<"company_employees", 'Int'>
    readonly joined_at: FieldRef<"company_employees", 'DateTime'>
    readonly status: FieldRef<"company_employees", 'AccountStatus'>
    readonly deleted_at: FieldRef<"company_employees", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_employees findUnique
   */
  export type company_employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findUniqueOrThrow
   */
  export type company_employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findFirst
   */
  export type company_employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findFirstOrThrow
   */
  export type company_employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findMany
   */
  export type company_employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees create
   */
  export type company_employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_employees.
     */
    data: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
  }

  /**
   * company_employees createMany
   */
  export type company_employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_employees createManyAndReturn
   */
  export type company_employeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees update
   */
  export type company_employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_employees.
     */
    data: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
    /**
     * Choose, which company_employees to update.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees updateMany
   */
  export type company_employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
  }

  /**
   * company_employees updateManyAndReturn
   */
  export type company_employeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees upsert
   */
  export type company_employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_employees to update in case it exists.
     */
    where: company_employeesWhereUniqueInput
    /**
     * In case the company_employees found by the `where` argument doesn't exist, create a new company_employees with this data.
     */
    create: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
    /**
     * In case the company_employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
  }

  /**
   * company_employees delete
   */
  export type company_employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter which company_employees to delete.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees deleteMany
   */
  export type company_employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to delete
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to delete.
     */
    limit?: number
  }

  /**
   * company_employees.employee_site_access
   */
  export type company_employees$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * company_employees without action
   */
  export type company_employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
  }


  /**
   * Model complaints
   */

  export type AggregateComplaints = {
    _count: ComplaintsCountAggregateOutputType | null
    _avg: ComplaintsAvgAggregateOutputType | null
    _sum: ComplaintsSumAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  export type ComplaintsAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintsSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    status: number
    siteId: number
    userId: number
    created_at: number
    updated_at: number
    category: number
    _all: number
  }


  export type ComplaintsAvgAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintsSumAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
    _all?: true
  }

  export type ComplaintsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to aggregate.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints
    **/
    _count?: true | ComplaintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintsMaxAggregateInputType
  }

  export type GetComplaintsAggregateType<T extends ComplaintsAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaints[P]>
      : GetScalarType<T[P], AggregateComplaints[P]>
  }




  export type complaintsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithAggregationInput | complaintsOrderByWithAggregationInput[]
    by: ComplaintsScalarFieldEnum[] | ComplaintsScalarFieldEnum
    having?: complaintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintsCountAggregateInputType | true
    _avg?: ComplaintsAvgAggregateInputType
    _sum?: ComplaintsSumAggregateInputType
    _min?: ComplaintsMinAggregateInputType
    _max?: ComplaintsMaxAggregateInputType
  }

  export type ComplaintsGroupByOutputType = {
    id: number
    title: string
    content: string
    status: $Enums.Status
    siteId: number
    userId: number
    created_at: Date
    updated_at: Date
    category: $Enums.Category | null
    _count: ComplaintsCountAggregateOutputType | null
    _avg: ComplaintsAvgAggregateOutputType | null
    _sum: ComplaintsSumAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  type GetComplaintsGroupByPayload<T extends complaintsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
        }
      >
    >


  export type complaintsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
  }

  export type complaintsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "status" | "siteId" | "userId" | "created_at" | "updated_at" | "category", ExtArgs["result"]["complaints"]>
  export type complaintsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type complaintsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type complaintsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $complaintsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "complaints"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      status: $Enums.Status
      siteId: number
      userId: number
      created_at: Date
      updated_at: Date
      category: $Enums.Category | null
    }, ExtArgs["result"]["complaints"]>
    composites: {}
  }

  type complaintsGetPayload<S extends boolean | null | undefined | complaintsDefaultArgs> = $Result.GetResult<Prisma.$complaintsPayload, S>

  type complaintsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<complaintsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintsCountAggregateInputType | true
    }

  export interface complaintsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['complaints'], meta: { name: 'complaints' } }
    /**
     * Find zero or one Complaints that matches the filter.
     * @param {complaintsFindUniqueArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends complaintsFindUniqueArgs>(args: SelectSubset<T, complaintsFindUniqueArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaints that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {complaintsFindUniqueOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends complaintsFindUniqueOrThrowArgs>(args: SelectSubset<T, complaintsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends complaintsFindFirstArgs>(args?: SelectSubset<T, complaintsFindFirstArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends complaintsFindFirstOrThrowArgs>(args?: SelectSubset<T, complaintsFindFirstOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaints.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintsWithIdOnly = await prisma.complaints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends complaintsFindManyArgs>(args?: SelectSubset<T, complaintsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaints.
     * @param {complaintsCreateArgs} args - Arguments to create a Complaints.
     * @example
     * // Create one Complaints
     * const Complaints = await prisma.complaints.create({
     *   data: {
     *     // ... data to create a Complaints
     *   }
     * })
     * 
     */
    create<T extends complaintsCreateArgs>(args: SelectSubset<T, complaintsCreateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {complaintsCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends complaintsCreateManyArgs>(args?: SelectSubset<T, complaintsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {complaintsCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends complaintsCreateManyAndReturnArgs>(args?: SelectSubset<T, complaintsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Complaints.
     * @param {complaintsDeleteArgs} args - Arguments to delete one Complaints.
     * @example
     * // Delete one Complaints
     * const Complaints = await prisma.complaints.delete({
     *   where: {
     *     // ... filter to delete one Complaints
     *   }
     * })
     * 
     */
    delete<T extends complaintsDeleteArgs>(args: SelectSubset<T, complaintsDeleteArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaints.
     * @param {complaintsUpdateArgs} args - Arguments to update one Complaints.
     * @example
     * // Update one Complaints
     * const complaints = await prisma.complaints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends complaintsUpdateArgs>(args: SelectSubset<T, complaintsUpdateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {complaintsDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends complaintsDeleteManyArgs>(args?: SelectSubset<T, complaintsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends complaintsUpdateManyArgs>(args: SelectSubset<T, complaintsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints and returns the data updated in the database.
     * @param {complaintsUpdateManyAndReturnArgs} args - Arguments to update many Complaints.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends complaintsUpdateManyAndReturnArgs>(args: SelectSubset<T, complaintsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Complaints.
     * @param {complaintsUpsertArgs} args - Arguments to update or create a Complaints.
     * @example
     * // Update or create a Complaints
     * const complaints = await prisma.complaints.upsert({
     *   create: {
     *     // ... data to create a Complaints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaints we want to update
     *   }
     * })
     */
    upsert<T extends complaintsUpsertArgs>(args: SelectSubset<T, complaintsUpsertArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaints.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends complaintsCountArgs>(
      args?: Subset<T, complaintsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintsAggregateArgs>(args: Subset<T, ComplaintsAggregateArgs>): Prisma.PrismaPromise<GetComplaintsAggregateType<T>>

    /**
     * Group by Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends complaintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: complaintsGroupByArgs['orderBy'] }
        : { orderBy?: complaintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, complaintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the complaints model
   */
  readonly fields: complaintsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__complaintsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the complaints model
   */
  interface complaintsFieldRefs {
    readonly id: FieldRef<"complaints", 'Int'>
    readonly title: FieldRef<"complaints", 'String'>
    readonly content: FieldRef<"complaints", 'String'>
    readonly status: FieldRef<"complaints", 'Status'>
    readonly siteId: FieldRef<"complaints", 'Int'>
    readonly userId: FieldRef<"complaints", 'Int'>
    readonly created_at: FieldRef<"complaints", 'DateTime'>
    readonly updated_at: FieldRef<"complaints", 'DateTime'>
    readonly category: FieldRef<"complaints", 'Category'>
  }
    

  // Custom InputTypes
  /**
   * complaints findUnique
   */
  export type complaintsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findUniqueOrThrow
   */
  export type complaintsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findFirst
   */
  export type complaintsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findFirstOrThrow
   */
  export type complaintsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findMany
   */
  export type complaintsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints create
   */
  export type complaintsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to create a complaints.
     */
    data: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
  }

  /**
   * complaints createMany
   */
  export type complaintsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * complaints createManyAndReturn
   */
  export type complaintsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * complaints update
   */
  export type complaintsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to update a complaints.
     */
    data: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
    /**
     * Choose, which complaints to update.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints updateMany
   */
  export type complaintsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to update.
     */
    limit?: number
  }

  /**
   * complaints updateManyAndReturn
   */
  export type complaintsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * complaints upsert
   */
  export type complaintsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The filter to search for the complaints to update in case it exists.
     */
    where: complaintsWhereUniqueInput
    /**
     * In case the complaints found by the `where` argument doesn't exist, create a new complaints with this data.
     */
    create: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
    /**
     * In case the complaints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
  }

  /**
   * complaints delete
   */
  export type complaintsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter which complaints to delete.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints deleteMany
   */
  export type complaintsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to delete
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to delete.
     */
    limit?: number
  }

  /**
   * complaints without action
   */
  export type complaintsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
  }


  /**
   * Model employee_site_access
   */

  export type AggregateEmployee_site_access = {
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  export type Employee_site_accessAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
    deleted_at: Date | null
  }

  export type Employee_site_accessMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
    deleted_at: Date | null
  }

  export type Employee_site_accessCountAggregateOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: number
    deleted_at: number
    _all: number
  }


  export type Employee_site_accessAvgAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessSumAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessMinAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
    deleted_at?: true
  }

  export type Employee_site_accessMaxAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
    deleted_at?: true
  }

  export type Employee_site_accessCountAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Employee_site_accessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_access to aggregate.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employee_site_accesses
    **/
    _count?: true | Employee_site_accessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Employee_site_accessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Employee_site_accessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_site_accessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type GetEmployee_site_accessAggregateType<T extends Employee_site_accessAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_site_access]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_site_access[P]>
      : GetScalarType<T[P], AggregateEmployee_site_access[P]>
  }




  export type employee_site_accessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithAggregationInput | employee_site_accessOrderByWithAggregationInput[]
    by: Employee_site_accessScalarFieldEnum[] | Employee_site_accessScalarFieldEnum
    having?: employee_site_accessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_site_accessCountAggregateInputType | true
    _avg?: Employee_site_accessAvgAggregateInputType
    _sum?: Employee_site_accessSumAggregateInputType
    _min?: Employee_site_accessMinAggregateInputType
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type Employee_site_accessGroupByOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: Date
    deleted_at: Date | null
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  type GetEmployee_site_accessGroupByPayload<T extends employee_site_accessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_site_accessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_site_accessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
        }
      >
    >


  export type employee_site_accessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    deleted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    deleted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    deleted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectScalar = {
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    deleted_at?: boolean
  }

  export type employee_site_accessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "site_id" | "granted_at" | "deleted_at", ExtArgs["result"]["employee_site_access"]>
  export type employee_site_accessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $employee_site_accessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee_site_access"
    objects: {
      company_employees: Prisma.$company_employeesPayload<ExtArgs>
      sites: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number
      site_id: number
      granted_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["employee_site_access"]>
    composites: {}
  }

  type employee_site_accessGetPayload<S extends boolean | null | undefined | employee_site_accessDefaultArgs> = $Result.GetResult<Prisma.$employee_site_accessPayload, S>

  type employee_site_accessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employee_site_accessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Employee_site_accessCountAggregateInputType | true
    }

  export interface employee_site_accessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee_site_access'], meta: { name: 'employee_site_access' } }
    /**
     * Find zero or one Employee_site_access that matches the filter.
     * @param {employee_site_accessFindUniqueArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employee_site_accessFindUniqueArgs>(args: SelectSubset<T, employee_site_accessFindUniqueArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee_site_access that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employee_site_accessFindUniqueOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employee_site_accessFindUniqueOrThrowArgs>(args: SelectSubset<T, employee_site_accessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employee_site_accessFindFirstArgs>(args?: SelectSubset<T, employee_site_accessFindFirstArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employee_site_accessFindFirstOrThrowArgs>(args?: SelectSubset<T, employee_site_accessFindFirstOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employee_site_accesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany()
     * 
     * // Get first 10 Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employee_site_accessFindManyArgs>(args?: SelectSubset<T, employee_site_accessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee_site_access.
     * @param {employee_site_accessCreateArgs} args - Arguments to create a Employee_site_access.
     * @example
     * // Create one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.create({
     *   data: {
     *     // ... data to create a Employee_site_access
     *   }
     * })
     * 
     */
    create<T extends employee_site_accessCreateArgs>(args: SelectSubset<T, employee_site_accessCreateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employee_site_accesses.
     * @param {employee_site_accessCreateManyArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employee_site_accessCreateManyArgs>(args?: SelectSubset<T, employee_site_accessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employee_site_accesses and returns the data saved in the database.
     * @param {employee_site_accessCreateManyAndReturnArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employee_site_accessCreateManyAndReturnArgs>(args?: SelectSubset<T, employee_site_accessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee_site_access.
     * @param {employee_site_accessDeleteArgs} args - Arguments to delete one Employee_site_access.
     * @example
     * // Delete one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.delete({
     *   where: {
     *     // ... filter to delete one Employee_site_access
     *   }
     * })
     * 
     */
    delete<T extends employee_site_accessDeleteArgs>(args: SelectSubset<T, employee_site_accessDeleteArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee_site_access.
     * @param {employee_site_accessUpdateArgs} args - Arguments to update one Employee_site_access.
     * @example
     * // Update one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employee_site_accessUpdateArgs>(args: SelectSubset<T, employee_site_accessUpdateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employee_site_accesses.
     * @param {employee_site_accessDeleteManyArgs} args - Arguments to filter Employee_site_accesses to delete.
     * @example
     * // Delete a few Employee_site_accesses
     * const { count } = await prisma.employee_site_access.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employee_site_accessDeleteManyArgs>(args?: SelectSubset<T, employee_site_accessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employee_site_accessUpdateManyArgs>(args: SelectSubset<T, employee_site_accessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses and returns the data updated in the database.
     * @param {employee_site_accessUpdateManyAndReturnArgs} args - Arguments to update many Employee_site_accesses.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employee_site_accessUpdateManyAndReturnArgs>(args: SelectSubset<T, employee_site_accessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee_site_access.
     * @param {employee_site_accessUpsertArgs} args - Arguments to update or create a Employee_site_access.
     * @example
     * // Update or create a Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.upsert({
     *   create: {
     *     // ... data to create a Employee_site_access
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_site_access we want to update
     *   }
     * })
     */
    upsert<T extends employee_site_accessUpsertArgs>(args: SelectSubset<T, employee_site_accessUpsertArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessCountArgs} args - Arguments to filter Employee_site_accesses to count.
     * @example
     * // Count the number of Employee_site_accesses
     * const count = await prisma.employee_site_access.count({
     *   where: {
     *     // ... the filter for the Employee_site_accesses we want to count
     *   }
     * })
    **/
    count<T extends employee_site_accessCountArgs>(
      args?: Subset<T, employee_site_accessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_site_accessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_site_accessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_site_accessAggregateArgs>(args: Subset<T, Employee_site_accessAggregateArgs>): Prisma.PrismaPromise<GetEmployee_site_accessAggregateType<T>>

    /**
     * Group by Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employee_site_accessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employee_site_accessGroupByArgs['orderBy'] }
        : { orderBy?: employee_site_accessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employee_site_accessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_site_accessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee_site_access model
   */
  readonly fields: employee_site_accessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee_site_access.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employee_site_accessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_employees<T extends company_employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, company_employeesDefaultArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee_site_access model
   */
  interface employee_site_accessFieldRefs {
    readonly id: FieldRef<"employee_site_access", 'Int'>
    readonly employee_id: FieldRef<"employee_site_access", 'Int'>
    readonly site_id: FieldRef<"employee_site_access", 'Int'>
    readonly granted_at: FieldRef<"employee_site_access", 'DateTime'>
    readonly deleted_at: FieldRef<"employee_site_access", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employee_site_access findUnique
   */
  export type employee_site_accessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findUniqueOrThrow
   */
  export type employee_site_accessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findFirst
   */
  export type employee_site_accessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findFirstOrThrow
   */
  export type employee_site_accessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findMany
   */
  export type employee_site_accessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_accesses to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access create
   */
  export type employee_site_accessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to create a employee_site_access.
     */
    data: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
  }

  /**
   * employee_site_access createMany
   */
  export type employee_site_accessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee_site_access createManyAndReturn
   */
  export type employee_site_accessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access update
   */
  export type employee_site_accessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to update a employee_site_access.
     */
    data: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
    /**
     * Choose, which employee_site_access to update.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access updateMany
   */
  export type employee_site_accessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
  }

  /**
   * employee_site_access updateManyAndReturn
   */
  export type employee_site_accessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access upsert
   */
  export type employee_site_accessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The filter to search for the employee_site_access to update in case it exists.
     */
    where: employee_site_accessWhereUniqueInput
    /**
     * In case the employee_site_access found by the `where` argument doesn't exist, create a new employee_site_access with this data.
     */
    create: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
    /**
     * In case the employee_site_access was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
  }

  /**
   * employee_site_access delete
   */
  export type employee_site_accessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter which employee_site_access to delete.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access deleteMany
   */
  export type employee_site_accessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_accesses to delete
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to delete.
     */
    limit?: number
  }

  /**
   * employee_site_access without action
   */
  export type employee_site_accessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
  }


  /**
   * Model invitations
   */

  export type AggregateInvitations = {
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  export type InvitationsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsSumAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsMinAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsMaxAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsCountAggregateOutputType = {
    id: number
    company_id: number
    invite_code: number
    invite_link: number
    invited_email: number
    invited_by: number
    status: number
    expires_at: number
    used_at: number
    used_by: number
    created_at: number
    _all: number
  }


  export type InvitationsAvgAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsSumAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsMinAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsCountAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
    _all?: true
  }

  export type InvitationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to aggregate.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invitations
    **/
    _count?: true | InvitationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationsMaxAggregateInputType
  }

  export type GetInvitationsAggregateType<T extends InvitationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitations[P]>
      : GetScalarType<T[P], AggregateInvitations[P]>
  }




  export type invitationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithAggregationInput | invitationsOrderByWithAggregationInput[]
    by: InvitationsScalarFieldEnum[] | InvitationsScalarFieldEnum
    having?: invitationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationsCountAggregateInputType | true
    _avg?: InvitationsAvgAggregateInputType
    _sum?: InvitationsSumAggregateInputType
    _min?: InvitationsMinAggregateInputType
    _max?: InvitationsMaxAggregateInputType
  }

  export type InvitationsGroupByOutputType = {
    id: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email: string | null
    invited_by: number
    status: $Enums.InvitationStatus
    expires_at: Date
    used_at: Date | null
    used_by: number | null
    created_at: Date
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  type GetInvitationsGroupByPayload<T extends invitationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
        }
      >
    >


  export type invitationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
  }

  export type invitationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "invite_code" | "invite_link" | "invited_email" | "invited_by" | "status" | "expires_at" | "used_at" | "used_by" | "created_at", ExtArgs["result"]["invitations"]>
  export type invitationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $invitationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invitations"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: number
      invite_code: string
      invite_link: string
      invited_email: string | null
      invited_by: number
      status: $Enums.InvitationStatus
      expires_at: Date
      used_at: Date | null
      used_by: number | null
      created_at: Date
    }, ExtArgs["result"]["invitations"]>
    composites: {}
  }

  type invitationsGetPayload<S extends boolean | null | undefined | invitationsDefaultArgs> = $Result.GetResult<Prisma.$invitationsPayload, S>

  type invitationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invitationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationsCountAggregateInputType | true
    }

  export interface invitationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invitations'], meta: { name: 'invitations' } }
    /**
     * Find zero or one Invitations that matches the filter.
     * @param {invitationsFindUniqueArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invitationsFindUniqueArgs>(args: SelectSubset<T, invitationsFindUniqueArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invitationsFindUniqueOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invitationsFindUniqueOrThrowArgs>(args: SelectSubset<T, invitationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invitationsFindFirstArgs>(args?: SelectSubset<T, invitationsFindFirstArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invitationsFindFirstOrThrowArgs>(args?: SelectSubset<T, invitationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitations.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationsWithIdOnly = await prisma.invitations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invitationsFindManyArgs>(args?: SelectSubset<T, invitationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitations.
     * @param {invitationsCreateArgs} args - Arguments to create a Invitations.
     * @example
     * // Create one Invitations
     * const Invitations = await prisma.invitations.create({
     *   data: {
     *     // ... data to create a Invitations
     *   }
     * })
     * 
     */
    create<T extends invitationsCreateArgs>(args: SelectSubset<T, invitationsCreateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {invitationsCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invitationsCreateManyArgs>(args?: SelectSubset<T, invitationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {invitationsCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invitationsCreateManyAndReturnArgs>(args?: SelectSubset<T, invitationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitations.
     * @param {invitationsDeleteArgs} args - Arguments to delete one Invitations.
     * @example
     * // Delete one Invitations
     * const Invitations = await prisma.invitations.delete({
     *   where: {
     *     // ... filter to delete one Invitations
     *   }
     * })
     * 
     */
    delete<T extends invitationsDeleteArgs>(args: SelectSubset<T, invitationsDeleteArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitations.
     * @param {invitationsUpdateArgs} args - Arguments to update one Invitations.
     * @example
     * // Update one Invitations
     * const invitations = await prisma.invitations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invitationsUpdateArgs>(args: SelectSubset<T, invitationsUpdateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {invitationsDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invitationsDeleteManyArgs>(args?: SelectSubset<T, invitationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invitationsUpdateManyArgs>(args: SelectSubset<T, invitationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {invitationsUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invitationsUpdateManyAndReturnArgs>(args: SelectSubset<T, invitationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitations.
     * @param {invitationsUpsertArgs} args - Arguments to update or create a Invitations.
     * @example
     * // Update or create a Invitations
     * const invitations = await prisma.invitations.upsert({
     *   create: {
     *     // ... data to create a Invitations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitations we want to update
     *   }
     * })
     */
    upsert<T extends invitationsUpsertArgs>(args: SelectSubset<T, invitationsUpsertArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitations.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends invitationsCountArgs>(
      args?: Subset<T, invitationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationsAggregateArgs>(args: Subset<T, InvitationsAggregateArgs>): Prisma.PrismaPromise<GetInvitationsAggregateType<T>>

    /**
     * Group by Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invitationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invitationsGroupByArgs['orderBy'] }
        : { orderBy?: invitationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invitationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invitations model
   */
  readonly fields: invitationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invitations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invitationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invitations model
   */
  interface invitationsFieldRefs {
    readonly id: FieldRef<"invitations", 'Int'>
    readonly company_id: FieldRef<"invitations", 'Int'>
    readonly invite_code: FieldRef<"invitations", 'String'>
    readonly invite_link: FieldRef<"invitations", 'String'>
    readonly invited_email: FieldRef<"invitations", 'String'>
    readonly invited_by: FieldRef<"invitations", 'Int'>
    readonly status: FieldRef<"invitations", 'InvitationStatus'>
    readonly expires_at: FieldRef<"invitations", 'DateTime'>
    readonly used_at: FieldRef<"invitations", 'DateTime'>
    readonly used_by: FieldRef<"invitations", 'Int'>
    readonly created_at: FieldRef<"invitations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invitations findUnique
   */
  export type invitationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findUniqueOrThrow
   */
  export type invitationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findFirst
   */
  export type invitationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findFirstOrThrow
   */
  export type invitationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findMany
   */
  export type invitationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations create
   */
  export type invitationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to create a invitations.
     */
    data: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
  }

  /**
   * invitations createMany
   */
  export type invitationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invitations createManyAndReturn
   */
  export type invitationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations update
   */
  export type invitationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to update a invitations.
     */
    data: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
    /**
     * Choose, which invitations to update.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations updateMany
   */
  export type invitationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
  }

  /**
   * invitations updateManyAndReturn
   */
  export type invitationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations upsert
   */
  export type invitationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The filter to search for the invitations to update in case it exists.
     */
    where: invitationsWhereUniqueInput
    /**
     * In case the invitations found by the `where` argument doesn't exist, create a new invitations with this data.
     */
    create: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
    /**
     * In case the invitations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
  }

  /**
   * invitations delete
   */
  export type invitationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter which invitations to delete.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations deleteMany
   */
  export type invitationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to delete
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to delete.
     */
    limit?: number
  }

  /**
   * invitations without action
   */
  export type invitationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    amount: number
    payment_date: number
    payment_method: number
    description: number
    created_at: number
    userId: number
    siteId: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    amount: number
    payment_date: Date
    payment_method: $Enums.PaymentMethod
    description: string | null
    created_at: Date
    userId: number
    siteId: number
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "payment_date" | "payment_method" | "description" | "created_at" | "userId" | "siteId", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      payment_date: Date
      payment_method: $Enums.PaymentMethod
      description: string | null
      created_at: Date
      userId: number
      siteId: number
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Float'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'PaymentMethod'>
    readonly description: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly userId: FieldRef<"payments", 'Int'>
    readonly siteId: FieldRef<"payments", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model MasterUser
   */

  export type AggregateMasterUser = {
    _count: MasterUserCountAggregateOutputType | null
    _avg: MasterUserAvgAggregateOutputType | null
    _sum: MasterUserSumAggregateOutputType | null
    _min: MasterUserMinAggregateOutputType | null
    _max: MasterUserMaxAggregateOutputType | null
  }

  export type MasterUserAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterUserSumAggregateOutputType = {
    id: number | null
  }

  export type MasterUserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    master_role: $Enums.MasterRole | null
    is_active: boolean | null
    is_verified: boolean | null
    verificationToken: string | null
    tokenExpiry: Date | null
    last_login_at: Date | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MasterUserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    master_role: $Enums.MasterRole | null
    is_active: boolean | null
    is_verified: boolean | null
    verificationToken: string | null
    tokenExpiry: Date | null
    last_login_at: Date | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MasterUserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    full_name: number
    master_role: number
    is_active: number
    is_verified: number
    verificationToken: number
    tokenExpiry: number
    last_login_at: number
    deleted_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MasterUserAvgAggregateInputType = {
    id?: true
  }

  export type MasterUserSumAggregateInputType = {
    id?: true
  }

  export type MasterUserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    master_role?: true
    is_active?: true
    is_verified?: true
    verificationToken?: true
    tokenExpiry?: true
    last_login_at?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MasterUserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    master_role?: true
    is_active?: true
    is_verified?: true
    verificationToken?: true
    tokenExpiry?: true
    last_login_at?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MasterUserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    master_role?: true
    is_active?: true
    is_verified?: true
    verificationToken?: true
    tokenExpiry?: true
    last_login_at?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MasterUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterUser to aggregate.
     */
    where?: MasterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUsers to fetch.
     */
    orderBy?: MasterUserOrderByWithRelationInput | MasterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterUsers
    **/
    _count?: true | MasterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterUserMaxAggregateInputType
  }

  export type GetMasterUserAggregateType<T extends MasterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterUser[P]>
      : GetScalarType<T[P], AggregateMasterUser[P]>
  }




  export type MasterUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterUserWhereInput
    orderBy?: MasterUserOrderByWithAggregationInput | MasterUserOrderByWithAggregationInput[]
    by: MasterUserScalarFieldEnum[] | MasterUserScalarFieldEnum
    having?: MasterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterUserCountAggregateInputType | true
    _avg?: MasterUserAvgAggregateInputType
    _sum?: MasterUserSumAggregateInputType
    _min?: MasterUserMinAggregateInputType
    _max?: MasterUserMaxAggregateInputType
  }

  export type MasterUserGroupByOutputType = {
    id: number
    email: string
    password_hash: string
    full_name: string
    master_role: $Enums.MasterRole
    is_active: boolean
    is_verified: boolean
    verificationToken: string | null
    tokenExpiry: Date | null
    last_login_at: Date | null
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    _count: MasterUserCountAggregateOutputType | null
    _avg: MasterUserAvgAggregateOutputType | null
    _sum: MasterUserSumAggregateOutputType | null
    _min: MasterUserMinAggregateOutputType | null
    _max: MasterUserMaxAggregateOutputType | null
  }

  type GetMasterUserGroupByPayload<T extends MasterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterUserGroupByOutputType[P]>
            : GetScalarType<T[P], MasterUserGroupByOutputType[P]>
        }
      >
    >


  export type MasterUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    master_role?: boolean
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: boolean
    tokenExpiry?: boolean
    last_login_at?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["masterUser"]>

  export type MasterUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    master_role?: boolean
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: boolean
    tokenExpiry?: boolean
    last_login_at?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["masterUser"]>

  export type MasterUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    master_role?: boolean
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: boolean
    tokenExpiry?: boolean
    last_login_at?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["masterUser"]>

  export type MasterUserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    master_role?: boolean
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: boolean
    tokenExpiry?: boolean
    last_login_at?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MasterUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "full_name" | "master_role" | "is_active" | "is_verified" | "verificationToken" | "tokenExpiry" | "last_login_at" | "deleted_at" | "created_at" | "updated_at", ExtArgs["result"]["masterUser"]>

  export type $MasterUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password_hash: string
      full_name: string
      master_role: $Enums.MasterRole
      is_active: boolean
      is_verified: boolean
      verificationToken: string | null
      tokenExpiry: Date | null
      last_login_at: Date | null
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["masterUser"]>
    composites: {}
  }

  type MasterUserGetPayload<S extends boolean | null | undefined | MasterUserDefaultArgs> = $Result.GetResult<Prisma.$MasterUserPayload, S>

  type MasterUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterUserCountAggregateInputType | true
    }

  export interface MasterUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterUser'], meta: { name: 'MasterUser' } }
    /**
     * Find zero or one MasterUser that matches the filter.
     * @param {MasterUserFindUniqueArgs} args - Arguments to find a MasterUser
     * @example
     * // Get one MasterUser
     * const masterUser = await prisma.masterUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterUserFindUniqueArgs>(args: SelectSubset<T, MasterUserFindUniqueArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterUserFindUniqueOrThrowArgs} args - Arguments to find a MasterUser
     * @example
     * // Get one MasterUser
     * const masterUser = await prisma.masterUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterUserFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserFindFirstArgs} args - Arguments to find a MasterUser
     * @example
     * // Get one MasterUser
     * const masterUser = await prisma.masterUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterUserFindFirstArgs>(args?: SelectSubset<T, MasterUserFindFirstArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserFindFirstOrThrowArgs} args - Arguments to find a MasterUser
     * @example
     * // Get one MasterUser
     * const masterUser = await prisma.masterUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterUserFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterUsers
     * const masterUsers = await prisma.masterUser.findMany()
     * 
     * // Get first 10 MasterUsers
     * const masterUsers = await prisma.masterUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterUserWithIdOnly = await prisma.masterUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterUserFindManyArgs>(args?: SelectSubset<T, MasterUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterUser.
     * @param {MasterUserCreateArgs} args - Arguments to create a MasterUser.
     * @example
     * // Create one MasterUser
     * const MasterUser = await prisma.masterUser.create({
     *   data: {
     *     // ... data to create a MasterUser
     *   }
     * })
     * 
     */
    create<T extends MasterUserCreateArgs>(args: SelectSubset<T, MasterUserCreateArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterUsers.
     * @param {MasterUserCreateManyArgs} args - Arguments to create many MasterUsers.
     * @example
     * // Create many MasterUsers
     * const masterUser = await prisma.masterUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterUserCreateManyArgs>(args?: SelectSubset<T, MasterUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MasterUsers and returns the data saved in the database.
     * @param {MasterUserCreateManyAndReturnArgs} args - Arguments to create many MasterUsers.
     * @example
     * // Create many MasterUsers
     * const masterUser = await prisma.masterUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MasterUsers and only return the `id`
     * const masterUserWithIdOnly = await prisma.masterUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MasterUserCreateManyAndReturnArgs>(args?: SelectSubset<T, MasterUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MasterUser.
     * @param {MasterUserDeleteArgs} args - Arguments to delete one MasterUser.
     * @example
     * // Delete one MasterUser
     * const MasterUser = await prisma.masterUser.delete({
     *   where: {
     *     // ... filter to delete one MasterUser
     *   }
     * })
     * 
     */
    delete<T extends MasterUserDeleteArgs>(args: SelectSubset<T, MasterUserDeleteArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterUser.
     * @param {MasterUserUpdateArgs} args - Arguments to update one MasterUser.
     * @example
     * // Update one MasterUser
     * const masterUser = await prisma.masterUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterUserUpdateArgs>(args: SelectSubset<T, MasterUserUpdateArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterUsers.
     * @param {MasterUserDeleteManyArgs} args - Arguments to filter MasterUsers to delete.
     * @example
     * // Delete a few MasterUsers
     * const { count } = await prisma.masterUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterUserDeleteManyArgs>(args?: SelectSubset<T, MasterUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterUsers
     * const masterUser = await prisma.masterUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterUserUpdateManyArgs>(args: SelectSubset<T, MasterUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterUsers and returns the data updated in the database.
     * @param {MasterUserUpdateManyAndReturnArgs} args - Arguments to update many MasterUsers.
     * @example
     * // Update many MasterUsers
     * const masterUser = await prisma.masterUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MasterUsers and only return the `id`
     * const masterUserWithIdOnly = await prisma.masterUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MasterUserUpdateManyAndReturnArgs>(args: SelectSubset<T, MasterUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MasterUser.
     * @param {MasterUserUpsertArgs} args - Arguments to update or create a MasterUser.
     * @example
     * // Update or create a MasterUser
     * const masterUser = await prisma.masterUser.upsert({
     *   create: {
     *     // ... data to create a MasterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterUser we want to update
     *   }
     * })
     */
    upsert<T extends MasterUserUpsertArgs>(args: SelectSubset<T, MasterUserUpsertArgs<ExtArgs>>): Prisma__MasterUserClient<$Result.GetResult<Prisma.$MasterUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserCountArgs} args - Arguments to filter MasterUsers to count.
     * @example
     * // Count the number of MasterUsers
     * const count = await prisma.masterUser.count({
     *   where: {
     *     // ... the filter for the MasterUsers we want to count
     *   }
     * })
    **/
    count<T extends MasterUserCountArgs>(
      args?: Subset<T, MasterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterUserAggregateArgs>(args: Subset<T, MasterUserAggregateArgs>): Prisma.PrismaPromise<GetMasterUserAggregateType<T>>

    /**
     * Group by MasterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterUserGroupByArgs['orderBy'] }
        : { orderBy?: MasterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterUser model
   */
  readonly fields: MasterUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterUser model
   */
  interface MasterUserFieldRefs {
    readonly id: FieldRef<"MasterUser", 'Int'>
    readonly email: FieldRef<"MasterUser", 'String'>
    readonly password_hash: FieldRef<"MasterUser", 'String'>
    readonly full_name: FieldRef<"MasterUser", 'String'>
    readonly master_role: FieldRef<"MasterUser", 'MasterRole'>
    readonly is_active: FieldRef<"MasterUser", 'Boolean'>
    readonly is_verified: FieldRef<"MasterUser", 'Boolean'>
    readonly verificationToken: FieldRef<"MasterUser", 'String'>
    readonly tokenExpiry: FieldRef<"MasterUser", 'DateTime'>
    readonly last_login_at: FieldRef<"MasterUser", 'DateTime'>
    readonly deleted_at: FieldRef<"MasterUser", 'DateTime'>
    readonly created_at: FieldRef<"MasterUser", 'DateTime'>
    readonly updated_at: FieldRef<"MasterUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterUser findUnique
   */
  export type MasterUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter, which MasterUser to fetch.
     */
    where: MasterUserWhereUniqueInput
  }

  /**
   * MasterUser findUniqueOrThrow
   */
  export type MasterUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter, which MasterUser to fetch.
     */
    where: MasterUserWhereUniqueInput
  }

  /**
   * MasterUser findFirst
   */
  export type MasterUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter, which MasterUser to fetch.
     */
    where?: MasterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUsers to fetch.
     */
    orderBy?: MasterUserOrderByWithRelationInput | MasterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterUsers.
     */
    cursor?: MasterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterUsers.
     */
    distinct?: MasterUserScalarFieldEnum | MasterUserScalarFieldEnum[]
  }

  /**
   * MasterUser findFirstOrThrow
   */
  export type MasterUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter, which MasterUser to fetch.
     */
    where?: MasterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUsers to fetch.
     */
    orderBy?: MasterUserOrderByWithRelationInput | MasterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterUsers.
     */
    cursor?: MasterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterUsers.
     */
    distinct?: MasterUserScalarFieldEnum | MasterUserScalarFieldEnum[]
  }

  /**
   * MasterUser findMany
   */
  export type MasterUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter, which MasterUsers to fetch.
     */
    where?: MasterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterUsers to fetch.
     */
    orderBy?: MasterUserOrderByWithRelationInput | MasterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterUsers.
     */
    cursor?: MasterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterUsers.
     */
    skip?: number
    distinct?: MasterUserScalarFieldEnum | MasterUserScalarFieldEnum[]
  }

  /**
   * MasterUser create
   */
  export type MasterUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * The data needed to create a MasterUser.
     */
    data: XOR<MasterUserCreateInput, MasterUserUncheckedCreateInput>
  }

  /**
   * MasterUser createMany
   */
  export type MasterUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterUsers.
     */
    data: MasterUserCreateManyInput | MasterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterUser createManyAndReturn
   */
  export type MasterUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * The data used to create many MasterUsers.
     */
    data: MasterUserCreateManyInput | MasterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterUser update
   */
  export type MasterUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * The data needed to update a MasterUser.
     */
    data: XOR<MasterUserUpdateInput, MasterUserUncheckedUpdateInput>
    /**
     * Choose, which MasterUser to update.
     */
    where: MasterUserWhereUniqueInput
  }

  /**
   * MasterUser updateMany
   */
  export type MasterUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterUsers.
     */
    data: XOR<MasterUserUpdateManyMutationInput, MasterUserUncheckedUpdateManyInput>
    /**
     * Filter which MasterUsers to update
     */
    where?: MasterUserWhereInput
    /**
     * Limit how many MasterUsers to update.
     */
    limit?: number
  }

  /**
   * MasterUser updateManyAndReturn
   */
  export type MasterUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * The data used to update MasterUsers.
     */
    data: XOR<MasterUserUpdateManyMutationInput, MasterUserUncheckedUpdateManyInput>
    /**
     * Filter which MasterUsers to update
     */
    where?: MasterUserWhereInput
    /**
     * Limit how many MasterUsers to update.
     */
    limit?: number
  }

  /**
   * MasterUser upsert
   */
  export type MasterUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * The filter to search for the MasterUser to update in case it exists.
     */
    where: MasterUserWhereUniqueInput
    /**
     * In case the MasterUser found by the `where` argument doesn't exist, create a new MasterUser with this data.
     */
    create: XOR<MasterUserCreateInput, MasterUserUncheckedCreateInput>
    /**
     * In case the MasterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterUserUpdateInput, MasterUserUncheckedUpdateInput>
  }

  /**
   * MasterUser delete
   */
  export type MasterUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
    /**
     * Filter which MasterUser to delete.
     */
    where: MasterUserWhereUniqueInput
  }

  /**
   * MasterUser deleteMany
   */
  export type MasterUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterUsers to delete
     */
    where?: MasterUserWhereInput
    /**
     * Limit how many MasterUsers to delete.
     */
    limit?: number
  }

  /**
   * MasterUser without action
   */
  export type MasterUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterUser
     */
    select?: MasterUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterUser
     */
    omit?: MasterUserOmit<ExtArgs> | null
  }


  /**
   * Model AdminComplaint
   */

  export type AggregateAdminComplaint = {
    _count: AdminComplaintCountAggregateOutputType | null
    _avg: AdminComplaintAvgAggregateOutputType | null
    _sum: AdminComplaintSumAggregateOutputType | null
    _min: AdminComplaintMinAggregateOutputType | null
    _max: AdminComplaintMaxAggregateOutputType | null
  }

  export type AdminComplaintAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
  }

  export type AdminComplaintSumAggregateOutputType = {
    id: number | null
    adminId: number | null
  }

  export type AdminComplaintMinAggregateOutputType = {
    id: number | null
    adminId: number | null
    accountType: $Enums.AccountType | null
    title: string | null
    content: string | null
    category: $Enums.AdminComplaintCategory | null
    status: $Enums.Status | null
    created_at: Date | null
    updated_at: Date | null
    master_note: string | null
  }

  export type AdminComplaintMaxAggregateOutputType = {
    id: number | null
    adminId: number | null
    accountType: $Enums.AccountType | null
    title: string | null
    content: string | null
    category: $Enums.AdminComplaintCategory | null
    status: $Enums.Status | null
    created_at: Date | null
    updated_at: Date | null
    master_note: string | null
  }

  export type AdminComplaintCountAggregateOutputType = {
    id: number
    adminId: number
    accountType: number
    title: number
    content: number
    category: number
    status: number
    created_at: number
    updated_at: number
    master_note: number
    _all: number
  }


  export type AdminComplaintAvgAggregateInputType = {
    id?: true
    adminId?: true
  }

  export type AdminComplaintSumAggregateInputType = {
    id?: true
    adminId?: true
  }

  export type AdminComplaintMinAggregateInputType = {
    id?: true
    adminId?: true
    accountType?: true
    title?: true
    content?: true
    category?: true
    status?: true
    created_at?: true
    updated_at?: true
    master_note?: true
  }

  export type AdminComplaintMaxAggregateInputType = {
    id?: true
    adminId?: true
    accountType?: true
    title?: true
    content?: true
    category?: true
    status?: true
    created_at?: true
    updated_at?: true
    master_note?: true
  }

  export type AdminComplaintCountAggregateInputType = {
    id?: true
    adminId?: true
    accountType?: true
    title?: true
    content?: true
    category?: true
    status?: true
    created_at?: true
    updated_at?: true
    master_note?: true
    _all?: true
  }

  export type AdminComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminComplaint to aggregate.
     */
    where?: AdminComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminComplaints to fetch.
     */
    orderBy?: AdminComplaintOrderByWithRelationInput | AdminComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminComplaints
    **/
    _count?: true | AdminComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminComplaintMaxAggregateInputType
  }

  export type GetAdminComplaintAggregateType<T extends AdminComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminComplaint[P]>
      : GetScalarType<T[P], AggregateAdminComplaint[P]>
  }




  export type AdminComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminComplaintWhereInput
    orderBy?: AdminComplaintOrderByWithAggregationInput | AdminComplaintOrderByWithAggregationInput[]
    by: AdminComplaintScalarFieldEnum[] | AdminComplaintScalarFieldEnum
    having?: AdminComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminComplaintCountAggregateInputType | true
    _avg?: AdminComplaintAvgAggregateInputType
    _sum?: AdminComplaintSumAggregateInputType
    _min?: AdminComplaintMinAggregateInputType
    _max?: AdminComplaintMaxAggregateInputType
  }

  export type AdminComplaintGroupByOutputType = {
    id: number
    adminId: number
    accountType: $Enums.AccountType
    title: string
    content: string
    category: $Enums.AdminComplaintCategory | null
    status: $Enums.Status
    created_at: Date
    updated_at: Date
    master_note: string | null
    _count: AdminComplaintCountAggregateOutputType | null
    _avg: AdminComplaintAvgAggregateOutputType | null
    _sum: AdminComplaintSumAggregateOutputType | null
    _min: AdminComplaintMinAggregateOutputType | null
    _max: AdminComplaintMaxAggregateOutputType | null
  }

  type GetAdminComplaintGroupByPayload<T extends AdminComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], AdminComplaintGroupByOutputType[P]>
        }
      >
    >


  export type AdminComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    accountType?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    master_note?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminComplaint"]>

  export type AdminComplaintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    accountType?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    master_note?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminComplaint"]>

  export type AdminComplaintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    accountType?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    master_note?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminComplaint"]>

  export type AdminComplaintSelectScalar = {
    id?: boolean
    adminId?: boolean
    accountType?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    master_note?: boolean
  }

  export type AdminComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "accountType" | "title" | "content" | "category" | "status" | "created_at" | "updated_at" | "master_note", ExtArgs["result"]["adminComplaint"]>
  export type AdminComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminComplaintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminComplaintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminComplaint"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminId: number
      accountType: $Enums.AccountType
      title: string
      content: string
      category: $Enums.AdminComplaintCategory | null
      status: $Enums.Status
      created_at: Date
      updated_at: Date
      master_note: string | null
    }, ExtArgs["result"]["adminComplaint"]>
    composites: {}
  }

  type AdminComplaintGetPayload<S extends boolean | null | undefined | AdminComplaintDefaultArgs> = $Result.GetResult<Prisma.$AdminComplaintPayload, S>

  type AdminComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminComplaintCountAggregateInputType | true
    }

  export interface AdminComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminComplaint'], meta: { name: 'AdminComplaint' } }
    /**
     * Find zero or one AdminComplaint that matches the filter.
     * @param {AdminComplaintFindUniqueArgs} args - Arguments to find a AdminComplaint
     * @example
     * // Get one AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminComplaintFindUniqueArgs>(args: SelectSubset<T, AdminComplaintFindUniqueArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminComplaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminComplaintFindUniqueOrThrowArgs} args - Arguments to find a AdminComplaint
     * @example
     * // Get one AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminComplaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintFindFirstArgs} args - Arguments to find a AdminComplaint
     * @example
     * // Get one AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminComplaintFindFirstArgs>(args?: SelectSubset<T, AdminComplaintFindFirstArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminComplaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintFindFirstOrThrowArgs} args - Arguments to find a AdminComplaint
     * @example
     * // Get one AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminComplaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminComplaints
     * const adminComplaints = await prisma.adminComplaint.findMany()
     * 
     * // Get first 10 AdminComplaints
     * const adminComplaints = await prisma.adminComplaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminComplaintWithIdOnly = await prisma.adminComplaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminComplaintFindManyArgs>(args?: SelectSubset<T, AdminComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminComplaint.
     * @param {AdminComplaintCreateArgs} args - Arguments to create a AdminComplaint.
     * @example
     * // Create one AdminComplaint
     * const AdminComplaint = await prisma.adminComplaint.create({
     *   data: {
     *     // ... data to create a AdminComplaint
     *   }
     * })
     * 
     */
    create<T extends AdminComplaintCreateArgs>(args: SelectSubset<T, AdminComplaintCreateArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminComplaints.
     * @param {AdminComplaintCreateManyArgs} args - Arguments to create many AdminComplaints.
     * @example
     * // Create many AdminComplaints
     * const adminComplaint = await prisma.adminComplaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminComplaintCreateManyArgs>(args?: SelectSubset<T, AdminComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminComplaints and returns the data saved in the database.
     * @param {AdminComplaintCreateManyAndReturnArgs} args - Arguments to create many AdminComplaints.
     * @example
     * // Create many AdminComplaints
     * const adminComplaint = await prisma.adminComplaint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminComplaints and only return the `id`
     * const adminComplaintWithIdOnly = await prisma.adminComplaint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminComplaintCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminComplaintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminComplaint.
     * @param {AdminComplaintDeleteArgs} args - Arguments to delete one AdminComplaint.
     * @example
     * // Delete one AdminComplaint
     * const AdminComplaint = await prisma.adminComplaint.delete({
     *   where: {
     *     // ... filter to delete one AdminComplaint
     *   }
     * })
     * 
     */
    delete<T extends AdminComplaintDeleteArgs>(args: SelectSubset<T, AdminComplaintDeleteArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminComplaint.
     * @param {AdminComplaintUpdateArgs} args - Arguments to update one AdminComplaint.
     * @example
     * // Update one AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminComplaintUpdateArgs>(args: SelectSubset<T, AdminComplaintUpdateArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminComplaints.
     * @param {AdminComplaintDeleteManyArgs} args - Arguments to filter AdminComplaints to delete.
     * @example
     * // Delete a few AdminComplaints
     * const { count } = await prisma.adminComplaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminComplaintDeleteManyArgs>(args?: SelectSubset<T, AdminComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminComplaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminComplaints
     * const adminComplaint = await prisma.adminComplaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminComplaintUpdateManyArgs>(args: SelectSubset<T, AdminComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminComplaints and returns the data updated in the database.
     * @param {AdminComplaintUpdateManyAndReturnArgs} args - Arguments to update many AdminComplaints.
     * @example
     * // Update many AdminComplaints
     * const adminComplaint = await prisma.adminComplaint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminComplaints and only return the `id`
     * const adminComplaintWithIdOnly = await prisma.adminComplaint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminComplaintUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminComplaintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminComplaint.
     * @param {AdminComplaintUpsertArgs} args - Arguments to update or create a AdminComplaint.
     * @example
     * // Update or create a AdminComplaint
     * const adminComplaint = await prisma.adminComplaint.upsert({
     *   create: {
     *     // ... data to create a AdminComplaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminComplaint we want to update
     *   }
     * })
     */
    upsert<T extends AdminComplaintUpsertArgs>(args: SelectSubset<T, AdminComplaintUpsertArgs<ExtArgs>>): Prisma__AdminComplaintClient<$Result.GetResult<Prisma.$AdminComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminComplaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintCountArgs} args - Arguments to filter AdminComplaints to count.
     * @example
     * // Count the number of AdminComplaints
     * const count = await prisma.adminComplaint.count({
     *   where: {
     *     // ... the filter for the AdminComplaints we want to count
     *   }
     * })
    **/
    count<T extends AdminComplaintCountArgs>(
      args?: Subset<T, AdminComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminComplaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminComplaintAggregateArgs>(args: Subset<T, AdminComplaintAggregateArgs>): Prisma.PrismaPromise<GetAdminComplaintAggregateType<T>>

    /**
     * Group by AdminComplaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminComplaintGroupByArgs['orderBy'] }
        : { orderBy?: AdminComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminComplaint model
   */
  readonly fields: AdminComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminComplaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminComplaint model
   */
  interface AdminComplaintFieldRefs {
    readonly id: FieldRef<"AdminComplaint", 'Int'>
    readonly adminId: FieldRef<"AdminComplaint", 'Int'>
    readonly accountType: FieldRef<"AdminComplaint", 'AccountType'>
    readonly title: FieldRef<"AdminComplaint", 'String'>
    readonly content: FieldRef<"AdminComplaint", 'String'>
    readonly category: FieldRef<"AdminComplaint", 'AdminComplaintCategory'>
    readonly status: FieldRef<"AdminComplaint", 'Status'>
    readonly created_at: FieldRef<"AdminComplaint", 'DateTime'>
    readonly updated_at: FieldRef<"AdminComplaint", 'DateTime'>
    readonly master_note: FieldRef<"AdminComplaint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminComplaint findUnique
   */
  export type AdminComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AdminComplaint to fetch.
     */
    where: AdminComplaintWhereUniqueInput
  }

  /**
   * AdminComplaint findUniqueOrThrow
   */
  export type AdminComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AdminComplaint to fetch.
     */
    where: AdminComplaintWhereUniqueInput
  }

  /**
   * AdminComplaint findFirst
   */
  export type AdminComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AdminComplaint to fetch.
     */
    where?: AdminComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminComplaints to fetch.
     */
    orderBy?: AdminComplaintOrderByWithRelationInput | AdminComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminComplaints.
     */
    cursor?: AdminComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminComplaints.
     */
    distinct?: AdminComplaintScalarFieldEnum | AdminComplaintScalarFieldEnum[]
  }

  /**
   * AdminComplaint findFirstOrThrow
   */
  export type AdminComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AdminComplaint to fetch.
     */
    where?: AdminComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminComplaints to fetch.
     */
    orderBy?: AdminComplaintOrderByWithRelationInput | AdminComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminComplaints.
     */
    cursor?: AdminComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminComplaints.
     */
    distinct?: AdminComplaintScalarFieldEnum | AdminComplaintScalarFieldEnum[]
  }

  /**
   * AdminComplaint findMany
   */
  export type AdminComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AdminComplaints to fetch.
     */
    where?: AdminComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminComplaints to fetch.
     */
    orderBy?: AdminComplaintOrderByWithRelationInput | AdminComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminComplaints.
     */
    cursor?: AdminComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminComplaints.
     */
    skip?: number
    distinct?: AdminComplaintScalarFieldEnum | AdminComplaintScalarFieldEnum[]
  }

  /**
   * AdminComplaint create
   */
  export type AdminComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminComplaint.
     */
    data: XOR<AdminComplaintCreateInput, AdminComplaintUncheckedCreateInput>
  }

  /**
   * AdminComplaint createMany
   */
  export type AdminComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminComplaints.
     */
    data: AdminComplaintCreateManyInput | AdminComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminComplaint createManyAndReturn
   */
  export type AdminComplaintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * The data used to create many AdminComplaints.
     */
    data: AdminComplaintCreateManyInput | AdminComplaintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminComplaint update
   */
  export type AdminComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminComplaint.
     */
    data: XOR<AdminComplaintUpdateInput, AdminComplaintUncheckedUpdateInput>
    /**
     * Choose, which AdminComplaint to update.
     */
    where: AdminComplaintWhereUniqueInput
  }

  /**
   * AdminComplaint updateMany
   */
  export type AdminComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminComplaints.
     */
    data: XOR<AdminComplaintUpdateManyMutationInput, AdminComplaintUncheckedUpdateManyInput>
    /**
     * Filter which AdminComplaints to update
     */
    where?: AdminComplaintWhereInput
    /**
     * Limit how many AdminComplaints to update.
     */
    limit?: number
  }

  /**
   * AdminComplaint updateManyAndReturn
   */
  export type AdminComplaintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * The data used to update AdminComplaints.
     */
    data: XOR<AdminComplaintUpdateManyMutationInput, AdminComplaintUncheckedUpdateManyInput>
    /**
     * Filter which AdminComplaints to update
     */
    where?: AdminComplaintWhereInput
    /**
     * Limit how many AdminComplaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminComplaint upsert
   */
  export type AdminComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminComplaint to update in case it exists.
     */
    where: AdminComplaintWhereUniqueInput
    /**
     * In case the AdminComplaint found by the `where` argument doesn't exist, create a new AdminComplaint with this data.
     */
    create: XOR<AdminComplaintCreateInput, AdminComplaintUncheckedCreateInput>
    /**
     * In case the AdminComplaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminComplaintUpdateInput, AdminComplaintUncheckedUpdateInput>
  }

  /**
   * AdminComplaint delete
   */
  export type AdminComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
    /**
     * Filter which AdminComplaint to delete.
     */
    where: AdminComplaintWhereUniqueInput
  }

  /**
   * AdminComplaint deleteMany
   */
  export type AdminComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminComplaints to delete
     */
    where?: AdminComplaintWhereInput
    /**
     * Limit how many AdminComplaints to delete.
     */
    limit?: number
  }

  /**
   * AdminComplaint without action
   */
  export type AdminComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminComplaint
     */
    select?: AdminComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminComplaint
     */
    omit?: AdminComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminComplaintInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone_number: 'phone_number',
    password: 'password',
    apartment_no: 'apartment_no',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    code_expiry: 'code_expiry',
    phone_verification_code: 'phone_verification_code',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login',
    plates: 'plates',
    resident_count: 'resident_count',
    resident_type: 'resident_type',
    block_id: 'block_id',
    is_password_set: 'is_password_set',
    reset_code: 'reset_code',
    reset_code_expiry: 'reset_code_expiry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password: 'password',
    account_type: 'account_type',
    company_name: 'company_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    tokenExpiry: 'tokenExpiry',
    verificationToken: 'verificationToken',
    is_verified: 'is_verified',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login',
    company_code: 'company_code',
    companyId: 'companyId',
    individualId: 'individualId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    site_id: 'site_id',
    site_name: 'site_name',
    site_address: 'site_address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    adminId: 'adminId',
    apartment_count: 'apartment_count',
    block_count: 'block_count',
    company_id: 'company_id',
    deleted_at: 'deleted_at',
    site_status: 'site_status'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const SocialAmenityScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    description: 'description',
    status: 'status',
    hours: 'hours',
    rules: 'rules',
    extra: 'extra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialAmenityScalarFieldEnum = (typeof SocialAmenityScalarFieldEnum)[keyof typeof SocialAmenityScalarFieldEnum]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    start_date: 'start_date',
    end_date: 'end_date'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const BlocksScalarFieldEnum: {
    id: 'id',
    block_name: 'block_name',
    site_id: 'site_id',
    created_at: 'created_at',
    block_number: 'block_number',
    deleted_at: 'deleted_at',
    updated_at: 'updated_at',
    apartment_count: 'apartment_count'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    company_code: 'company_code',
    account_status: 'account_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    expiry_date: 'expiry_date'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const IndividualsScalarFieldEnum: {
    id: 'id',
    site_id: 'site_id',
    admin_id: 'admin_id',
    account_status: 'account_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    expiry_date: 'expiry_date'
  };

  export type IndividualsScalarFieldEnum = (typeof IndividualsScalarFieldEnum)[keyof typeof IndividualsScalarFieldEnum]


  export const Company_employeesScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    company_id: 'company_id',
    joined_at: 'joined_at',
    status: 'status',
    deleted_at: 'deleted_at'
  };

  export type Company_employeesScalarFieldEnum = (typeof Company_employeesScalarFieldEnum)[keyof typeof Company_employeesScalarFieldEnum]


  export const ComplaintsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    status: 'status',
    siteId: 'siteId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    category: 'category'
  };

  export type ComplaintsScalarFieldEnum = (typeof ComplaintsScalarFieldEnum)[keyof typeof ComplaintsScalarFieldEnum]


  export const Employee_site_accessScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    site_id: 'site_id',
    granted_at: 'granted_at',
    deleted_at: 'deleted_at'
  };

  export type Employee_site_accessScalarFieldEnum = (typeof Employee_site_accessScalarFieldEnum)[keyof typeof Employee_site_accessScalarFieldEnum]


  export const InvitationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    invite_code: 'invite_code',
    invite_link: 'invite_link',
    invited_email: 'invited_email',
    invited_by: 'invited_by',
    status: 'status',
    expires_at: 'expires_at',
    used_at: 'used_at',
    used_by: 'used_by',
    created_at: 'created_at'
  };

  export type InvitationsScalarFieldEnum = (typeof InvitationsScalarFieldEnum)[keyof typeof InvitationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    description: 'description',
    created_at: 'created_at',
    userId: 'userId',
    siteId: 'siteId'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const MasterUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    full_name: 'full_name',
    master_role: 'master_role',
    is_active: 'is_active',
    is_verified: 'is_verified',
    verificationToken: 'verificationToken',
    tokenExpiry: 'tokenExpiry',
    last_login_at: 'last_login_at',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MasterUserScalarFieldEnum = (typeof MasterUserScalarFieldEnum)[keyof typeof MasterUserScalarFieldEnum]


  export const AdminComplaintScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    accountType: 'accountType',
    title: 'title',
    content: 'content',
    category: 'category',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    master_note: 'master_note'
  };

  export type AdminComplaintScalarFieldEnum = (typeof AdminComplaintScalarFieldEnum)[keyof typeof AdminComplaintScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'ResidentType'
   */
  export type EnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType'>
    


  /**
   * Reference to a field of type 'ResidentType[]'
   */
  export type ListEnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'MasterRole'
   */
  export type EnumMasterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasterRole'>
    


  /**
   * Reference to a field of type 'MasterRole[]'
   */
  export type ListEnumMasterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasterRole[]'>
    


  /**
   * Reference to a field of type 'AdminComplaintCategory'
   */
  export type EnumAdminComplaintCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminComplaintCategory'>
    


  /**
   * Reference to a field of type 'AdminComplaintCategory[]'
   */
  export type ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminComplaintCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    complaints?: ComplaintsListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    complaints?: complaintsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    blocks?: blocksOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    complaints?: ComplaintsListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id" | "phone_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    full_name?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    apartment_no?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    siteId?: IntWithAggregatesFilter<"User"> | number
    code_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    plates?: StringNullableWithAggregatesFilter<"User"> | string | null
    resident_count?: IntNullableWithAggregatesFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableWithAggregatesFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableWithAggregatesFilter<"User"> | number | null
    is_password_set?: BoolWithAggregatesFilter<"User"> | boolean
    reset_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    full_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    account_type?: EnumAccountTypeFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableFilter<"Admin"> | string | null
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    verificationToken?: StringNullableFilter<"Admin"> | string | null
    is_verified?: BoolFilter<"Admin"> | boolean
    resetToken?: StringNullableFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    company_code?: StringNullableFilter<"Admin"> | string | null
    companyId?: IntNullableFilter<"Admin"> | number | null
    individualId?: IntNullableFilter<"Admin"> | number | null
    company?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    individual?: XOR<IndividualsNullableScalarRelationFilter, individualsWhereInput> | null
    sites_created?: SiteListRelationFilter
    adminComplaints?: AdminComplaintListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    company_code?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    individualId?: SortOrderInput | SortOrder
    company?: companiesOrderByWithRelationInput
    company_employees?: company_employeesOrderByWithRelationInput
    individual?: individualsOrderByWithRelationInput
    sites_created?: SiteOrderByRelationAggregateInput
    adminComplaints?: AdminComplaintOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    verificationToken?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    full_name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    account_type?: EnumAccountTypeFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableFilter<"Admin"> | string | null
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    is_verified?: BoolFilter<"Admin"> | boolean
    resetToken?: StringNullableFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    company_code?: StringNullableFilter<"Admin"> | string | null
    companyId?: IntNullableFilter<"Admin"> | number | null
    individualId?: IntNullableFilter<"Admin"> | number | null
    company?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    individual?: XOR<IndividualsNullableScalarRelationFilter, individualsWhereInput> | null
    sites_created?: SiteListRelationFilter
    adminComplaints?: AdminComplaintListRelationFilter
  }, "id" | "email" | "verificationToken">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    company_code?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    individualId?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    full_name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    account_type?: EnumAccountTypeWithAggregatesFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    is_verified?: BoolWithAggregatesFilter<"Admin"> | boolean
    resetToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    company_code?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    companyId?: IntNullableWithAggregatesFilter<"Admin"> | number | null
    individualId?: IntNullableWithAggregatesFilter<"Admin"> | number | null
  }

  export type SiteWhereInput = {
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    id?: IntFilter<"Site"> | number
    site_id?: StringFilter<"Site"> | string
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
    announcements?: AnnouncementsListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintsListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    individuals?: XOR<IndividualsNullableScalarRelationFilter, individualsWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    socialAmenities?: SocialAmenityListRelationFilter
    users?: UserListRelationFilter
  }

  export type SiteOrderByWithRelationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    announcements?: announcementsOrderByRelationAggregateInput
    blocks?: blocksOrderByRelationAggregateInput
    complaints?: complaintsOrderByRelationAggregateInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
    individuals?: individualsOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    socialAmenities?: SocialAmenityOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type SiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id?: string
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
    announcements?: AnnouncementsListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintsListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    individuals?: XOR<IndividualsNullableScalarRelationFilter, individualsWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    socialAmenities?: SocialAmenityListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "site_id">

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    _count?: SiteCountOrderByAggregateInput
    _avg?: SiteAvgOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
    _sum?: SiteSumOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    OR?: SiteScalarWhereWithAggregatesInput[]
    NOT?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Site"> | number
    site_id?: StringWithAggregatesFilter<"Site"> | string
    site_name?: StringWithAggregatesFilter<"Site"> | string
    site_address?: StringWithAggregatesFilter<"Site"> | string
    created_at?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    adminId?: IntNullableWithAggregatesFilter<"Site"> | number | null
    apartment_count?: IntNullableWithAggregatesFilter<"Site"> | number | null
    block_count?: IntNullableWithAggregatesFilter<"Site"> | number | null
    company_id?: IntNullableWithAggregatesFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusWithAggregatesFilter<"Site"> | $Enums.AccountStatus
  }

  export type SocialAmenityWhereInput = {
    AND?: SocialAmenityWhereInput | SocialAmenityWhereInput[]
    OR?: SocialAmenityWhereInput[]
    NOT?: SocialAmenityWhereInput | SocialAmenityWhereInput[]
    id?: StringFilter<"SocialAmenity"> | string
    siteId?: IntFilter<"SocialAmenity"> | number
    name?: StringFilter<"SocialAmenity"> | string
    description?: StringNullableFilter<"SocialAmenity"> | string | null
    status?: StringFilter<"SocialAmenity"> | string
    hours?: StringNullableFilter<"SocialAmenity"> | string | null
    rules?: StringNullableFilter<"SocialAmenity"> | string | null
    extra?: StringNullableFilter<"SocialAmenity"> | string | null
    createdAt?: DateTimeFilter<"SocialAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAmenity"> | Date | string
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type SocialAmenityOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    site?: SiteOrderByWithRelationInput
  }

  export type SocialAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialAmenityWhereInput | SocialAmenityWhereInput[]
    OR?: SocialAmenityWhereInput[]
    NOT?: SocialAmenityWhereInput | SocialAmenityWhereInput[]
    siteId?: IntFilter<"SocialAmenity"> | number
    name?: StringFilter<"SocialAmenity"> | string
    description?: StringNullableFilter<"SocialAmenity"> | string | null
    status?: StringFilter<"SocialAmenity"> | string
    hours?: StringNullableFilter<"SocialAmenity"> | string | null
    rules?: StringNullableFilter<"SocialAmenity"> | string | null
    extra?: StringNullableFilter<"SocialAmenity"> | string | null
    createdAt?: DateTimeFilter<"SocialAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAmenity"> | Date | string
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type SocialAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialAmenityCountOrderByAggregateInput
    _avg?: SocialAmenityAvgOrderByAggregateInput
    _max?: SocialAmenityMaxOrderByAggregateInput
    _min?: SocialAmenityMinOrderByAggregateInput
    _sum?: SocialAmenitySumOrderByAggregateInput
  }

  export type SocialAmenityScalarWhereWithAggregatesInput = {
    AND?: SocialAmenityScalarWhereWithAggregatesInput | SocialAmenityScalarWhereWithAggregatesInput[]
    OR?: SocialAmenityScalarWhereWithAggregatesInput[]
    NOT?: SocialAmenityScalarWhereWithAggregatesInput | SocialAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialAmenity"> | string
    siteId?: IntWithAggregatesFilter<"SocialAmenity"> | number
    name?: StringWithAggregatesFilter<"SocialAmenity"> | string
    description?: StringNullableWithAggregatesFilter<"SocialAmenity"> | string | null
    status?: StringWithAggregatesFilter<"SocialAmenity"> | string
    hours?: StringNullableWithAggregatesFilter<"SocialAmenity"> | string | null
    rules?: StringNullableWithAggregatesFilter<"SocialAmenity"> | string | null
    extra?: StringNullableWithAggregatesFilter<"SocialAmenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SocialAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialAmenity"> | Date | string
  }

  export type announcementsWhereInput = {
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    id?: IntFilter<"announcements"> | number
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type announcementsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    sites?: SiteOrderByWithRelationInput
  }

  export type announcementsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type announcementsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    _count?: announcementsCountOrderByAggregateInput
    _avg?: announcementsAvgOrderByAggregateInput
    _max?: announcementsMaxOrderByAggregateInput
    _min?: announcementsMinOrderByAggregateInput
    _sum?: announcementsSumOrderByAggregateInput
  }

  export type announcementsScalarWhereWithAggregatesInput = {
    AND?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    OR?: announcementsScalarWhereWithAggregatesInput[]
    NOT?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"announcements"> | number
    title?: StringWithAggregatesFilter<"announcements"> | string
    content?: StringWithAggregatesFilter<"announcements"> | string
    created_at?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    siteId?: IntWithAggregatesFilter<"announcements"> | number
    start_date?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
  }

  export type blocksWhereInput = {
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    block_number?: IntNullableFilter<"blocks"> | number | null
    deleted_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeFilter<"blocks"> | Date | string
    apartment_count?: IntNullableFilter<"blocks"> | number | null
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: UserListRelationFilter
  }

  export type blocksOrderByWithRelationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    block_number?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    apartment_count?: SortOrderInput | SortOrder
    sites?: SiteOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type blocksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id_block_name?: blocksSite_idBlock_nameCompoundUniqueInput
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    block_number?: IntNullableFilter<"blocks"> | number | null
    deleted_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeFilter<"blocks"> | Date | string
    apartment_count?: IntNullableFilter<"blocks"> | number | null
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: UserListRelationFilter
  }, "id" | "site_id_block_name">

  export type blocksOrderByWithAggregationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    block_number?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    apartment_count?: SortOrderInput | SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    OR?: blocksScalarWhereWithAggregatesInput[]
    NOT?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"blocks"> | number
    block_name?: StringWithAggregatesFilter<"blocks"> | string
    site_id?: IntWithAggregatesFilter<"blocks"> | number
    created_at?: DateTimeWithAggregatesFilter<"blocks"> | Date | string
    block_number?: IntNullableWithAggregatesFilter<"blocks"> | number | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeWithAggregatesFilter<"blocks"> | Date | string
    apartment_count?: IntNullableWithAggregatesFilter<"blocks"> | number | null
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: IntFilter<"companies"> | number
    company_name?: StringFilter<"companies"> | string
    company_code?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"companies"> | Date | string | null
    admins?: AdminListRelationFilter
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SiteListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    admins?: AdminOrderByRelationAggregateInput
    company_employees?: company_employeesOrderByRelationAggregateInput
    invitations?: invitationsOrderByRelationAggregateInput
    sites?: SiteOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    company_code?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    company_name?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"companies"> | Date | string | null
    admins?: AdminListRelationFilter
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SiteListRelationFilter
  }, "id" | "company_code">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companies"> | number
    company_name?: StringWithAggregatesFilter<"companies"> | string
    company_code?: StringWithAggregatesFilter<"companies"> | string
    account_status?: EnumAccountStatusWithAggregatesFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
  }

  export type individualsWhereInput = {
    AND?: individualsWhereInput | individualsWhereInput[]
    OR?: individualsWhereInput[]
    NOT?: individualsWhereInput | individualsWhereInput[]
    id?: IntFilter<"individuals"> | number
    site_id?: IntNullableFilter<"individuals"> | number | null
    admin_id?: IntFilter<"individuals"> | number
    account_status?: EnumAccountStatusFilter<"individuals"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"individuals"> | Date | string
    updated_at?: DateTimeFilter<"individuals"> | Date | string
    deleted_at?: DateTimeNullableFilter<"individuals"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"individuals"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
  }

  export type individualsOrderByWithRelationInput = {
    id?: SortOrder
    site_id?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type individualsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id?: number
    admin_id?: number
    AND?: individualsWhereInput | individualsWhereInput[]
    OR?: individualsWhereInput[]
    NOT?: individualsWhereInput | individualsWhereInput[]
    account_status?: EnumAccountStatusFilter<"individuals"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"individuals"> | Date | string
    updated_at?: DateTimeFilter<"individuals"> | Date | string
    deleted_at?: DateTimeNullableFilter<"individuals"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"individuals"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
  }, "id" | "site_id" | "admin_id">

  export type individualsOrderByWithAggregationInput = {
    id?: SortOrder
    site_id?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    _count?: individualsCountOrderByAggregateInput
    _avg?: individualsAvgOrderByAggregateInput
    _max?: individualsMaxOrderByAggregateInput
    _min?: individualsMinOrderByAggregateInput
    _sum?: individualsSumOrderByAggregateInput
  }

  export type individualsScalarWhereWithAggregatesInput = {
    AND?: individualsScalarWhereWithAggregatesInput | individualsScalarWhereWithAggregatesInput[]
    OR?: individualsScalarWhereWithAggregatesInput[]
    NOT?: individualsScalarWhereWithAggregatesInput | individualsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"individuals"> | number
    site_id?: IntNullableWithAggregatesFilter<"individuals"> | number | null
    admin_id?: IntWithAggregatesFilter<"individuals"> | number
    account_status?: EnumAccountStatusWithAggregatesFilter<"individuals"> | $Enums.AccountStatus
    created_at?: DateTimeWithAggregatesFilter<"individuals"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"individuals"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"individuals"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"individuals"> | Date | string | null
  }

  export type company_employeesWhereInput = {
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"company_employees"> | Date | string | null
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }

  export type company_employeesOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    admins?: AdminOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
  }

  export type company_employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    admin_id?: number
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"company_employees"> | Date | string | null
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }, "id" | "admin_id">

  export type company_employeesOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: company_employeesCountOrderByAggregateInput
    _avg?: company_employeesAvgOrderByAggregateInput
    _max?: company_employeesMaxOrderByAggregateInput
    _min?: company_employeesMinOrderByAggregateInput
    _sum?: company_employeesSumOrderByAggregateInput
  }

  export type company_employeesScalarWhereWithAggregatesInput = {
    AND?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    OR?: company_employeesScalarWhereWithAggregatesInput[]
    NOT?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"company_employees"> | number
    admin_id?: IntWithAggregatesFilter<"company_employees"> | number
    company_id?: IntWithAggregatesFilter<"company_employees"> | number
    joined_at?: DateTimeWithAggregatesFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusWithAggregatesFilter<"company_employees"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"company_employees"> | Date | string | null
  }

  export type complaintsWhereInput = {
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    id?: IntFilter<"complaints"> | number
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type complaintsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    sites?: SiteOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type complaintsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type complaintsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: complaintsCountOrderByAggregateInput
    _avg?: complaintsAvgOrderByAggregateInput
    _max?: complaintsMaxOrderByAggregateInput
    _min?: complaintsMinOrderByAggregateInput
    _sum?: complaintsSumOrderByAggregateInput
  }

  export type complaintsScalarWhereWithAggregatesInput = {
    AND?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    OR?: complaintsScalarWhereWithAggregatesInput[]
    NOT?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"complaints"> | number
    title?: StringWithAggregatesFilter<"complaints"> | string
    content?: StringWithAggregatesFilter<"complaints"> | string
    status?: EnumStatusWithAggregatesFilter<"complaints"> | $Enums.Status
    siteId?: IntWithAggregatesFilter<"complaints"> | number
    userId?: IntWithAggregatesFilter<"complaints"> | number
    created_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableWithAggregatesFilter<"complaints"> | $Enums.Category | null
  }

  export type employee_site_accessWhereInput = {
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    deleted_at?: DateTimeNullableFilter<"employee_site_access"> | Date | string | null
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type employee_site_accessOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    company_employees?: company_employeesOrderByWithRelationInput
    sites?: SiteOrderByWithRelationInput
  }

  export type employee_site_accessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employee_id_site_id?: employee_site_accessEmployee_idSite_idCompoundUniqueInput
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    deleted_at?: DateTimeNullableFilter<"employee_site_access"> | Date | string | null
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id" | "employee_id_site_id">

  export type employee_site_accessOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: employee_site_accessCountOrderByAggregateInput
    _avg?: employee_site_accessAvgOrderByAggregateInput
    _max?: employee_site_accessMaxOrderByAggregateInput
    _min?: employee_site_accessMinOrderByAggregateInput
    _sum?: employee_site_accessSumOrderByAggregateInput
  }

  export type employee_site_accessScalarWhereWithAggregatesInput = {
    AND?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    OR?: employee_site_accessScalarWhereWithAggregatesInput[]
    NOT?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employee_site_access"> | number
    employee_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    site_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    granted_at?: DateTimeWithAggregatesFilter<"employee_site_access"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"employee_site_access"> | Date | string | null
  }

  export type invitationsWhereInput = {
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type invitationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type invitationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invite_code?: string
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    company_id?: IntFilter<"invitations"> | number
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id" | "invite_code">

  export type invitationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: invitationsCountOrderByAggregateInput
    _avg?: invitationsAvgOrderByAggregateInput
    _max?: invitationsMaxOrderByAggregateInput
    _min?: invitationsMinOrderByAggregateInput
    _sum?: invitationsSumOrderByAggregateInput
  }

  export type invitationsScalarWhereWithAggregatesInput = {
    AND?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    OR?: invitationsScalarWhereWithAggregatesInput[]
    NOT?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"invitations"> | number
    company_id?: IntWithAggregatesFilter<"invitations"> | number
    invite_code?: StringWithAggregatesFilter<"invitations"> | string
    invite_link?: StringWithAggregatesFilter<"invitations"> | string
    invited_email?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    invited_by?: IntWithAggregatesFilter<"invitations"> | number
    status?: EnumInvitationStatusWithAggregatesFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"invitations"> | Date | string | null
    used_by?: IntNullableWithAggregatesFilter<"invitations"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    amount?: FloatWithAggregatesFilter<"payments"> | number
    payment_date?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    userId?: IntWithAggregatesFilter<"payments"> | number
    siteId?: IntWithAggregatesFilter<"payments"> | number
  }

  export type MasterUserWhereInput = {
    AND?: MasterUserWhereInput | MasterUserWhereInput[]
    OR?: MasterUserWhereInput[]
    NOT?: MasterUserWhereInput | MasterUserWhereInput[]
    id?: IntFilter<"MasterUser"> | number
    email?: StringFilter<"MasterUser"> | string
    password_hash?: StringFilter<"MasterUser"> | string
    full_name?: StringFilter<"MasterUser"> | string
    master_role?: EnumMasterRoleFilter<"MasterUser"> | $Enums.MasterRole
    is_active?: BoolFilter<"MasterUser"> | boolean
    is_verified?: BoolFilter<"MasterUser"> | boolean
    verificationToken?: StringNullableFilter<"MasterUser"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    last_login_at?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    created_at?: DateTimeFilter<"MasterUser"> | Date | string
    updated_at?: DateTimeFilter<"MasterUser"> | Date | string
  }

  export type MasterUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    master_role?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MasterUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: MasterUserWhereInput | MasterUserWhereInput[]
    OR?: MasterUserWhereInput[]
    NOT?: MasterUserWhereInput | MasterUserWhereInput[]
    password_hash?: StringFilter<"MasterUser"> | string
    full_name?: StringFilter<"MasterUser"> | string
    master_role?: EnumMasterRoleFilter<"MasterUser"> | $Enums.MasterRole
    is_active?: BoolFilter<"MasterUser"> | boolean
    is_verified?: BoolFilter<"MasterUser"> | boolean
    verificationToken?: StringNullableFilter<"MasterUser"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    last_login_at?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"MasterUser"> | Date | string | null
    created_at?: DateTimeFilter<"MasterUser"> | Date | string
    updated_at?: DateTimeFilter<"MasterUser"> | Date | string
  }, "id" | "email">

  export type MasterUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    master_role?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MasterUserCountOrderByAggregateInput
    _avg?: MasterUserAvgOrderByAggregateInput
    _max?: MasterUserMaxOrderByAggregateInput
    _min?: MasterUserMinOrderByAggregateInput
    _sum?: MasterUserSumOrderByAggregateInput
  }

  export type MasterUserScalarWhereWithAggregatesInput = {
    AND?: MasterUserScalarWhereWithAggregatesInput | MasterUserScalarWhereWithAggregatesInput[]
    OR?: MasterUserScalarWhereWithAggregatesInput[]
    NOT?: MasterUserScalarWhereWithAggregatesInput | MasterUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterUser"> | number
    email?: StringWithAggregatesFilter<"MasterUser"> | string
    password_hash?: StringWithAggregatesFilter<"MasterUser"> | string
    full_name?: StringWithAggregatesFilter<"MasterUser"> | string
    master_role?: EnumMasterRoleWithAggregatesFilter<"MasterUser"> | $Enums.MasterRole
    is_active?: BoolWithAggregatesFilter<"MasterUser"> | boolean
    is_verified?: BoolWithAggregatesFilter<"MasterUser"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"MasterUser"> | string | null
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"MasterUser"> | Date | string | null
    last_login_at?: DateTimeNullableWithAggregatesFilter<"MasterUser"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"MasterUser"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MasterUser"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MasterUser"> | Date | string
  }

  export type AdminComplaintWhereInput = {
    AND?: AdminComplaintWhereInput | AdminComplaintWhereInput[]
    OR?: AdminComplaintWhereInput[]
    NOT?: AdminComplaintWhereInput | AdminComplaintWhereInput[]
    id?: IntFilter<"AdminComplaint"> | number
    adminId?: IntFilter<"AdminComplaint"> | number
    accountType?: EnumAccountTypeFilter<"AdminComplaint"> | $Enums.AccountType
    title?: StringFilter<"AdminComplaint"> | string
    content?: StringFilter<"AdminComplaint"> | string
    category?: EnumAdminComplaintCategoryNullableFilter<"AdminComplaint"> | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFilter<"AdminComplaint"> | $Enums.Status
    created_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    updated_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    master_note?: StringNullableFilter<"AdminComplaint"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminComplaintOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    accountType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    master_note?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type AdminComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminComplaintWhereInput | AdminComplaintWhereInput[]
    OR?: AdminComplaintWhereInput[]
    NOT?: AdminComplaintWhereInput | AdminComplaintWhereInput[]
    adminId?: IntFilter<"AdminComplaint"> | number
    accountType?: EnumAccountTypeFilter<"AdminComplaint"> | $Enums.AccountType
    title?: StringFilter<"AdminComplaint"> | string
    content?: StringFilter<"AdminComplaint"> | string
    category?: EnumAdminComplaintCategoryNullableFilter<"AdminComplaint"> | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFilter<"AdminComplaint"> | $Enums.Status
    created_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    updated_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    master_note?: StringNullableFilter<"AdminComplaint"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    accountType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    master_note?: SortOrderInput | SortOrder
    _count?: AdminComplaintCountOrderByAggregateInput
    _avg?: AdminComplaintAvgOrderByAggregateInput
    _max?: AdminComplaintMaxOrderByAggregateInput
    _min?: AdminComplaintMinOrderByAggregateInput
    _sum?: AdminComplaintSumOrderByAggregateInput
  }

  export type AdminComplaintScalarWhereWithAggregatesInput = {
    AND?: AdminComplaintScalarWhereWithAggregatesInput | AdminComplaintScalarWhereWithAggregatesInput[]
    OR?: AdminComplaintScalarWhereWithAggregatesInput[]
    NOT?: AdminComplaintScalarWhereWithAggregatesInput | AdminComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminComplaint"> | number
    adminId?: IntWithAggregatesFilter<"AdminComplaint"> | number
    accountType?: EnumAccountTypeWithAggregatesFilter<"AdminComplaint"> | $Enums.AccountType
    title?: StringWithAggregatesFilter<"AdminComplaint"> | string
    content?: StringWithAggregatesFilter<"AdminComplaint"> | string
    category?: EnumAdminComplaintCategoryNullableWithAggregatesFilter<"AdminComplaint"> | $Enums.AdminComplaintCategory | null
    status?: EnumStatusWithAggregatesFilter<"AdminComplaint"> | $Enums.Status
    created_at?: DateTimeWithAggregatesFilter<"AdminComplaint"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AdminComplaint"> | Date | string
    master_note?: StringNullableWithAggregatesFilter<"AdminComplaint"> | string | null
  }

  export type UserCreateInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company?: companiesCreateNestedOneWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    individual?: individualsCreateNestedOneWithoutAdminInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    individual?: individualsUncheckedCreateNestedOneWithoutAdminInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companiesUpdateOneWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    individual?: individualsUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    individual?: individualsUncheckedUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
  }

  export type AdminUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SiteCreateInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteUpdateInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateManyInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type SiteUpdateManyMutationInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type SocialAmenityCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site: SiteCreateNestedOneWithoutSocialAmenitiesInput
  }

  export type SocialAmenityUncheckedCreateInput = {
    id?: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneRequiredWithoutSocialAmenitiesNestedInput
  }

  export type SocialAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAmenityCreateManyInput = {
    id?: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
    sites: SiteCreateNestedOneWithoutAnnouncementsInput
  }

  export type announcementsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type announcementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateManyInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksCreateInput = {
    block_name: string
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
    sites: SiteCreateNestedOneWithoutBlocksInput
    users?: UserCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
    users?: UserUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksUpdateInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    sites?: SiteUpdateOneRequiredWithoutBlocksNestedInput
    users?: UserUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksCreateManyInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
  }

  export type blocksUpdateManyMutationInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type blocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type companiesCreateInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
  }

  export type companiesUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type individualsCreateInput = {
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admin: AdminCreateNestedOneWithoutIndividualInput
    site?: SiteCreateNestedOneWithoutIndividualsInput
  }

  export type individualsUncheckedCreateInput = {
    id?: number
    site_id?: number | null
    admin_id: number
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
  }

  export type individualsUpdateInput = {
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutIndividualNestedInput
    site?: SiteUpdateOneWithoutIndividualsNestedInput
  }

  export type individualsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    admin_id?: IntFieldUpdateOperationsInput | number
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type individualsCreateManyInput = {
    id?: number
    site_id?: number | null
    admin_id: number
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
  }

  export type individualsUpdateManyMutationInput = {
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type individualsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    admin_id?: IntFieldUpdateOperationsInput | number
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_employeesCreateInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUpdateInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesCreateManyInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
  }

  export type company_employeesUpdateManyMutationInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type complaintsCreateInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    sites: SiteCreateNestedOneWithoutComplaintsInput
    users: UserCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sites?: SiteUpdateOneRequiredWithoutComplaintsNestedInput
    users?: UserUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsCreateManyInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type employee_site_accessCreateInput = {
    granted_at?: Date | string
    deleted_at?: Date | string | null
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
    sites: SiteCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type employee_site_accessUpdateInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
    sites?: SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employee_site_accessCreateManyInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type employee_site_accessUpdateManyMutationInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employee_site_accessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invitationsCreateInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
    companies: companiesCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateManyInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateManyMutationInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
    users: UserCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsCreateManyInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type MasterUserCreateInput = {
    email: string
    password_hash: string
    full_name: string
    master_role?: $Enums.MasterRole
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: string | null
    tokenExpiry?: Date | string | null
    last_login_at?: Date | string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MasterUserUncheckedCreateInput = {
    id?: number
    email: string
    password_hash: string
    full_name: string
    master_role?: $Enums.MasterRole
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: string | null
    tokenExpiry?: Date | string | null
    last_login_at?: Date | string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MasterUserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    master_role?: EnumMasterRoleFieldUpdateOperationsInput | $Enums.MasterRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    master_role?: EnumMasterRoleFieldUpdateOperationsInput | $Enums.MasterRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterUserCreateManyInput = {
    id?: number
    email: string
    password_hash: string
    full_name: string
    master_role?: $Enums.MasterRole
    is_active?: boolean
    is_verified?: boolean
    verificationToken?: string | null
    tokenExpiry?: Date | string | null
    last_login_at?: Date | string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MasterUserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    master_role?: EnumMasterRoleFieldUpdateOperationsInput | $Enums.MasterRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    master_role?: EnumMasterRoleFieldUpdateOperationsInput | $Enums.MasterRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminComplaintCreateInput = {
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
    admin: AdminCreateNestedOneWithoutAdminComplaintsInput
  }

  export type AdminComplaintUncheckedCreateInput = {
    id?: number
    adminId: number
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
  }

  export type AdminComplaintUpdateInput = {
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneRequiredWithoutAdminComplaintsNestedInput
  }

  export type AdminComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminComplaintCreateManyInput = {
    id?: number
    adminId: number
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
  }

  export type AdminComplaintUpdateManyMutationInput = {
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ComplaintsListRelationFilter = {
    every?: complaintsWhereInput
    some?: complaintsWhereInput
    none?: complaintsWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type BlocksNullableScalarRelationFilter = {
    is?: blocksWhereInput | null
    isNot?: blocksWhereInput | null
  }

  export type SiteScalarRelationFilter = {
    is?: SiteWhereInput
    isNot?: SiteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type complaintsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type Company_employeesNullableScalarRelationFilter = {
    is?: company_employeesWhereInput | null
    isNot?: company_employeesWhereInput | null
  }

  export type IndividualsNullableScalarRelationFilter = {
    is?: individualsWhereInput | null
    isNot?: individualsWhereInput | null
  }

  export type SiteListRelationFilter = {
    every?: SiteWhereInput
    some?: SiteWhereInput
    none?: SiteWhereInput
  }

  export type AdminComplaintListRelationFilter = {
    every?: AdminComplaintWhereInput
    some?: AdminComplaintWhereInput
    none?: AdminComplaintWhereInput
  }

  export type SiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    company_code?: SortOrder
    companyId?: SortOrder
    individualId?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    individualId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    company_code?: SortOrder
    companyId?: SortOrder
    individualId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    company_code?: SortOrder
    companyId?: SortOrder
    individualId?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    individualId?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type AnnouncementsListRelationFilter = {
    every?: announcementsWhereInput
    some?: announcementsWhereInput
    none?: announcementsWhereInput
  }

  export type BlocksListRelationFilter = {
    every?: blocksWhereInput
    some?: blocksWhereInput
    none?: blocksWhereInput
  }

  export type Employee_site_accessListRelationFilter = {
    every?: employee_site_accessWhereInput
    some?: employee_site_accessWhereInput
    none?: employee_site_accessWhereInput
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SocialAmenityListRelationFilter = {
    every?: SocialAmenityWhereInput
    some?: SocialAmenityWhereInput
    none?: SocialAmenityWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type announcementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employee_site_accessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type SocialAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAmenityAvgOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type SocialAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAmenitySumOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type announcementsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type announcementsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type blocksSite_idBlock_nameCompoundUniqueInput = {
    site_id: number
    block_name: string
  }

  export type blocksCountOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    block_number?: SortOrder
    deleted_at?: SortOrder
    updated_at?: SortOrder
    apartment_count?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    block_number?: SortOrder
    apartment_count?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    block_number?: SortOrder
    deleted_at?: SortOrder
    updated_at?: SortOrder
    apartment_count?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    block_number?: SortOrder
    deleted_at?: SortOrder
    updated_at?: SortOrder
    apartment_count?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    block_number?: SortOrder
    apartment_count?: SortOrder
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type Company_employeesListRelationFilter = {
    every?: company_employeesWhereInput
    some?: company_employeesWhereInput
    none?: company_employeesWhereInput
  }

  export type InvitationsListRelationFilter = {
    every?: invitationsWhereInput
    some?: invitationsWhereInput
    none?: invitationsWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invitationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type SiteNullableScalarRelationFilter = {
    is?: SiteWhereInput | null
    isNot?: SiteWhereInput | null
  }

  export type individualsCountOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    admin_id?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type individualsAvgOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    admin_id?: SortOrder
  }

  export type individualsMaxOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    admin_id?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type individualsMinOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    admin_id?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    expiry_date?: SortOrder
  }

  export type individualsSumOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    admin_id?: SortOrder
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type company_employeesCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type company_employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type company_employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type company_employeesMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type company_employeesSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type complaintsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type complaintsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type Company_employeesScalarRelationFilter = {
    is?: company_employeesWhereInput
    isNot?: company_employeesWhereInput
  }

  export type employee_site_accessEmployee_idSite_idCompoundUniqueInput = {
    employee_id: number
    site_id: number
  }

  export type employee_site_accessCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type employee_site_accessAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type employee_site_accessMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type employee_site_accessMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type employee_site_accessSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type invitationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type invitationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumMasterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterRole | EnumMasterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterRoleFilter<$PrismaModel> | $Enums.MasterRole
  }

  export type MasterUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    master_role?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    verificationToken?: SortOrder
    tokenExpiry?: SortOrder
    last_login_at?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MasterUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    master_role?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    verificationToken?: SortOrder
    tokenExpiry?: SortOrder
    last_login_at?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MasterUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    master_role?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    verificationToken?: SortOrder
    tokenExpiry?: SortOrder
    last_login_at?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MasterUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumMasterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterRole | EnumMasterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterRoleWithAggregatesFilter<$PrismaModel> | $Enums.MasterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasterRoleFilter<$PrismaModel>
    _max?: NestedEnumMasterRoleFilter<$PrismaModel>
  }

  export type EnumAdminComplaintCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminComplaintCategory | EnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel> | $Enums.AdminComplaintCategory | null
  }

  export type AdminComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    accountType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    master_note?: SortOrder
  }

  export type AdminComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
  }

  export type AdminComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    accountType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    master_note?: SortOrder
  }

  export type AdminComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    accountType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    master_note?: SortOrder
  }

  export type AdminComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
  }

  export type EnumAdminComplaintCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminComplaintCategory | EnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminComplaintCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminComplaintCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel>
  }

  export type complaintsCreateNestedManyWithoutUsersInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type blocksCreateNestedOneWithoutUsersInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    connect?: blocksWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutUsersInput = {
    create?: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SiteCreateOrConnectWithoutUsersInput
    connect?: SiteWhereUniqueInput
  }

  export type complaintsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumResidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResidentType | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type complaintsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsersInput | complaintsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsersInput | complaintsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsersInput | complaintsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type blocksUpdateOneWithoutUsersNestedInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    upsert?: blocksUpsertWithoutUsersInput
    disconnect?: blocksWhereInput | boolean
    delete?: blocksWhereInput | boolean
    connect?: blocksWhereUniqueInput
    update?: XOR<XOR<blocksUpdateToOneWithWhereWithoutUsersInput, blocksUpdateWithoutUsersInput>, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type SiteUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SiteCreateOrConnectWithoutUsersInput
    upsert?: SiteUpsertWithoutUsersInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutUsersInput, SiteUpdateWithoutUsersInput>, SiteUncheckedUpdateWithoutUsersInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type complaintsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsersInput | complaintsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsersInput | complaintsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsersInput | complaintsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutAdminsInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput
    connect?: companiesWhereUniqueInput
  }

  export type company_employeesCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type individualsCreateNestedOneWithoutAdminInput = {
    create?: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
    connectOrCreate?: individualsCreateOrConnectWithoutAdminInput
    connect?: individualsWhereUniqueInput
  }

  export type SiteCreateNestedManyWithoutAdminInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type AdminComplaintCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput> | AdminComplaintCreateWithoutAdminInput[] | AdminComplaintUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminComplaintCreateOrConnectWithoutAdminInput | AdminComplaintCreateOrConnectWithoutAdminInput[]
    createMany?: AdminComplaintCreateManyAdminInputEnvelope
    connect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type individualsUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
    connectOrCreate?: individualsCreateOrConnectWithoutAdminInput
    connect?: individualsWhereUniqueInput
  }

  export type SiteUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type AdminComplaintUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput> | AdminComplaintCreateWithoutAdminInput[] | AdminComplaintUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminComplaintCreateOrConnectWithoutAdminInput | AdminComplaintCreateOrConnectWithoutAdminInput[]
    createMany?: AdminComplaintCreateManyAdminInputEnvelope
    connect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type companiesUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput
    upsert?: companiesUpsertWithoutAdminsInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutAdminsInput, companiesUpdateWithoutAdminsInput>, companiesUncheckedUpdateWithoutAdminsInput>
  }

  export type company_employeesUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type individualsUpdateOneWithoutAdminNestedInput = {
    create?: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
    connectOrCreate?: individualsCreateOrConnectWithoutAdminInput
    upsert?: individualsUpsertWithoutAdminInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutAdminInput, individualsUpdateWithoutAdminInput>, individualsUncheckedUpdateWithoutAdminInput>
  }

  export type SiteUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutAdminInput | SiteUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutAdminInput | SiteUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutAdminInput | SiteUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AdminComplaintUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput> | AdminComplaintCreateWithoutAdminInput[] | AdminComplaintUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminComplaintCreateOrConnectWithoutAdminInput | AdminComplaintCreateOrConnectWithoutAdminInput[]
    upsert?: AdminComplaintUpsertWithWhereUniqueWithoutAdminInput | AdminComplaintUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminComplaintCreateManyAdminInputEnvelope
    set?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    disconnect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    delete?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    connect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    update?: AdminComplaintUpdateWithWhereUniqueWithoutAdminInput | AdminComplaintUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminComplaintUpdateManyWithWhereWithoutAdminInput | AdminComplaintUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminComplaintScalarWhereInput | AdminComplaintScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type individualsUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
    connectOrCreate?: individualsCreateOrConnectWithoutAdminInput
    upsert?: individualsUpsertWithoutAdminInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutAdminInput, individualsUpdateWithoutAdminInput>, individualsUncheckedUpdateWithoutAdminInput>
  }

  export type SiteUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutAdminInput | SiteUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutAdminInput | SiteUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutAdminInput | SiteUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput> | AdminComplaintCreateWithoutAdminInput[] | AdminComplaintUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminComplaintCreateOrConnectWithoutAdminInput | AdminComplaintCreateOrConnectWithoutAdminInput[]
    upsert?: AdminComplaintUpsertWithWhereUniqueWithoutAdminInput | AdminComplaintUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminComplaintCreateManyAdminInputEnvelope
    set?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    disconnect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    delete?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    connect?: AdminComplaintWhereUniqueInput | AdminComplaintWhereUniqueInput[]
    update?: AdminComplaintUpdateWithWhereUniqueWithoutAdminInput | AdminComplaintUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminComplaintUpdateManyWithWhereWithoutAdminInput | AdminComplaintUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminComplaintScalarWhereInput | AdminComplaintScalarWhereInput[]
  }

  export type announcementsCreateNestedManyWithoutSitesInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
  }

  export type blocksCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type complaintsCreateNestedManyWithoutSitesInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type employee_site_accessCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type individualsCreateNestedOneWithoutSiteInput = {
    create?: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
    connectOrCreate?: individualsCreateOrConnectWithoutSiteInput
    connect?: individualsWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutSites_createdInput = {
    create?: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSites_createdInput
    connect?: AdminWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutSitesInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    connect?: companiesWhereUniqueInput
  }

  export type SocialAmenityCreateNestedManyWithoutSiteInput = {
    create?: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput> | SocialAmenityCreateWithoutSiteInput[] | SocialAmenityUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SocialAmenityCreateOrConnectWithoutSiteInput | SocialAmenityCreateOrConnectWithoutSiteInput[]
    createMany?: SocialAmenityCreateManySiteInputEnvelope
    connect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutSiteInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type announcementsUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
  }

  export type blocksUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type complaintsUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type individualsUncheckedCreateNestedOneWithoutSiteInput = {
    create?: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
    connectOrCreate?: individualsCreateOrConnectWithoutSiteInput
    connect?: individualsWhereUniqueInput
  }

  export type SocialAmenityUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput> | SocialAmenityCreateWithoutSiteInput[] | SocialAmenityUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SocialAmenityCreateOrConnectWithoutSiteInput | SocialAmenityCreateOrConnectWithoutSiteInput[]
    createMany?: SocialAmenityCreateManySiteInputEnvelope
    connect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type announcementsUpdateManyWithoutSitesNestedInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    upsert?: announcementsUpsertWithWhereUniqueWithoutSitesInput | announcementsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    set?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    disconnect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    delete?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    update?: announcementsUpdateWithWhereUniqueWithoutSitesInput | announcementsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: announcementsUpdateManyWithWhereWithoutSitesInput | announcementsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
  }

  export type blocksUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type complaintsUpdateManyWithoutSitesNestedInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutSitesInput | complaintsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutSitesInput | complaintsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutSitesInput | complaintsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type employee_site_accessUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type individualsUpdateOneWithoutSiteNestedInput = {
    create?: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
    connectOrCreate?: individualsCreateOrConnectWithoutSiteInput
    upsert?: individualsUpsertWithoutSiteInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutSiteInput, individualsUpdateWithoutSiteInput>, individualsUncheckedUpdateWithoutSiteInput>
  }

  export type AdminUpdateOneWithoutSites_createdNestedInput = {
    create?: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSites_createdInput
    upsert?: AdminUpsertWithoutSites_createdInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSites_createdInput, AdminUpdateWithoutSites_createdInput>, AdminUncheckedUpdateWithoutSites_createdInput>
  }

  export type companiesUpdateOneWithoutSitesNestedInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    upsert?: companiesUpsertWithoutSitesInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutSitesInput, companiesUpdateWithoutSitesInput>, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type SocialAmenityUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput> | SocialAmenityCreateWithoutSiteInput[] | SocialAmenityUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SocialAmenityCreateOrConnectWithoutSiteInput | SocialAmenityCreateOrConnectWithoutSiteInput[]
    upsert?: SocialAmenityUpsertWithWhereUniqueWithoutSiteInput | SocialAmenityUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SocialAmenityCreateManySiteInputEnvelope
    set?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    disconnect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    delete?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    connect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    update?: SocialAmenityUpdateWithWhereUniqueWithoutSiteInput | SocialAmenityUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SocialAmenityUpdateManyWithWhereWithoutSiteInput | SocialAmenityUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SocialAmenityScalarWhereInput | SocialAmenityScalarWhereInput[]
  }

  export type UserUpdateManyWithoutSiteNestedInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSiteInput | UserUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSiteInput | UserUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSiteInput | UserUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type announcementsUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    upsert?: announcementsUpsertWithWhereUniqueWithoutSitesInput | announcementsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    set?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    disconnect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    delete?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    update?: announcementsUpdateWithWhereUniqueWithoutSitesInput | announcementsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: announcementsUpdateManyWithWhereWithoutSitesInput | announcementsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
  }

  export type blocksUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type complaintsUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutSitesInput | complaintsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutSitesInput | complaintsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutSitesInput | complaintsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type individualsUncheckedUpdateOneWithoutSiteNestedInput = {
    create?: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
    connectOrCreate?: individualsCreateOrConnectWithoutSiteInput
    upsert?: individualsUpsertWithoutSiteInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutSiteInput, individualsUpdateWithoutSiteInput>, individualsUncheckedUpdateWithoutSiteInput>
  }

  export type SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput> | SocialAmenityCreateWithoutSiteInput[] | SocialAmenityUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SocialAmenityCreateOrConnectWithoutSiteInput | SocialAmenityCreateOrConnectWithoutSiteInput[]
    upsert?: SocialAmenityUpsertWithWhereUniqueWithoutSiteInput | SocialAmenityUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SocialAmenityCreateManySiteInputEnvelope
    set?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    disconnect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    delete?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    connect?: SocialAmenityWhereUniqueInput | SocialAmenityWhereUniqueInput[]
    update?: SocialAmenityUpdateWithWhereUniqueWithoutSiteInput | SocialAmenityUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SocialAmenityUpdateManyWithWhereWithoutSiteInput | SocialAmenityUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SocialAmenityScalarWhereInput | SocialAmenityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSiteInput | UserUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSiteInput | UserUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSiteInput | UserUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutSocialAmenitiesInput = {
    create?: XOR<SiteCreateWithoutSocialAmenitiesInput, SiteUncheckedCreateWithoutSocialAmenitiesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSocialAmenitiesInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutSocialAmenitiesNestedInput = {
    create?: XOR<SiteCreateWithoutSocialAmenitiesInput, SiteUncheckedCreateWithoutSocialAmenitiesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSocialAmenitiesInput
    upsert?: SiteUpsertWithoutSocialAmenitiesInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutSocialAmenitiesInput, SiteUpdateWithoutSocialAmenitiesInput>, SiteUncheckedUpdateWithoutSocialAmenitiesInput>
  }

  export type SiteCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAnnouncementsInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAnnouncementsInput
    upsert?: SiteUpsertWithoutAnnouncementsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutAnnouncementsInput, SiteUpdateWithoutAnnouncementsInput>, SiteUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SiteCreateNestedOneWithoutBlocksInput = {
    create?: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutBlocksInput
    connect?: SiteWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutBlocksInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBlocksInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SiteUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutBlocksInput
    upsert?: SiteUpsertWithoutBlocksInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutBlocksInput, SiteUpdateWithoutBlocksInput>, SiteUncheckedUpdateWithoutBlocksInput>
  }

  export type UserUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBlocksInput | UserUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBlocksInput | UserUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBlocksInput | UserUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBlocksInput | UserUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBlocksInput | UserUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBlocksInput | UserUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type company_employeesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type SiteCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type SiteUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type AdminUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCompanyInput | AdminUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCompanyInput | AdminUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCompanyInput | AdminUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type company_employeesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type SiteUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCompaniesInput | SiteUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCompaniesInput | SiteUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCompaniesInput | SiteUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput> | AdminCreateWithoutCompanyInput[] | AdminUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCompanyInput | AdminCreateOrConnectWithoutCompanyInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCompanyInput | AdminUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AdminCreateManyCompanyInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCompanyInput | AdminUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCompanyInput | AdminUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type SiteUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCompaniesInput | SiteUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCompaniesInput | SiteUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCompaniesInput | SiteUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutIndividualInput = {
    create?: XOR<AdminCreateWithoutIndividualInput, AdminUncheckedCreateWithoutIndividualInput>
    connectOrCreate?: AdminCreateOrConnectWithoutIndividualInput
    connect?: AdminWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutIndividualsInput = {
    create?: XOR<SiteCreateWithoutIndividualsInput, SiteUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutIndividualsInput
    connect?: SiteWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutIndividualNestedInput = {
    create?: XOR<AdminCreateWithoutIndividualInput, AdminUncheckedCreateWithoutIndividualInput>
    connectOrCreate?: AdminCreateOrConnectWithoutIndividualInput
    upsert?: AdminUpsertWithoutIndividualInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutIndividualInput, AdminUpdateWithoutIndividualInput>, AdminUncheckedUpdateWithoutIndividualInput>
  }

  export type SiteUpdateOneWithoutIndividualsNestedInput = {
    create?: XOR<SiteCreateWithoutIndividualsInput, SiteUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutIndividualsInput
    upsert?: SiteUpsertWithoutIndividualsInput
    disconnect?: SiteWhereInput | boolean
    delete?: SiteWhereInput | boolean
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutIndividualsInput, SiteUpdateWithoutIndividualsInput>, SiteUncheckedUpdateWithoutIndividualsInput>
  }

  export type AdminCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompany_employeesInput
    connect?: AdminWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
  }

  export type employee_site_accessCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompany_employeesInput
    upsert?: AdminUpsertWithoutCompany_employeesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCompany_employeesInput, AdminUpdateWithoutCompany_employeesInput>, AdminUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    upsert?: companiesUpsertWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_employeesInput, companiesUpdateWithoutCompany_employeesInput>, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutComplaintsInput
    connect?: SiteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type SiteUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutComplaintsInput
    upsert?: SiteUpsertWithoutComplaintsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutComplaintsInput, SiteUpdateWithoutComplaintsInput>, SiteUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    upsert?: UserUpsertWithoutComplaintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplaintsInput, UserUpdateWithoutComplaintsInput>, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type company_employeesCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: SiteCreateOrConnectWithoutEmployee_site_accessInput
    connect?: SiteWhereUniqueInput
  }

  export type company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: company_employeesUpsertWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput, company_employeesUpdateWithoutEmployee_site_accessInput>, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: SiteCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: SiteUpsertWithoutEmployee_site_accessInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutEmployee_site_accessInput, SiteUpdateWithoutEmployee_site_accessInput>, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type companiesCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type companiesUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    upsert?: companiesUpsertWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutInvitationsInput, companiesUpdateWithoutInvitationsInput>, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type EnumMasterRoleFieldUpdateOperationsInput = {
    set?: $Enums.MasterRole
  }

  export type AdminCreateNestedOneWithoutAdminComplaintsInput = {
    create?: XOR<AdminCreateWithoutAdminComplaintsInput, AdminUncheckedCreateWithoutAdminComplaintsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminComplaintsInput
    connect?: AdminWhereUniqueInput
  }

  export type NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AdminComplaintCategory | null
  }

  export type AdminUpdateOneRequiredWithoutAdminComplaintsNestedInput = {
    create?: XOR<AdminCreateWithoutAdminComplaintsInput, AdminUncheckedCreateWithoutAdminComplaintsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminComplaintsInput
    upsert?: AdminUpsertWithoutAdminComplaintsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAdminComplaintsInput, AdminUpdateWithoutAdminComplaintsInput>, AdminUncheckedUpdateWithoutAdminComplaintsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumMasterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterRole | EnumMasterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterRoleFilter<$PrismaModel> | $Enums.MasterRole
  }

  export type NestedEnumMasterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterRole | EnumMasterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterRole[] | ListEnumMasterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterRoleWithAggregatesFilter<$PrismaModel> | $Enums.MasterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasterRoleFilter<$PrismaModel>
    _max?: NestedEnumMasterRoleFilter<$PrismaModel>
  }

  export type NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminComplaintCategory | EnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel> | $Enums.AdminComplaintCategory | null
  }

  export type NestedEnumAdminComplaintCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminComplaintCategory | EnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdminComplaintCategory[] | ListEnumAdminComplaintCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdminComplaintCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdminComplaintCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumAdminComplaintCategoryNullableFilter<$PrismaModel>
  }

  export type complaintsCreateWithoutUsersInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    sites: SiteCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsCreateOrConnectWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput>
  }

  export type complaintsCreateManyUsersInputEnvelope = {
    data: complaintsCreateManyUsersInput | complaintsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutUsersInput = {
    block_name: string
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
    sites: SiteCreateNestedOneWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutUsersInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
  }

  export type blocksCreateOrConnectWithoutUsersInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
  }

  export type SiteCreateWithoutUsersInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutUsersInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutUsersInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
  }

  export type complaintsUpsertWithWhereUniqueWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutUsersInput, complaintsUncheckedUpdateWithoutUsersInput>
    create: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutUsersInput, complaintsUncheckedUpdateWithoutUsersInput>
  }

  export type complaintsUpdateManyWithWhereWithoutUsersInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutUsersInput>
  }

  export type complaintsScalarWhereInput = {
    AND?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    OR?: complaintsScalarWhereInput[]
    NOT?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    id?: IntFilter<"complaints"> | number
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
  }

  export type blocksUpsertWithoutUsersInput = {
    update: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    where?: blocksWhereInput
  }

  export type blocksUpdateToOneWithWhereWithoutUsersInput = {
    where?: blocksWhereInput
    data: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type blocksUpdateWithoutUsersInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    sites?: SiteUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SiteUpsertWithoutUsersInput = {
    update: XOR<SiteUpdateWithoutUsersInput, SiteUncheckedUpdateWithoutUsersInput>
    create: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutUsersInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutUsersInput, SiteUncheckedUpdateWithoutUsersInput>
  }

  export type SiteUpdateWithoutUsersInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type companiesCreateWithoutAdminsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
  }

  export type company_employeesCreateWithoutAdminsInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutAdminsInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
  }

  export type individualsCreateWithoutAdminInput = {
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    site?: SiteCreateNestedOneWithoutIndividualsInput
  }

  export type individualsUncheckedCreateWithoutAdminInput = {
    id?: number
    site_id?: number | null
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
  }

  export type individualsCreateOrConnectWithoutAdminInput = {
    where: individualsWhereUniqueInput
    create: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
  }

  export type SiteCreateWithoutAdminInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutAdminInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAdminInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput>
  }

  export type SiteCreateManyAdminInputEnvelope = {
    data: SiteCreateManyAdminInput | SiteCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminComplaintCreateWithoutAdminInput = {
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
  }

  export type AdminComplaintUncheckedCreateWithoutAdminInput = {
    id?: number
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
  }

  export type AdminComplaintCreateOrConnectWithoutAdminInput = {
    where: AdminComplaintWhereUniqueInput
    create: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput>
  }

  export type AdminComplaintCreateManyAdminInputEnvelope = {
    data: AdminComplaintCreateManyAdminInput | AdminComplaintCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithoutAdminsInput = {
    update: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutAdminsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
  }

  export type companiesUpdateWithoutAdminsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type company_employeesUpsertWithoutAdminsInput = {
    update: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutAdminsInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type company_employeesUpdateWithoutAdminsInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type individualsUpsertWithoutAdminInput = {
    update: XOR<individualsUpdateWithoutAdminInput, individualsUncheckedUpdateWithoutAdminInput>
    create: XOR<individualsCreateWithoutAdminInput, individualsUncheckedCreateWithoutAdminInput>
    where?: individualsWhereInput
  }

  export type individualsUpdateToOneWithWhereWithoutAdminInput = {
    where?: individualsWhereInput
    data: XOR<individualsUpdateWithoutAdminInput, individualsUncheckedUpdateWithoutAdminInput>
  }

  export type individualsUpdateWithoutAdminInput = {
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site?: SiteUpdateOneWithoutIndividualsNestedInput
  }

  export type individualsUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteUpsertWithWhereUniqueWithoutAdminInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutAdminInput, SiteUncheckedUpdateWithoutAdminInput>
    create: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutAdminInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutAdminInput, SiteUncheckedUpdateWithoutAdminInput>
  }

  export type SiteUpdateManyWithWhereWithoutAdminInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutAdminInput>
  }

  export type SiteScalarWhereInput = {
    AND?: SiteScalarWhereInput | SiteScalarWhereInput[]
    OR?: SiteScalarWhereInput[]
    NOT?: SiteScalarWhereInput | SiteScalarWhereInput[]
    id?: IntFilter<"Site"> | number
    site_id?: StringFilter<"Site"> | string
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
  }

  export type AdminComplaintUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminComplaintWhereUniqueInput
    update: XOR<AdminComplaintUpdateWithoutAdminInput, AdminComplaintUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminComplaintCreateWithoutAdminInput, AdminComplaintUncheckedCreateWithoutAdminInput>
  }

  export type AdminComplaintUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminComplaintWhereUniqueInput
    data: XOR<AdminComplaintUpdateWithoutAdminInput, AdminComplaintUncheckedUpdateWithoutAdminInput>
  }

  export type AdminComplaintUpdateManyWithWhereWithoutAdminInput = {
    where: AdminComplaintScalarWhereInput
    data: XOR<AdminComplaintUpdateManyMutationInput, AdminComplaintUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminComplaintScalarWhereInput = {
    AND?: AdminComplaintScalarWhereInput | AdminComplaintScalarWhereInput[]
    OR?: AdminComplaintScalarWhereInput[]
    NOT?: AdminComplaintScalarWhereInput | AdminComplaintScalarWhereInput[]
    id?: IntFilter<"AdminComplaint"> | number
    adminId?: IntFilter<"AdminComplaint"> | number
    accountType?: EnumAccountTypeFilter<"AdminComplaint"> | $Enums.AccountType
    title?: StringFilter<"AdminComplaint"> | string
    content?: StringFilter<"AdminComplaint"> | string
    category?: EnumAdminComplaintCategoryNullableFilter<"AdminComplaint"> | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFilter<"AdminComplaint"> | $Enums.Status
    created_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    updated_at?: DateTimeFilter<"AdminComplaint"> | Date | string
    master_note?: StringNullableFilter<"AdminComplaint"> | string | null
  }

  export type announcementsCreateWithoutSitesInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUncheckedCreateWithoutSitesInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsCreateOrConnectWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    create: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput>
  }

  export type announcementsCreateManySitesInputEnvelope = {
    data: announcementsCreateManySitesInput | announcementsCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutSitesInput = {
    block_name: string
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
    users?: UserCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutSitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
    users?: UserUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksCreateOrConnectWithoutSitesInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksCreateManySitesInputEnvelope = {
    data: blocksCreateManySitesInput | blocksCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type complaintsCreateWithoutSitesInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    users: UserCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateWithoutSitesInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsCreateOrConnectWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput>
  }

  export type complaintsCreateManySitesInputEnvelope = {
    data: complaintsCreateManySitesInput | complaintsCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type employee_site_accessCreateWithoutSitesInput = {
    granted_at?: Date | string
    deleted_at?: Date | string | null
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutSitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type employee_site_accessCreateOrConnectWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessCreateManySitesInputEnvelope = {
    data: employee_site_accessCreateManySitesInput | employee_site_accessCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type individualsCreateWithoutSiteInput = {
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admin: AdminCreateNestedOneWithoutIndividualInput
  }

  export type individualsUncheckedCreateWithoutSiteInput = {
    id?: number
    admin_id: number
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
  }

  export type individualsCreateOrConnectWithoutSiteInput = {
    where: individualsWhereUniqueInput
    create: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
  }

  export type AdminCreateWithoutSites_createdInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company?: companiesCreateNestedOneWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    individual?: individualsCreateNestedOneWithoutAdminInput
    adminComplaints?: AdminComplaintCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSites_createdInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    individual?: individualsUncheckedCreateNestedOneWithoutAdminInput
    adminComplaints?: AdminComplaintUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSites_createdInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
  }

  export type companiesCreateWithoutSitesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutSitesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutSitesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
  }

  export type SocialAmenityCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAmenityUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAmenityCreateOrConnectWithoutSiteInput = {
    where: SocialAmenityWhereUniqueInput
    create: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput>
  }

  export type SocialAmenityCreateManySiteInputEnvelope = {
    data: SocialAmenityCreateManySiteInput | SocialAmenityCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSiteInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSiteInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutSiteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput>
  }

  export type UserCreateManySiteInputEnvelope = {
    data: UserCreateManySiteInput | UserCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type announcementsUpsertWithWhereUniqueWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    update: XOR<announcementsUpdateWithoutSitesInput, announcementsUncheckedUpdateWithoutSitesInput>
    create: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput>
  }

  export type announcementsUpdateWithWhereUniqueWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    data: XOR<announcementsUpdateWithoutSitesInput, announcementsUncheckedUpdateWithoutSitesInput>
  }

  export type announcementsUpdateManyWithWhereWithoutSitesInput = {
    where: announcementsScalarWhereInput
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyWithoutSitesInput>
  }

  export type announcementsScalarWhereInput = {
    AND?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
    OR?: announcementsScalarWhereInput[]
    NOT?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
    id?: IntFilter<"announcements"> | number
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
  }

  export type blocksUpsertWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    update: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksUpdateWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    data: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
  }

  export type blocksUpdateManyWithWhereWithoutSitesInput = {
    where: blocksScalarWhereInput
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyWithoutSitesInput>
  }

  export type blocksScalarWhereInput = {
    AND?: blocksScalarWhereInput | blocksScalarWhereInput[]
    OR?: blocksScalarWhereInput[]
    NOT?: blocksScalarWhereInput | blocksScalarWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    block_number?: IntNullableFilter<"blocks"> | number | null
    deleted_at?: DateTimeNullableFilter<"blocks"> | Date | string | null
    updated_at?: DateTimeFilter<"blocks"> | Date | string
    apartment_count?: IntNullableFilter<"blocks"> | number | null
  }

  export type complaintsUpsertWithWhereUniqueWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutSitesInput, complaintsUncheckedUpdateWithoutSitesInput>
    create: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutSitesInput, complaintsUncheckedUpdateWithoutSitesInput>
  }

  export type complaintsUpdateManyWithWhereWithoutSitesInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutSitesInput>
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutSitesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutSitesInput>
  }

  export type employee_site_accessScalarWhereInput = {
    AND?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    OR?: employee_site_accessScalarWhereInput[]
    NOT?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    deleted_at?: DateTimeNullableFilter<"employee_site_access"> | Date | string | null
  }

  export type individualsUpsertWithoutSiteInput = {
    update: XOR<individualsUpdateWithoutSiteInput, individualsUncheckedUpdateWithoutSiteInput>
    create: XOR<individualsCreateWithoutSiteInput, individualsUncheckedCreateWithoutSiteInput>
    where?: individualsWhereInput
  }

  export type individualsUpdateToOneWithWhereWithoutSiteInput = {
    where?: individualsWhereInput
    data: XOR<individualsUpdateWithoutSiteInput, individualsUncheckedUpdateWithoutSiteInput>
  }

  export type individualsUpdateWithoutSiteInput = {
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutIndividualNestedInput
  }

  export type individualsUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUpsertWithoutSites_createdInput = {
    update: XOR<AdminUpdateWithoutSites_createdInput, AdminUncheckedUpdateWithoutSites_createdInput>
    create: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSites_createdInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSites_createdInput, AdminUncheckedUpdateWithoutSites_createdInput>
  }

  export type AdminUpdateWithoutSites_createdInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companiesUpdateOneWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    individual?: individualsUpdateOneWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSites_createdInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    individual?: individualsUncheckedUpdateOneWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type companiesUpsertWithoutSitesInput = {
    update: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutSitesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type companiesUpdateWithoutSitesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type SocialAmenityUpsertWithWhereUniqueWithoutSiteInput = {
    where: SocialAmenityWhereUniqueInput
    update: XOR<SocialAmenityUpdateWithoutSiteInput, SocialAmenityUncheckedUpdateWithoutSiteInput>
    create: XOR<SocialAmenityCreateWithoutSiteInput, SocialAmenityUncheckedCreateWithoutSiteInput>
  }

  export type SocialAmenityUpdateWithWhereUniqueWithoutSiteInput = {
    where: SocialAmenityWhereUniqueInput
    data: XOR<SocialAmenityUpdateWithoutSiteInput, SocialAmenityUncheckedUpdateWithoutSiteInput>
  }

  export type SocialAmenityUpdateManyWithWhereWithoutSiteInput = {
    where: SocialAmenityScalarWhereInput
    data: XOR<SocialAmenityUpdateManyMutationInput, SocialAmenityUncheckedUpdateManyWithoutSiteInput>
  }

  export type SocialAmenityScalarWhereInput = {
    AND?: SocialAmenityScalarWhereInput | SocialAmenityScalarWhereInput[]
    OR?: SocialAmenityScalarWhereInput[]
    NOT?: SocialAmenityScalarWhereInput | SocialAmenityScalarWhereInput[]
    id?: StringFilter<"SocialAmenity"> | string
    siteId?: IntFilter<"SocialAmenity"> | number
    name?: StringFilter<"SocialAmenity"> | string
    description?: StringNullableFilter<"SocialAmenity"> | string | null
    status?: StringFilter<"SocialAmenity"> | string
    hours?: StringNullableFilter<"SocialAmenity"> | string | null
    rules?: StringNullableFilter<"SocialAmenity"> | string | null
    extra?: StringNullableFilter<"SocialAmenity"> | string | null
    createdAt?: DateTimeFilter<"SocialAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAmenity"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutSiteInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSiteInput, UserUncheckedUpdateWithoutSiteInput>
    create: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSiteInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSiteInput, UserUncheckedUpdateWithoutSiteInput>
  }

  export type UserUpdateManyWithWhereWithoutSiteInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSiteInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type SiteCreateWithoutSocialAmenitiesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutSocialAmenitiesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutSocialAmenitiesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutSocialAmenitiesInput, SiteUncheckedCreateWithoutSocialAmenitiesInput>
  }

  export type SiteUpsertWithoutSocialAmenitiesInput = {
    update: XOR<SiteUpdateWithoutSocialAmenitiesInput, SiteUncheckedUpdateWithoutSocialAmenitiesInput>
    create: XOR<SiteCreateWithoutSocialAmenitiesInput, SiteUncheckedCreateWithoutSocialAmenitiesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutSocialAmenitiesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutSocialAmenitiesInput, SiteUncheckedUpdateWithoutSocialAmenitiesInput>
  }

  export type SiteUpdateWithoutSocialAmenitiesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutSocialAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutAnnouncementsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutAnnouncementsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAnnouncementsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
  }

  export type SiteUpsertWithoutAnnouncementsInput = {
    update: XOR<SiteUpdateWithoutAnnouncementsInput, SiteUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutAnnouncementsInput, SiteUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SiteUpdateWithoutAnnouncementsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutAnnouncementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutBlocksInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutBlocksInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutBlocksInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
  }

  export type UserCreateWithoutBlocksInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutBlocksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput>
  }

  export type UserCreateManyBlocksInputEnvelope = {
    data: UserCreateManyBlocksInput | UserCreateManyBlocksInput[]
    skipDuplicates?: boolean
  }

  export type SiteUpsertWithoutBlocksInput = {
    update: XOR<SiteUpdateWithoutBlocksInput, SiteUncheckedUpdateWithoutBlocksInput>
    create: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutBlocksInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutBlocksInput, SiteUncheckedUpdateWithoutBlocksInput>
  }

  export type SiteUpdateWithoutBlocksInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutBlocksInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBlocksInput, UserUncheckedUpdateWithoutBlocksInput>
    create: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBlocksInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBlocksInput, UserUncheckedUpdateWithoutBlocksInput>
  }

  export type UserUpdateManyWithWhereWithoutBlocksInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBlocksInput>
  }

  export type AdminCreateWithoutCompanyInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    individual?: individualsCreateNestedOneWithoutAdminInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCompanyInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    individual?: individualsUncheckedCreateNestedOneWithoutAdminInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput>
  }

  export type AdminCreateManyCompanyInputEnvelope = {
    data: AdminCreateManyCompanyInput | AdminCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type company_employeesCreateWithoutCompaniesInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesCreateManyCompaniesInputEnvelope = {
    data: company_employeesCreateManyCompaniesInput | company_employeesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type invitationsCreateWithoutCompaniesInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsCreateOrConnectWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsCreateManyCompaniesInputEnvelope = {
    data: invitationsCreateManyCompaniesInput | invitationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type SiteCreateWithoutCompaniesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput>
  }

  export type SiteCreateManyCompaniesInputEnvelope = {
    data: SiteCreateManyCompaniesInput | SiteCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCompanyInput, AdminUncheckedUpdateWithoutCompanyInput>
    create: XOR<AdminCreateWithoutCompanyInput, AdminUncheckedCreateWithoutCompanyInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCompanyInput, AdminUncheckedUpdateWithoutCompanyInput>
  }

  export type AdminUpdateManyWithWhereWithoutCompanyInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: IntFilter<"Admin"> | number
    full_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    account_type?: EnumAccountTypeFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableFilter<"Admin"> | string | null
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    verificationToken?: StringNullableFilter<"Admin"> | string | null
    is_verified?: BoolFilter<"Admin"> | boolean
    resetToken?: StringNullableFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    company_code?: StringNullableFilter<"Admin"> | string | null
    companyId?: IntNullableFilter<"Admin"> | number | null
    individualId?: IntNullableFilter<"Admin"> | number | null
  }

  export type company_employeesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    update: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    data: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_employeesUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_employeesScalarWhereInput
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_employeesScalarWhereInput = {
    AND?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    OR?: company_employeesScalarWhereInput[]
    NOT?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"company_employees"> | Date | string | null
  }

  export type invitationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    update: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    data: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type invitationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: invitationsScalarWhereInput
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type invitationsScalarWhereInput = {
    AND?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    OR?: invitationsScalarWhereInput[]
    NOT?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
  }

  export type SiteUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutCompaniesInput, SiteUncheckedUpdateWithoutCompaniesInput>
    create: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutCompaniesInput, SiteUncheckedUpdateWithoutCompaniesInput>
  }

  export type SiteUpdateManyWithWhereWithoutCompaniesInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type AdminCreateWithoutIndividualInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company?: companiesCreateNestedOneWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutIndividualInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutIndividualInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutIndividualInput, AdminUncheckedCreateWithoutIndividualInput>
  }

  export type SiteCreateWithoutIndividualsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutIndividualsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutIndividualsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutIndividualsInput, SiteUncheckedCreateWithoutIndividualsInput>
  }

  export type AdminUpsertWithoutIndividualInput = {
    update: XOR<AdminUpdateWithoutIndividualInput, AdminUncheckedUpdateWithoutIndividualInput>
    create: XOR<AdminCreateWithoutIndividualInput, AdminUncheckedCreateWithoutIndividualInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutIndividualInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutIndividualInput, AdminUncheckedUpdateWithoutIndividualInput>
  }

  export type AdminUpdateWithoutIndividualInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companiesUpdateOneWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutIndividualInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type SiteUpsertWithoutIndividualsInput = {
    update: XOR<SiteUpdateWithoutIndividualsInput, SiteUncheckedUpdateWithoutIndividualsInput>
    create: XOR<SiteCreateWithoutIndividualsInput, SiteUncheckedCreateWithoutIndividualsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutIndividualsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutIndividualsInput, SiteUncheckedUpdateWithoutIndividualsInput>
  }

  export type SiteUpdateWithoutIndividualsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutIndividualsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type AdminCreateWithoutCompany_employeesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company?: companiesCreateNestedOneWithoutAdminsInput
    individual?: individualsCreateNestedOneWithoutAdminInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
    individual?: individualsUncheckedCreateNestedOneWithoutAdminInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
    adminComplaints?: AdminComplaintUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCompany_employeesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
  }

  export type companiesCreateWithoutCompany_employeesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminCreateNestedManyWithoutCompanyInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_employeesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateWithoutCompany_employeesInput = {
    granted_at?: Date | string
    deleted_at?: Date | string | null
    sites: SiteCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type employee_site_accessCreateOrConnectWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateManyCompany_employeesInputEnvelope = {
    data: employee_site_accessCreateManyCompany_employeesInput | employee_site_accessCreateManyCompany_employeesInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCompany_employeesInput = {
    update: XOR<AdminUpdateWithoutCompany_employeesInput, AdminUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCompany_employeesInput, AdminUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type AdminUpdateWithoutCompany_employeesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companiesUpdateOneWithoutAdminsNestedInput
    individual?: individualsUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    individual?: individualsUncheckedUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type companiesUpsertWithoutCompany_employeesInput = {
    update: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateWithoutCompany_employeesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutCompanyNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput>
  }

  export type SiteCreateWithoutComplaintsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutComplaintsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutComplaintsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutComplaintsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutComplaintsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
  }

  export type SiteUpsertWithoutComplaintsInput = {
    update: XOR<SiteUpdateWithoutComplaintsInput, SiteUncheckedUpdateWithoutComplaintsInput>
    create: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutComplaintsInput, SiteUncheckedUpdateWithoutComplaintsInput>
  }

  export type SiteUpdateWithoutComplaintsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type UserUpsertWithoutComplaintsInput = {
    update: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateWithoutComplaintsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type company_employeesCreateWithoutEmployee_site_accessInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
  }

  export type company_employeesCreateOrConnectWithoutEmployee_site_accessInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type SiteCreateWithoutEmployee_site_accessInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    individuals?: individualsCreateNestedOneWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    socialAmenities?: SocialAmenityCreateNestedManyWithoutSiteInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    individuals?: individualsUncheckedCreateNestedOneWithoutSiteInput
    socialAmenities?: SocialAmenityUncheckedCreateNestedManyWithoutSiteInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutEmployee_site_accessInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpsertWithoutEmployee_site_accessInput = {
    update: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpdateWithoutEmployee_site_accessInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteUpsertWithoutEmployee_site_accessInput = {
    update: XOR<SiteUpdateWithoutEmployee_site_accessInput, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutEmployee_site_accessInput, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type SiteUpdateWithoutEmployee_site_accessInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type companiesCreateWithoutInvitationsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutInvitationsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    expiry_date?: Date | string | null
    admins?: AdminUncheckedCreateNestedManyWithoutCompanyInput
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutInvitationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
  }

  export type companiesUpsertWithoutInvitationsInput = {
    update: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type companiesUpdateWithoutInvitationsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUncheckedUpdateManyWithoutCompanyNestedInput
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AdminCreateWithoutAdminComplaintsInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
    company?: companiesCreateNestedOneWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    individual?: individualsCreateNestedOneWithoutAdminInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAdminComplaintsInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    companyId?: number | null
    individualId?: number | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    individual?: individualsUncheckedCreateNestedOneWithoutAdminInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAdminComplaintsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminComplaintsInput, AdminUncheckedCreateWithoutAdminComplaintsInput>
  }

  export type AdminUpsertWithoutAdminComplaintsInput = {
    update: XOR<AdminUpdateWithoutAdminComplaintsInput, AdminUncheckedUpdateWithoutAdminComplaintsInput>
    create: XOR<AdminCreateWithoutAdminComplaintsInput, AdminUncheckedCreateWithoutAdminComplaintsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAdminComplaintsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAdminComplaintsInput, AdminUncheckedUpdateWithoutAdminComplaintsInput>
  }

  export type AdminUpdateWithoutAdminComplaintsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companiesUpdateOneWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    individual?: individualsUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAdminComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    individual?: individualsUncheckedUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type complaintsCreateManyUsersInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type paymentsCreateManyUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type complaintsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sites?: SiteUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type paymentsUpdateWithoutUsersInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type SiteCreateManyAdminInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type AdminComplaintCreateManyAdminInput = {
    id?: number
    accountType: $Enums.AccountType
    title: string
    content: string
    category?: $Enums.AdminComplaintCategory | null
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    master_note?: string | null
  }

  export type SiteUpdateWithoutAdminInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type AdminComplaintUpdateWithoutAdminInput = {
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminComplaintUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminComplaintUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumAdminComplaintCategoryFieldUpdateOperationsInput | $Enums.AdminComplaintCategory | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    master_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type announcementsCreateManySitesInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type blocksCreateManySitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
    block_number?: number | null
    deleted_at?: Date | string | null
    updated_at?: Date | string
    apartment_count?: number | null
  }

  export type complaintsCreateManySitesInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type employee_site_accessCreateManySitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type SocialAmenityCreateManySiteInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManySiteInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
  }

  export type announcementsUpdateWithoutSitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksUpdateWithoutSitesInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    block_number?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type complaintsUpdateWithoutSitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    users?: UserUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type employee_site_accessUpdateWithoutSitesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialAmenityUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAmenityUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAmenityUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSiteInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
  }

  export type UserUpdateWithoutBlocksInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateManyCompanyInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_code?: string | null
    individualId?: number | null
  }

  export type company_employeesCreateManyCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
  }

  export type invitationsCreateManyCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type SiteCreateManyCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type AdminUpdateWithoutCompanyInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    individual?: individualsUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    individual?: individualsUncheckedUpdateOneWithoutAdminNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
    adminComplaints?: AdminComplaintUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_code?: NullableStringFieldUpdateOperationsInput | string | null
    individualId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type company_employeesUpdateWithoutCompaniesInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invitationsUpdateWithoutCompaniesInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUpdateWithoutCompaniesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    individuals?: individualsUpdateOneWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    socialAmenities?: SocialAmenityUpdateManyWithoutSiteNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    individuals?: individualsUncheckedUpdateOneWithoutSiteNestedInput
    socialAmenities?: SocialAmenityUncheckedUpdateManyWithoutSiteNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type employee_site_accessCreateManyCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type employee_site_accessUpdateWithoutCompany_employeesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sites?: SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}