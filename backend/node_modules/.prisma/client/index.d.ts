
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admins
 * 
 */
export type admins = $Result.DefaultSelection<Prisma.$adminsPayload>
/**
 * Model announcements
 * 
 */
export type announcements = $Result.DefaultSelection<Prisma.$announcementsPayload>
/**
 * Model blocks
 * 
 */
export type blocks = $Result.DefaultSelection<Prisma.$blocksPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model company_employees
 * 
 */
export type company_employees = $Result.DefaultSelection<Prisma.$company_employeesPayload>
/**
 * Model complaints
 * 
 */
export type complaints = $Result.DefaultSelection<Prisma.$complaintsPayload>
/**
 * Model employee_site_access
 * 
 */
export type employee_site_access = $Result.DefaultSelection<Prisma.$employee_site_accessPayload>
/**
 * Model invitations
 * 
 */
export type invitations = $Result.DefaultSelection<Prisma.$invitationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model sites
 * 
 */
export type sites = $Result.DefaultSelection<Prisma.$sitesPayload>
/**
 * Model social_amenities
 * 
 */
export type social_amenities = $Result.DefaultSelection<Prisma.$social_amenitiesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const AccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  MASTER_ADMIN: 'MASTER_ADMIN',
  COMPANY_MANAGER: 'COMPANY_MANAGER',
  COMPANY_EMPLOYEE: 'COMPANY_EMPLOYEE',
  SITE_USER: 'SITE_USER'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const Category: {
  MAINTENANCE: 'MAINTENANCE',
  COMPLAINT: 'COMPLAINT',
  REQUEST: 'REQUEST',
  OTHER: 'OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ResidentType: {
  OWNER: 'OWNER',
  HIRER: 'HIRER'
};

export type ResidentType = (typeof ResidentType)[keyof typeof ResidentType]


export const Status: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type Status = (typeof Status)[keyof typeof Status]

}

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ResidentType = $Enums.ResidentType

export const ResidentType: typeof $Enums.ResidentType

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admins.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admins.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admins`: Exposes CRUD operations for the **admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.adminsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcements`: Exposes CRUD operations for the **announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.announcementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_employees`: Exposes CRUD operations for the **company_employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_employees
    * const company_employees = await prisma.company_employees.findMany()
    * ```
    */
  get company_employees(): Prisma.company_employeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaints`: Exposes CRUD operations for the **complaints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaints.findMany()
    * ```
    */
  get complaints(): Prisma.complaintsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee_site_access`: Exposes CRUD operations for the **employee_site_access** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_site_accesses
    * const employee_site_accesses = await prisma.employee_site_access.findMany()
    * ```
    */
  get employee_site_access(): Prisma.employee_site_accessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitations`: Exposes CRUD operations for the **invitations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitations.findMany()
    * ```
    */
  get invitations(): Prisma.invitationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sites`: Exposes CRUD operations for the **sites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.sites.findMany()
    * ```
    */
  get sites(): Prisma.sitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.social_amenities`: Exposes CRUD operations for the **social_amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Social_amenities
    * const social_amenities = await prisma.social_amenities.findMany()
    * ```
    */
  get social_amenities(): Prisma.social_amenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admins: 'admins',
    announcements: 'announcements',
    blocks: 'blocks',
    companies: 'companies',
    company_employees: 'company_employees',
    complaints: 'complaints',
    employee_site_access: 'employee_site_access',
    invitations: 'invitations',
    payments: 'payments',
    sites: 'sites',
    social_amenities: 'social_amenities',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admins" | "announcements" | "blocks" | "companies" | "company_employees" | "complaints" | "employee_site_access" | "invitations" | "payments" | "sites" | "social_amenities" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admins: {
        payload: Prisma.$adminsPayload<ExtArgs>
        fields: Prisma.adminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          findFirst: {
            args: Prisma.adminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          findMany: {
            args: Prisma.adminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[]
          }
          create: {
            args: Prisma.adminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          createMany: {
            args: Prisma.adminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[]
          }
          delete: {
            args: Prisma.adminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          update: {
            args: Prisma.adminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          deleteMany: {
            args: Prisma.adminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[]
          }
          upsert: {
            args: Prisma.adminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmins>
          }
          groupBy: {
            args: Prisma.adminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminsCountArgs<ExtArgs>
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number
          }
        }
      }
      announcements: {
        payload: Prisma.$announcementsPayload<ExtArgs>
        fields: Prisma.announcementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.announcementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.announcementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findFirst: {
            args: Prisma.announcementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.announcementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findMany: {
            args: Prisma.announcementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          create: {
            args: Prisma.announcementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          createMany: {
            args: Prisma.announcementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.announcementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          delete: {
            args: Prisma.announcementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          update: {
            args: Prisma.announcementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          deleteMany: {
            args: Prisma.announcementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.announcementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.announcementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          upsert: {
            args: Prisma.announcementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.announcementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.announcementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      blocks: {
        payload: Prisma.$blocksPayload<ExtArgs>
        fields: Prisma.blocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blocksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blocksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findFirst: {
            args: Prisma.blocksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blocksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findMany: {
            args: Prisma.blocksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          create: {
            args: Prisma.blocksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          createMany: {
            args: Prisma.blocksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blocksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          delete: {
            args: Prisma.blocksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          update: {
            args: Prisma.blocksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          deleteMany: {
            args: Prisma.blocksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blocksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blocksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          upsert: {
            args: Prisma.blocksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.blocksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.blocksCountArgs<ExtArgs>
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      company_employees: {
        payload: Prisma.$company_employeesPayload<ExtArgs>
        fields: Prisma.company_employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findFirst: {
            args: Prisma.company_employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findMany: {
            args: Prisma.company_employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          create: {
            args: Prisma.company_employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          createMany: {
            args: Prisma.company_employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_employeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          delete: {
            args: Prisma.company_employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          update: {
            args: Prisma.company_employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          deleteMany: {
            args: Prisma.company_employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_employeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          upsert: {
            args: Prisma.company_employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          aggregate: {
            args: Prisma.Company_employeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_employees>
          }
          groupBy: {
            args: Prisma.company_employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_employeesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesCountAggregateOutputType> | number
          }
        }
      }
      complaints: {
        payload: Prisma.$complaintsPayload<ExtArgs>
        fields: Prisma.complaintsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.complaintsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.complaintsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findFirst: {
            args: Prisma.complaintsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.complaintsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findMany: {
            args: Prisma.complaintsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          create: {
            args: Prisma.complaintsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          createMany: {
            args: Prisma.complaintsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.complaintsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          delete: {
            args: Prisma.complaintsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          update: {
            args: Prisma.complaintsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          deleteMany: {
            args: Prisma.complaintsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.complaintsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.complaintsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          upsert: {
            args: Prisma.complaintsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          aggregate: {
            args: Prisma.ComplaintsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaints>
          }
          groupBy: {
            args: Prisma.complaintsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsGroupByOutputType>[]
          }
          count: {
            args: Prisma.complaintsCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsCountAggregateOutputType> | number
          }
        }
      }
      employee_site_access: {
        payload: Prisma.$employee_site_accessPayload<ExtArgs>
        fields: Prisma.employee_site_accessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employee_site_accessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employee_site_accessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findFirst: {
            args: Prisma.employee_site_accessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employee_site_accessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findMany: {
            args: Prisma.employee_site_accessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          create: {
            args: Prisma.employee_site_accessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          createMany: {
            args: Prisma.employee_site_accessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employee_site_accessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          delete: {
            args: Prisma.employee_site_accessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          update: {
            args: Prisma.employee_site_accessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          deleteMany: {
            args: Prisma.employee_site_accessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employee_site_accessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employee_site_accessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          upsert: {
            args: Prisma.employee_site_accessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          aggregate: {
            args: Prisma.Employee_site_accessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_site_access>
          }
          groupBy: {
            args: Prisma.employee_site_accessGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessGroupByOutputType>[]
          }
          count: {
            args: Prisma.employee_site_accessCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessCountAggregateOutputType> | number
          }
        }
      }
      invitations: {
        payload: Prisma.$invitationsPayload<ExtArgs>
        fields: Prisma.invitationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invitationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invitationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findFirst: {
            args: Prisma.invitationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invitationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findMany: {
            args: Prisma.invitationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          create: {
            args: Prisma.invitationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          createMany: {
            args: Prisma.invitationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invitationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          delete: {
            args: Prisma.invitationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          update: {
            args: Prisma.invitationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          deleteMany: {
            args: Prisma.invitationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invitationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invitationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          upsert: {
            args: Prisma.invitationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          aggregate: {
            args: Prisma.InvitationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitations>
          }
          groupBy: {
            args: Prisma.invitationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invitationsCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      sites: {
        payload: Prisma.$sitesPayload<ExtArgs>
        fields: Prisma.sitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          findFirst: {
            args: Prisma.sitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          findMany: {
            args: Prisma.sitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          create: {
            args: Prisma.sitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          createMany: {
            args: Prisma.sitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          delete: {
            args: Prisma.sitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          update: {
            args: Prisma.sitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          deleteMany: {
            args: Prisma.sitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sitesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          upsert: {
            args: Prisma.sitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          aggregate: {
            args: Prisma.SitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSites>
          }
          groupBy: {
            args: Prisma.sitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.sitesCountArgs<ExtArgs>
            result: $Utils.Optional<SitesCountAggregateOutputType> | number
          }
        }
      }
      social_amenities: {
        payload: Prisma.$social_amenitiesPayload<ExtArgs>
        fields: Prisma.social_amenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.social_amenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.social_amenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          findFirst: {
            args: Prisma.social_amenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.social_amenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          findMany: {
            args: Prisma.social_amenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          create: {
            args: Prisma.social_amenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          createMany: {
            args: Prisma.social_amenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.social_amenitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          delete: {
            args: Prisma.social_amenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          update: {
            args: Prisma.social_amenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          deleteMany: {
            args: Prisma.social_amenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.social_amenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.social_amenitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          upsert: {
            args: Prisma.social_amenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          aggregate: {
            args: Prisma.Social_amenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocial_amenities>
          }
          groupBy: {
            args: Prisma.social_amenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Social_amenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.social_amenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Social_amenitiesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admins?: adminsOmit
    announcements?: announcementsOmit
    blocks?: blocksOmit
    companies?: companiesOmit
    company_employees?: company_employeesOmit
    complaints?: complaintsOmit
    employee_site_access?: employee_site_accessOmit
    invitations?: invitationsOmit
    payments?: paymentsOmit
    sites?: sitesOmit
    social_amenities?: social_amenitiesOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminsCountOutputType
   */

  export type AdminsCountOutputType = {
    companies: number
    sites: number
  }

  export type AdminsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | AdminsCountOutputTypeCountCompaniesArgs
    sites?: boolean | AdminsCountOutputTypeCountSitesArgs
  }

  // Custom InputTypes
  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminsCountOutputType
     */
    select?: AdminsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
  }

  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sitesWhereInput
  }


  /**
   * Count Type BlocksCountOutputType
   */

  export type BlocksCountOutputType = {
    users: number
  }

  export type BlocksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BlocksCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocksCountOutputType
     */
    select?: BlocksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    company_employees: number
    invitations: number
    sites: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | CompaniesCountOutputTypeCountCompany_employeesArgs
    invitations?: boolean | CompaniesCountOutputTypeCountInvitationsArgs
    sites?: boolean | CompaniesCountOutputTypeCountSitesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sitesWhereInput
  }


  /**
   * Count Type Company_employeesCountOutputType
   */

  export type Company_employeesCountOutputType = {
    employee_site_access: number
  }

  export type Company_employeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_site_access?: boolean | Company_employeesCountOutputTypeCountEmployee_site_accessArgs
  }

  // Custom InputTypes
  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company_employeesCountOutputType
     */
    select?: Company_employeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }


  /**
   * Count Type SitesCountOutputType
   */

  export type SitesCountOutputType = {
    announcements: number
    blocks: number
    complaints: number
    employee_site_access: number
    social_amenities: number
    users: number
  }

  export type SitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | SitesCountOutputTypeCountAnnouncementsArgs
    blocks?: boolean | SitesCountOutputTypeCountBlocksArgs
    complaints?: boolean | SitesCountOutputTypeCountComplaintsArgs
    employee_site_access?: boolean | SitesCountOutputTypeCountEmployee_site_accessArgs
    social_amenities?: boolean | SitesCountOutputTypeCountSocial_amenitiesArgs
    users?: boolean | SitesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitesCountOutputType
     */
    select?: SitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountSocial_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_amenitiesWhereInput
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    complaints: number
    payments: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | UsersCountOutputTypeCountComplaintsArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminsSumAggregateOutputType = {
    id: number | null
  }

  export type AdminsMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
  }

  export type AdminsMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
  }

  export type AdminsCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password: number
    account_type: number
    company_name: number
    created_at: number
    updated_at: number
    tokenExpiry: number
    verificationToken: number
    is_verified: number
    resetToken: number
    resetTokenExpiry: number
    account_status: number
    deleted_at: number
    last_login: number
    _all: number
  }


  export type AdminsAvgAggregateInputType = {
    id?: true
  }

  export type AdminsSumAggregateInputType = {
    id?: true
  }

  export type AdminsMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
  }

  export type AdminsMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
  }

  export type AdminsCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    _all?: true
  }

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to aggregate.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }




  export type adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminsWhereInput
    orderBy?: adminsOrderByWithAggregationInput | adminsOrderByWithAggregationInput[]
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum
    having?: adminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _avg?: AdminsAvgAggregateInputType
    _sum?: AdminsSumAggregateInputType
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }

  export type AdminsGroupByOutputType = {
    id: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name: string | null
    created_at: Date
    updated_at: Date
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    _count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends adminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      >
    >


  export type adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    companies?: boolean | admins$companiesArgs<ExtArgs>
    company_employees?: boolean | admins$company_employeesArgs<ExtArgs>
    sites?: boolean | admins$sitesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admins"]>

  export type adminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }, ExtArgs["result"]["admins"]>

  export type adminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }, ExtArgs["result"]["admins"]>

  export type adminsSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }

  export type adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password" | "account_type" | "company_name" | "created_at" | "updated_at" | "tokenExpiry" | "verificationToken" | "is_verified" | "resetToken" | "resetTokenExpiry" | "account_status" | "deleted_at" | "last_login", ExtArgs["result"]["admins"]>
  export type adminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | admins$companiesArgs<ExtArgs>
    company_employees?: boolean | admins$company_employeesArgs<ExtArgs>
    sites?: boolean | admins$sitesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type adminsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type adminsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admins"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>[]
      company_employees: Prisma.$company_employeesPayload<ExtArgs> | null
      sites: Prisma.$sitesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      password: string
      account_type: $Enums.AccountType
      company_name: string | null
      created_at: Date
      updated_at: Date
      tokenExpiry: Date | null
      verificationToken: string | null
      is_verified: boolean
      resetToken: string | null
      resetTokenExpiry: Date | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
    }, ExtArgs["result"]["admins"]>
    composites: {}
  }

  type adminsGetPayload<S extends boolean | null | undefined | adminsDefaultArgs> = $Result.GetResult<Prisma.$adminsPayload, S>

  type adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminsCountAggregateInputType | true
    }

  export interface adminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admins'], meta: { name: 'admins' } }
    /**
     * Find zero or one Admins that matches the filter.
     * @param {adminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminsFindUniqueArgs>(args: SelectSubset<T, adminsFindUniqueArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminsFindUniqueOrThrowArgs>(args: SelectSubset<T, adminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminsFindFirstArgs>(args?: SelectSubset<T, adminsFindFirstArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminsFindFirstOrThrowArgs>(args?: SelectSubset<T, adminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminsFindManyArgs>(args?: SelectSubset<T, adminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admins.
     * @param {adminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
     */
    create<T extends adminsCreateArgs>(args: SelectSubset<T, adminsCreateArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminsCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminsCreateManyArgs>(args?: SelectSubset<T, adminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminsCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminsCreateManyAndReturnArgs>(args?: SelectSubset<T, adminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admins.
     * @param {adminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
     */
    delete<T extends adminsDeleteArgs>(args: SelectSubset<T, adminsDeleteArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admins.
     * @param {adminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminsUpdateArgs>(args: SelectSubset<T, adminsUpdateArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminsDeleteManyArgs>(args?: SelectSubset<T, adminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminsUpdateManyArgs>(args: SelectSubset<T, adminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminsUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminsUpdateManyAndReturnArgs>(args: SelectSubset<T, adminsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admins.
     * @param {adminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
     */
    upsert<T extends adminsUpsertArgs>(args: SelectSubset<T, adminsUpsertArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminsCountArgs>(
      args?: Subset<T, adminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): Prisma.PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminsGroupByArgs['orderBy'] }
        : { orderBy?: adminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admins model
   */
  readonly fields: adminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends admins$companiesArgs<ExtArgs> = {}>(args?: Subset<T, admins$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_employees<T extends admins$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, admins$company_employeesArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sites<T extends admins$sitesArgs<ExtArgs> = {}>(args?: Subset<T, admins$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admins model
   */
  interface adminsFieldRefs {
    readonly id: FieldRef<"admins", 'Int'>
    readonly full_name: FieldRef<"admins", 'String'>
    readonly email: FieldRef<"admins", 'String'>
    readonly password: FieldRef<"admins", 'String'>
    readonly account_type: FieldRef<"admins", 'AccountType'>
    readonly company_name: FieldRef<"admins", 'String'>
    readonly created_at: FieldRef<"admins", 'DateTime'>
    readonly updated_at: FieldRef<"admins", 'DateTime'>
    readonly tokenExpiry: FieldRef<"admins", 'DateTime'>
    readonly verificationToken: FieldRef<"admins", 'String'>
    readonly is_verified: FieldRef<"admins", 'Boolean'>
    readonly resetToken: FieldRef<"admins", 'String'>
    readonly resetTokenExpiry: FieldRef<"admins", 'DateTime'>
    readonly account_status: FieldRef<"admins", 'AccountStatus'>
    readonly deleted_at: FieldRef<"admins", 'DateTime'>
    readonly last_login: FieldRef<"admins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admins findUnique
   */
  export type adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins findUniqueOrThrow
   */
  export type adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins findFirst
   */
  export type adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins findFirstOrThrow
   */
  export type adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins findMany
   */
  export type adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins create
   */
  export type adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * The data needed to create a admins.
     */
    data: XOR<adminsCreateInput, adminsUncheckedCreateInput>
  }

  /**
   * admins createMany
   */
  export type adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminsCreateManyInput | adminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admins createManyAndReturn
   */
  export type adminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminsCreateManyInput | adminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admins update
   */
  export type adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * The data needed to update a admins.
     */
    data: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>
    /**
     * Choose, which admins to update.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins updateMany
   */
  export type adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminsUpdateManyMutationInput, adminsUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminsWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admins updateManyAndReturn
   */
  export type adminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminsUpdateManyMutationInput, adminsUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminsWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admins upsert
   */
  export type adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * The filter to search for the admins to update in case it exists.
     */
    where: adminsWhereUniqueInput
    /**
     * In case the admins found by the `where` argument doesn't exist, create a new admins with this data.
     */
    create: XOR<adminsCreateInput, adminsUncheckedCreateInput>
    /**
     * In case the admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>
  }

  /**
   * admins delete
   */
  export type adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    /**
     * Filter which admins to delete.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins deleteMany
   */
  export type adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminsWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admins.companies
   */
  export type admins$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    cursor?: companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * admins.company_employees
   */
  export type admins$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
  }

  /**
   * admins.sites
   */
  export type admins$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    where?: sitesWhereInput
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    cursor?: sitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * admins without action
   */
  export type adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
  }


  /**
   * Model announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _avg: AnnouncementsAvgAggregateOutputType | null
    _sum: AnnouncementsSumAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementsSumAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    created_at: number
    updated_at: number
    siteId: number
    start_date: number
    end_date: number
    _all: number
  }


  export type AnnouncementsAvgAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementsSumAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to aggregate.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type announcementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithAggregationInput | announcementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: announcementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _avg?: AnnouncementsAvgAggregateInputType
    _sum?: AnnouncementsSumAggregateInputType
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: number
    title: string
    content: string
    created_at: Date
    updated_at: Date
    siteId: number
    start_date: Date
    end_date: Date
    _count: AnnouncementsCountAggregateOutputType | null
    _avg: AnnouncementsAvgAggregateOutputType | null
    _sum: AnnouncementsSumAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends announcementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type announcementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
  }

  export type announcementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "created_at" | "updated_at" | "siteId" | "start_date" | "end_date", ExtArgs["result"]["announcements"]>
  export type announcementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type announcementsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type announcementsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }

  export type $announcementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "announcements"
    objects: {
      sites: Prisma.$sitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      created_at: Date
      updated_at: Date
      siteId: number
      start_date: Date
      end_date: Date
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type announcementsGetPayload<S extends boolean | null | undefined | announcementsDefaultArgs> = $Result.GetResult<Prisma.$announcementsPayload, S>

  type announcementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<announcementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface announcementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['announcements'], meta: { name: 'announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {announcementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends announcementsFindUniqueArgs>(args: SelectSubset<T, announcementsFindUniqueArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {announcementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends announcementsFindUniqueOrThrowArgs>(args: SelectSubset<T, announcementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends announcementsFindFirstArgs>(args?: SelectSubset<T, announcementsFindFirstArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends announcementsFindFirstOrThrowArgs>(args?: SelectSubset<T, announcementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends announcementsFindManyArgs>(args?: SelectSubset<T, announcementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {announcementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends announcementsCreateArgs>(args: SelectSubset<T, announcementsCreateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {announcementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends announcementsCreateManyArgs>(args?: SelectSubset<T, announcementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {announcementsCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends announcementsCreateManyAndReturnArgs>(args?: SelectSubset<T, announcementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcements.
     * @param {announcementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends announcementsDeleteArgs>(args: SelectSubset<T, announcementsDeleteArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {announcementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends announcementsUpdateArgs>(args: SelectSubset<T, announcementsUpdateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {announcementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends announcementsDeleteManyArgs>(args?: SelectSubset<T, announcementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends announcementsUpdateManyArgs>(args: SelectSubset<T, announcementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {announcementsUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends announcementsUpdateManyAndReturnArgs>(args: SelectSubset<T, announcementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcements.
     * @param {announcementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends announcementsUpsertArgs>(args: SelectSubset<T, announcementsUpsertArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementsCountArgs>(
      args?: Subset<T, announcementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends announcementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: announcementsGroupByArgs['orderBy'] }
        : { orderBy?: announcementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, announcementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the announcements model
   */
  readonly fields: announcementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__announcementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the announcements model
   */
  interface announcementsFieldRefs {
    readonly id: FieldRef<"announcements", 'Int'>
    readonly title: FieldRef<"announcements", 'String'>
    readonly content: FieldRef<"announcements", 'String'>
    readonly created_at: FieldRef<"announcements", 'DateTime'>
    readonly updated_at: FieldRef<"announcements", 'DateTime'>
    readonly siteId: FieldRef<"announcements", 'Int'>
    readonly start_date: FieldRef<"announcements", 'DateTime'>
    readonly end_date: FieldRef<"announcements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * announcements findUnique
   */
  export type announcementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findUniqueOrThrow
   */
  export type announcementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findFirst
   */
  export type announcementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findFirstOrThrow
   */
  export type announcementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findMany
   */
  export type announcementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements create
   */
  export type announcementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The data needed to create a announcements.
     */
    data: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
  }

  /**
   * announcements createMany
   */
  export type announcementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements createManyAndReturn
   */
  export type announcementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * announcements update
   */
  export type announcementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The data needed to update a announcements.
     */
    data: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
    /**
     * Choose, which announcements to update.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements updateMany
   */
  export type announcementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements updateManyAndReturn
   */
  export type announcementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * announcements upsert
   */
  export type announcementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * The filter to search for the announcements to update in case it exists.
     */
    where: announcementsWhereUniqueInput
    /**
     * In case the announcements found by the `where` argument doesn't exist, create a new announcements with this data.
     */
    create: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
    /**
     * In case the announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
  }

  /**
   * announcements delete
   */
  export type announcementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    /**
     * Filter which announcements to delete.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements deleteMany
   */
  export type announcementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to delete
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to delete.
     */
    limit?: number
  }

  /**
   * announcements without action
   */
  export type announcementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
  }


  /**
   * Model blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    id: number | null
    site_id: number | null
  }

  export type BlocksSumAggregateOutputType = {
    id: number | null
    site_id: number | null
  }

  export type BlocksMinAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
  }

  export type BlocksMaxAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
  }

  export type BlocksCountAggregateOutputType = {
    id: number
    block_name: number
    site_id: number
    created_at: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    id?: true
    site_id?: true
  }

  export type BlocksSumAggregateInputType = {
    id?: true
    site_id?: true
  }

  export type BlocksMinAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
  }

  export type BlocksMaxAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
  }

  export type BlocksCountAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to aggregate.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type blocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithAggregationInput | blocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    id: number
    block_name: string
    site_id: number
    created_at: Date
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends blocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectScalar = {
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
  }

  export type blocksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block_name" | "site_id" | "created_at", ExtArgs["result"]["blocks"]>
  export type blocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type blocksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type blocksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }

  export type $blocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blocks"
    objects: {
      sites: Prisma.$sitesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block_name: string
      site_id: number
      created_at: Date
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }

  type blocksGetPayload<S extends boolean | null | undefined | blocksDefaultArgs> = $Result.GetResult<Prisma.$blocksPayload, S>

  type blocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blocksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface blocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blocks'], meta: { name: 'blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blocksFindUniqueArgs>(args: SelectSubset<T, blocksFindUniqueArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs>(args: SelectSubset<T, blocksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blocksFindFirstArgs>(args?: SelectSubset<T, blocksFindFirstArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs>(args?: SelectSubset<T, blocksFindFirstOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blocksWithIdOnly = await prisma.blocks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blocksFindManyArgs>(args?: SelectSubset<T, blocksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
     */
    create<T extends blocksCreateArgs>(args: SelectSubset<T, blocksCreateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blocksCreateManyArgs>(args?: SelectSubset<T, blocksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {blocksCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blocksCreateManyAndReturnArgs>(args?: SelectSubset<T, blocksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
     */
    delete<T extends blocksDeleteArgs>(args: SelectSubset<T, blocksDeleteArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blocksUpdateArgs>(args: SelectSubset<T, blocksUpdateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blocksDeleteManyArgs>(args?: SelectSubset<T, blocksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blocksUpdateManyArgs>(args: SelectSubset<T, blocksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {blocksUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blocksUpdateManyAndReturnArgs>(args: SelectSubset<T, blocksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
     */
    upsert<T extends blocksUpsertArgs>(args: SelectSubset<T, blocksUpsertArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blocksGroupByArgs['orderBy'] }
        : { orderBy?: blocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blocks model
   */
  readonly fields: blocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends blocks$usersArgs<ExtArgs> = {}>(args?: Subset<T, blocks$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blocks model
   */
  interface blocksFieldRefs {
    readonly id: FieldRef<"blocks", 'Int'>
    readonly block_name: FieldRef<"blocks", 'String'>
    readonly site_id: FieldRef<"blocks", 'Int'>
    readonly created_at: FieldRef<"blocks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blocks findUnique
   */
  export type blocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findFirst
   */
  export type blocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findMany
   */
  export type blocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks create
   */
  export type blocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to create a blocks.
     */
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }

  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blocks createManyAndReturn
   */
  export type blocksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks update
   */
  export type blocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to update a blocks.
     */
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
  }

  /**
   * blocks updateManyAndReturn
   */
  export type blocksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks upsert
   */
  export type blocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The filter to search for the blocks to update in case it exists.
     */
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     */
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }

  /**
   * blocks delete
   */
  export type blocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter which blocks to delete.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to delete.
     */
    limit?: number
  }

  /**
   * blocks.users
   */
  export type blocks$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * blocks without action
   */
  export type blocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
    manager_id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number | null
    manager_id: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    manager_id: number | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    manager_id: number | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    company_name: number
    company_code: number
    account_status: number
    created_at: number
    updated_at: number
    deleted_at: number
    manager_id: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    manager_id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    manager_id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: number
    company_name: string
    company_code: string
    account_status: $Enums.AccountStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    manager_id: number
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "company_code" | "account_status" | "created_at" | "updated_at" | "deleted_at" | "manager_id", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
  }
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
  }

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      admins: Prisma.$adminsPayload<ExtArgs>
      company_employees: Prisma.$company_employeesPayload<ExtArgs>[]
      invitations: Prisma.$invitationsPayload<ExtArgs>[]
      sites: Prisma.$sitesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_name: string
      company_code: string
      account_status: $Enums.AccountStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      manager_id: number
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends adminsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminsDefaultArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company_employees<T extends companies$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends companies$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, companies$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sites<T extends companies$sitesArgs<ExtArgs> = {}>(args?: Subset<T, companies$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'Int'>
    readonly company_name: FieldRef<"companies", 'String'>
    readonly company_code: FieldRef<"companies", 'String'>
    readonly account_status: FieldRef<"companies", 'AccountStatus'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
    readonly deleted_at: FieldRef<"companies", 'DateTime'>
    readonly manager_id: FieldRef<"companies", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.company_employees
   */
  export type companies$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    cursor?: company_employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * companies.invitations
   */
  export type companies$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    cursor?: invitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * companies.sites
   */
  export type companies$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    where?: sitesWhereInput
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    cursor?: sitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model company_employees
   */

  export type AggregateCompany_employees = {
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  export type Company_employeesAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
  }

  export type Company_employeesMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
  }

  export type Company_employeesCountAggregateOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: number
    status: number
    _all: number
  }


  export type Company_employeesAvgAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesSumAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesMinAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
  }

  export type Company_employeesMaxAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
  }

  export type Company_employeesCountAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
    _all?: true
  }

  export type Company_employeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to aggregate.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_employees
    **/
    _count?: true | Company_employeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_employeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_employeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_employeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_employeesMaxAggregateInputType
  }

  export type GetCompany_employeesAggregateType<T extends Company_employeesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_employees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_employees[P]>
      : GetScalarType<T[P], AggregateCompany_employees[P]>
  }




  export type company_employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithAggregationInput | company_employeesOrderByWithAggregationInput[]
    by: Company_employeesScalarFieldEnum[] | Company_employeesScalarFieldEnum
    having?: company_employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_employeesCountAggregateInputType | true
    _avg?: Company_employeesAvgAggregateInputType
    _sum?: Company_employeesSumAggregateInputType
    _min?: Company_employeesMinAggregateInputType
    _max?: Company_employeesMaxAggregateInputType
  }

  export type Company_employeesGroupByOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: Date
    status: $Enums.AccountStatus
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  type GetCompany_employeesGroupByPayload<T extends company_employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_employeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_employeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
        }
      >
    >


  export type company_employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectScalar = {
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
  }

  export type company_employeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "company_id" | "joined_at" | "status", ExtArgs["result"]["company_employees"]>
  export type company_employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | adminsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_employees"
    objects: {
      admins: Prisma.$adminsPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      company_id: number
      joined_at: Date
      status: $Enums.AccountStatus
    }, ExtArgs["result"]["company_employees"]>
    composites: {}
  }

  type company_employeesGetPayload<S extends boolean | null | undefined | company_employeesDefaultArgs> = $Result.GetResult<Prisma.$company_employeesPayload, S>

  type company_employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_employeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_employeesCountAggregateInputType | true
    }

  export interface company_employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_employees'], meta: { name: 'company_employees' } }
    /**
     * Find zero or one Company_employees that matches the filter.
     * @param {company_employeesFindUniqueArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_employeesFindUniqueArgs>(args: SelectSubset<T, company_employeesFindUniqueArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_employeesFindUniqueOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_employeesFindFirstArgs>(args?: SelectSubset<T, company_employeesFindFirstArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_employees
     * const company_employees = await prisma.company_employees.findMany()
     * 
     * // Get first 10 Company_employees
     * const company_employees = await prisma.company_employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_employeesFindManyArgs>(args?: SelectSubset<T, company_employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_employees.
     * @param {company_employeesCreateArgs} args - Arguments to create a Company_employees.
     * @example
     * // Create one Company_employees
     * const Company_employees = await prisma.company_employees.create({
     *   data: {
     *     // ... data to create a Company_employees
     *   }
     * })
     * 
     */
    create<T extends company_employeesCreateArgs>(args: SelectSubset<T, company_employeesCreateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_employees.
     * @param {company_employeesCreateManyArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_employeesCreateManyArgs>(args?: SelectSubset<T, company_employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_employees and returns the data saved in the database.
     * @param {company_employeesCreateManyAndReturnArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_employeesCreateManyAndReturnArgs>(args?: SelectSubset<T, company_employeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_employees.
     * @param {company_employeesDeleteArgs} args - Arguments to delete one Company_employees.
     * @example
     * // Delete one Company_employees
     * const Company_employees = await prisma.company_employees.delete({
     *   where: {
     *     // ... filter to delete one Company_employees
     *   }
     * })
     * 
     */
    delete<T extends company_employeesDeleteArgs>(args: SelectSubset<T, company_employeesDeleteArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_employees.
     * @param {company_employeesUpdateArgs} args - Arguments to update one Company_employees.
     * @example
     * // Update one Company_employees
     * const company_employees = await prisma.company_employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_employeesUpdateArgs>(args: SelectSubset<T, company_employeesUpdateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_employees.
     * @param {company_employeesDeleteManyArgs} args - Arguments to filter Company_employees to delete.
     * @example
     * // Delete a few Company_employees
     * const { count } = await prisma.company_employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_employeesDeleteManyArgs>(args?: SelectSubset<T, company_employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_employeesUpdateManyArgs>(args: SelectSubset<T, company_employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees and returns the data updated in the database.
     * @param {company_employeesUpdateManyAndReturnArgs} args - Arguments to update many Company_employees.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_employeesUpdateManyAndReturnArgs>(args: SelectSubset<T, company_employeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_employees.
     * @param {company_employeesUpsertArgs} args - Arguments to update or create a Company_employees.
     * @example
     * // Update or create a Company_employees
     * const company_employees = await prisma.company_employees.upsert({
     *   create: {
     *     // ... data to create a Company_employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_employees we want to update
     *   }
     * })
     */
    upsert<T extends company_employeesUpsertArgs>(args: SelectSubset<T, company_employeesUpsertArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesCountArgs} args - Arguments to filter Company_employees to count.
     * @example
     * // Count the number of Company_employees
     * const count = await prisma.company_employees.count({
     *   where: {
     *     // ... the filter for the Company_employees we want to count
     *   }
     * })
    **/
    count<T extends company_employeesCountArgs>(
      args?: Subset<T, company_employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_employeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_employeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_employeesAggregateArgs>(args: Subset<T, Company_employeesAggregateArgs>): Prisma.PrismaPromise<GetCompany_employeesAggregateType<T>>

    /**
     * Group by Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_employeesGroupByArgs['orderBy'] }
        : { orderBy?: company_employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_employeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_employees model
   */
  readonly fields: company_employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends adminsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminsDefaultArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee_site_access<T extends company_employees$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, company_employees$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_employees model
   */
  interface company_employeesFieldRefs {
    readonly id: FieldRef<"company_employees", 'Int'>
    readonly admin_id: FieldRef<"company_employees", 'Int'>
    readonly company_id: FieldRef<"company_employees", 'Int'>
    readonly joined_at: FieldRef<"company_employees", 'DateTime'>
    readonly status: FieldRef<"company_employees", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * company_employees findUnique
   */
  export type company_employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findUniqueOrThrow
   */
  export type company_employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findFirst
   */
  export type company_employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findFirstOrThrow
   */
  export type company_employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findMany
   */
  export type company_employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees create
   */
  export type company_employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_employees.
     */
    data: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
  }

  /**
   * company_employees createMany
   */
  export type company_employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_employees createManyAndReturn
   */
  export type company_employeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees update
   */
  export type company_employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_employees.
     */
    data: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
    /**
     * Choose, which company_employees to update.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees updateMany
   */
  export type company_employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
  }

  /**
   * company_employees updateManyAndReturn
   */
  export type company_employeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees upsert
   */
  export type company_employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_employees to update in case it exists.
     */
    where: company_employeesWhereUniqueInput
    /**
     * In case the company_employees found by the `where` argument doesn't exist, create a new company_employees with this data.
     */
    create: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
    /**
     * In case the company_employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
  }

  /**
   * company_employees delete
   */
  export type company_employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter which company_employees to delete.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees deleteMany
   */
  export type company_employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to delete
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to delete.
     */
    limit?: number
  }

  /**
   * company_employees.employee_site_access
   */
  export type company_employees$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * company_employees without action
   */
  export type company_employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
  }


  /**
   * Model complaints
   */

  export type AggregateComplaints = {
    _count: ComplaintsCountAggregateOutputType | null
    _avg: ComplaintsAvgAggregateOutputType | null
    _sum: ComplaintsSumAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  export type ComplaintsAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintsSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    status: number
    siteId: number
    userId: number
    created_at: number
    updated_at: number
    category: number
    _all: number
  }


  export type ComplaintsAvgAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintsSumAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
    _all?: true
  }

  export type ComplaintsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to aggregate.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints
    **/
    _count?: true | ComplaintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintsMaxAggregateInputType
  }

  export type GetComplaintsAggregateType<T extends ComplaintsAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaints[P]>
      : GetScalarType<T[P], AggregateComplaints[P]>
  }




  export type complaintsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithAggregationInput | complaintsOrderByWithAggregationInput[]
    by: ComplaintsScalarFieldEnum[] | ComplaintsScalarFieldEnum
    having?: complaintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintsCountAggregateInputType | true
    _avg?: ComplaintsAvgAggregateInputType
    _sum?: ComplaintsSumAggregateInputType
    _min?: ComplaintsMinAggregateInputType
    _max?: ComplaintsMaxAggregateInputType
  }

  export type ComplaintsGroupByOutputType = {
    id: number
    title: string
    content: string
    status: $Enums.Status
    siteId: number
    userId: number
    created_at: Date
    updated_at: Date
    category: $Enums.Category | null
    _count: ComplaintsCountAggregateOutputType | null
    _avg: ComplaintsAvgAggregateOutputType | null
    _sum: ComplaintsSumAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  type GetComplaintsGroupByPayload<T extends complaintsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
        }
      >
    >


  export type complaintsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
  }

  export type complaintsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "status" | "siteId" | "userId" | "created_at" | "updated_at" | "category", ExtArgs["result"]["complaints"]>
  export type complaintsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type complaintsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type complaintsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $complaintsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "complaints"
    objects: {
      sites: Prisma.$sitesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      status: $Enums.Status
      siteId: number
      userId: number
      created_at: Date
      updated_at: Date
      category: $Enums.Category | null
    }, ExtArgs["result"]["complaints"]>
    composites: {}
  }

  type complaintsGetPayload<S extends boolean | null | undefined | complaintsDefaultArgs> = $Result.GetResult<Prisma.$complaintsPayload, S>

  type complaintsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<complaintsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintsCountAggregateInputType | true
    }

  export interface complaintsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['complaints'], meta: { name: 'complaints' } }
    /**
     * Find zero or one Complaints that matches the filter.
     * @param {complaintsFindUniqueArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends complaintsFindUniqueArgs>(args: SelectSubset<T, complaintsFindUniqueArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaints that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {complaintsFindUniqueOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends complaintsFindUniqueOrThrowArgs>(args: SelectSubset<T, complaintsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends complaintsFindFirstArgs>(args?: SelectSubset<T, complaintsFindFirstArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends complaintsFindFirstOrThrowArgs>(args?: SelectSubset<T, complaintsFindFirstOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaints.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintsWithIdOnly = await prisma.complaints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends complaintsFindManyArgs>(args?: SelectSubset<T, complaintsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaints.
     * @param {complaintsCreateArgs} args - Arguments to create a Complaints.
     * @example
     * // Create one Complaints
     * const Complaints = await prisma.complaints.create({
     *   data: {
     *     // ... data to create a Complaints
     *   }
     * })
     * 
     */
    create<T extends complaintsCreateArgs>(args: SelectSubset<T, complaintsCreateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {complaintsCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends complaintsCreateManyArgs>(args?: SelectSubset<T, complaintsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {complaintsCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends complaintsCreateManyAndReturnArgs>(args?: SelectSubset<T, complaintsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Complaints.
     * @param {complaintsDeleteArgs} args - Arguments to delete one Complaints.
     * @example
     * // Delete one Complaints
     * const Complaints = await prisma.complaints.delete({
     *   where: {
     *     // ... filter to delete one Complaints
     *   }
     * })
     * 
     */
    delete<T extends complaintsDeleteArgs>(args: SelectSubset<T, complaintsDeleteArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaints.
     * @param {complaintsUpdateArgs} args - Arguments to update one Complaints.
     * @example
     * // Update one Complaints
     * const complaints = await prisma.complaints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends complaintsUpdateArgs>(args: SelectSubset<T, complaintsUpdateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {complaintsDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends complaintsDeleteManyArgs>(args?: SelectSubset<T, complaintsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends complaintsUpdateManyArgs>(args: SelectSubset<T, complaintsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints and returns the data updated in the database.
     * @param {complaintsUpdateManyAndReturnArgs} args - Arguments to update many Complaints.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends complaintsUpdateManyAndReturnArgs>(args: SelectSubset<T, complaintsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Complaints.
     * @param {complaintsUpsertArgs} args - Arguments to update or create a Complaints.
     * @example
     * // Update or create a Complaints
     * const complaints = await prisma.complaints.upsert({
     *   create: {
     *     // ... data to create a Complaints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaints we want to update
     *   }
     * })
     */
    upsert<T extends complaintsUpsertArgs>(args: SelectSubset<T, complaintsUpsertArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaints.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends complaintsCountArgs>(
      args?: Subset<T, complaintsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintsAggregateArgs>(args: Subset<T, ComplaintsAggregateArgs>): Prisma.PrismaPromise<GetComplaintsAggregateType<T>>

    /**
     * Group by Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends complaintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: complaintsGroupByArgs['orderBy'] }
        : { orderBy?: complaintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, complaintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the complaints model
   */
  readonly fields: complaintsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__complaintsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the complaints model
   */
  interface complaintsFieldRefs {
    readonly id: FieldRef<"complaints", 'Int'>
    readonly title: FieldRef<"complaints", 'String'>
    readonly content: FieldRef<"complaints", 'String'>
    readonly status: FieldRef<"complaints", 'Status'>
    readonly siteId: FieldRef<"complaints", 'Int'>
    readonly userId: FieldRef<"complaints", 'Int'>
    readonly created_at: FieldRef<"complaints", 'DateTime'>
    readonly updated_at: FieldRef<"complaints", 'DateTime'>
    readonly category: FieldRef<"complaints", 'Category'>
  }
    

  // Custom InputTypes
  /**
   * complaints findUnique
   */
  export type complaintsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findUniqueOrThrow
   */
  export type complaintsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findFirst
   */
  export type complaintsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findFirstOrThrow
   */
  export type complaintsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findMany
   */
  export type complaintsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints create
   */
  export type complaintsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to create a complaints.
     */
    data: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
  }

  /**
   * complaints createMany
   */
  export type complaintsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * complaints createManyAndReturn
   */
  export type complaintsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * complaints update
   */
  export type complaintsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to update a complaints.
     */
    data: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
    /**
     * Choose, which complaints to update.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints updateMany
   */
  export type complaintsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to update.
     */
    limit?: number
  }

  /**
   * complaints updateManyAndReturn
   */
  export type complaintsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * complaints upsert
   */
  export type complaintsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The filter to search for the complaints to update in case it exists.
     */
    where: complaintsWhereUniqueInput
    /**
     * In case the complaints found by the `where` argument doesn't exist, create a new complaints with this data.
     */
    create: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
    /**
     * In case the complaints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
  }

  /**
   * complaints delete
   */
  export type complaintsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter which complaints to delete.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints deleteMany
   */
  export type complaintsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to delete
     */
    where?: complaintsWhereInput
    /**
     * Limit how many complaints to delete.
     */
    limit?: number
  }

  /**
   * complaints without action
   */
  export type complaintsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
  }


  /**
   * Model employee_site_access
   */

  export type AggregateEmployee_site_access = {
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  export type Employee_site_accessAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
  }

  export type Employee_site_accessMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
  }

  export type Employee_site_accessCountAggregateOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: number
    _all: number
  }


  export type Employee_site_accessAvgAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessSumAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessMinAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
  }

  export type Employee_site_accessMaxAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
  }

  export type Employee_site_accessCountAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
    _all?: true
  }

  export type Employee_site_accessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_access to aggregate.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employee_site_accesses
    **/
    _count?: true | Employee_site_accessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Employee_site_accessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Employee_site_accessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_site_accessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type GetEmployee_site_accessAggregateType<T extends Employee_site_accessAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_site_access]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_site_access[P]>
      : GetScalarType<T[P], AggregateEmployee_site_access[P]>
  }




  export type employee_site_accessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithAggregationInput | employee_site_accessOrderByWithAggregationInput[]
    by: Employee_site_accessScalarFieldEnum[] | Employee_site_accessScalarFieldEnum
    having?: employee_site_accessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_site_accessCountAggregateInputType | true
    _avg?: Employee_site_accessAvgAggregateInputType
    _sum?: Employee_site_accessSumAggregateInputType
    _min?: Employee_site_accessMinAggregateInputType
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type Employee_site_accessGroupByOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: Date
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  type GetEmployee_site_accessGroupByPayload<T extends employee_site_accessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_site_accessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_site_accessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
        }
      >
    >


  export type employee_site_accessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectScalar = {
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
  }

  export type employee_site_accessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "site_id" | "granted_at", ExtArgs["result"]["employee_site_access"]>
  export type employee_site_accessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }

  export type $employee_site_accessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee_site_access"
    objects: {
      company_employees: Prisma.$company_employeesPayload<ExtArgs>
      sites: Prisma.$sitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number
      site_id: number
      granted_at: Date
    }, ExtArgs["result"]["employee_site_access"]>
    composites: {}
  }

  type employee_site_accessGetPayload<S extends boolean | null | undefined | employee_site_accessDefaultArgs> = $Result.GetResult<Prisma.$employee_site_accessPayload, S>

  type employee_site_accessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employee_site_accessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Employee_site_accessCountAggregateInputType | true
    }

  export interface employee_site_accessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee_site_access'], meta: { name: 'employee_site_access' } }
    /**
     * Find zero or one Employee_site_access that matches the filter.
     * @param {employee_site_accessFindUniqueArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employee_site_accessFindUniqueArgs>(args: SelectSubset<T, employee_site_accessFindUniqueArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee_site_access that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employee_site_accessFindUniqueOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employee_site_accessFindUniqueOrThrowArgs>(args: SelectSubset<T, employee_site_accessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employee_site_accessFindFirstArgs>(args?: SelectSubset<T, employee_site_accessFindFirstArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employee_site_accessFindFirstOrThrowArgs>(args?: SelectSubset<T, employee_site_accessFindFirstOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employee_site_accesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany()
     * 
     * // Get first 10 Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employee_site_accessFindManyArgs>(args?: SelectSubset<T, employee_site_accessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee_site_access.
     * @param {employee_site_accessCreateArgs} args - Arguments to create a Employee_site_access.
     * @example
     * // Create one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.create({
     *   data: {
     *     // ... data to create a Employee_site_access
     *   }
     * })
     * 
     */
    create<T extends employee_site_accessCreateArgs>(args: SelectSubset<T, employee_site_accessCreateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employee_site_accesses.
     * @param {employee_site_accessCreateManyArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employee_site_accessCreateManyArgs>(args?: SelectSubset<T, employee_site_accessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employee_site_accesses and returns the data saved in the database.
     * @param {employee_site_accessCreateManyAndReturnArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employee_site_accessCreateManyAndReturnArgs>(args?: SelectSubset<T, employee_site_accessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee_site_access.
     * @param {employee_site_accessDeleteArgs} args - Arguments to delete one Employee_site_access.
     * @example
     * // Delete one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.delete({
     *   where: {
     *     // ... filter to delete one Employee_site_access
     *   }
     * })
     * 
     */
    delete<T extends employee_site_accessDeleteArgs>(args: SelectSubset<T, employee_site_accessDeleteArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee_site_access.
     * @param {employee_site_accessUpdateArgs} args - Arguments to update one Employee_site_access.
     * @example
     * // Update one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employee_site_accessUpdateArgs>(args: SelectSubset<T, employee_site_accessUpdateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employee_site_accesses.
     * @param {employee_site_accessDeleteManyArgs} args - Arguments to filter Employee_site_accesses to delete.
     * @example
     * // Delete a few Employee_site_accesses
     * const { count } = await prisma.employee_site_access.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employee_site_accessDeleteManyArgs>(args?: SelectSubset<T, employee_site_accessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employee_site_accessUpdateManyArgs>(args: SelectSubset<T, employee_site_accessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses and returns the data updated in the database.
     * @param {employee_site_accessUpdateManyAndReturnArgs} args - Arguments to update many Employee_site_accesses.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employee_site_accessUpdateManyAndReturnArgs>(args: SelectSubset<T, employee_site_accessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee_site_access.
     * @param {employee_site_accessUpsertArgs} args - Arguments to update or create a Employee_site_access.
     * @example
     * // Update or create a Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.upsert({
     *   create: {
     *     // ... data to create a Employee_site_access
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_site_access we want to update
     *   }
     * })
     */
    upsert<T extends employee_site_accessUpsertArgs>(args: SelectSubset<T, employee_site_accessUpsertArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessCountArgs} args - Arguments to filter Employee_site_accesses to count.
     * @example
     * // Count the number of Employee_site_accesses
     * const count = await prisma.employee_site_access.count({
     *   where: {
     *     // ... the filter for the Employee_site_accesses we want to count
     *   }
     * })
    **/
    count<T extends employee_site_accessCountArgs>(
      args?: Subset<T, employee_site_accessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_site_accessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_site_accessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_site_accessAggregateArgs>(args: Subset<T, Employee_site_accessAggregateArgs>): Prisma.PrismaPromise<GetEmployee_site_accessAggregateType<T>>

    /**
     * Group by Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employee_site_accessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employee_site_accessGroupByArgs['orderBy'] }
        : { orderBy?: employee_site_accessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employee_site_accessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_site_accessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee_site_access model
   */
  readonly fields: employee_site_accessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee_site_access.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employee_site_accessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_employees<T extends company_employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, company_employeesDefaultArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee_site_access model
   */
  interface employee_site_accessFieldRefs {
    readonly id: FieldRef<"employee_site_access", 'Int'>
    readonly employee_id: FieldRef<"employee_site_access", 'Int'>
    readonly site_id: FieldRef<"employee_site_access", 'Int'>
    readonly granted_at: FieldRef<"employee_site_access", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employee_site_access findUnique
   */
  export type employee_site_accessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findUniqueOrThrow
   */
  export type employee_site_accessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findFirst
   */
  export type employee_site_accessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findFirstOrThrow
   */
  export type employee_site_accessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findMany
   */
  export type employee_site_accessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_accesses to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access create
   */
  export type employee_site_accessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to create a employee_site_access.
     */
    data: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
  }

  /**
   * employee_site_access createMany
   */
  export type employee_site_accessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee_site_access createManyAndReturn
   */
  export type employee_site_accessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access update
   */
  export type employee_site_accessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to update a employee_site_access.
     */
    data: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
    /**
     * Choose, which employee_site_access to update.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access updateMany
   */
  export type employee_site_accessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
  }

  /**
   * employee_site_access updateManyAndReturn
   */
  export type employee_site_accessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access upsert
   */
  export type employee_site_accessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The filter to search for the employee_site_access to update in case it exists.
     */
    where: employee_site_accessWhereUniqueInput
    /**
     * In case the employee_site_access found by the `where` argument doesn't exist, create a new employee_site_access with this data.
     */
    create: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
    /**
     * In case the employee_site_access was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
  }

  /**
   * employee_site_access delete
   */
  export type employee_site_accessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter which employee_site_access to delete.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access deleteMany
   */
  export type employee_site_accessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_accesses to delete
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to delete.
     */
    limit?: number
  }

  /**
   * employee_site_access without action
   */
  export type employee_site_accessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
  }


  /**
   * Model invitations
   */

  export type AggregateInvitations = {
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  export type InvitationsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsSumAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsMinAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsMaxAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsCountAggregateOutputType = {
    id: number
    company_id: number
    invite_code: number
    invite_link: number
    invited_email: number
    invited_by: number
    status: number
    expires_at: number
    used_at: number
    used_by: number
    created_at: number
    _all: number
  }


  export type InvitationsAvgAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsSumAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsMinAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsCountAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
    _all?: true
  }

  export type InvitationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to aggregate.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invitations
    **/
    _count?: true | InvitationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationsMaxAggregateInputType
  }

  export type GetInvitationsAggregateType<T extends InvitationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitations[P]>
      : GetScalarType<T[P], AggregateInvitations[P]>
  }




  export type invitationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithAggregationInput | invitationsOrderByWithAggregationInput[]
    by: InvitationsScalarFieldEnum[] | InvitationsScalarFieldEnum
    having?: invitationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationsCountAggregateInputType | true
    _avg?: InvitationsAvgAggregateInputType
    _sum?: InvitationsSumAggregateInputType
    _min?: InvitationsMinAggregateInputType
    _max?: InvitationsMaxAggregateInputType
  }

  export type InvitationsGroupByOutputType = {
    id: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email: string | null
    invited_by: number
    status: $Enums.InvitationStatus
    expires_at: Date
    used_at: Date | null
    used_by: number | null
    created_at: Date
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  type GetInvitationsGroupByPayload<T extends invitationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
        }
      >
    >


  export type invitationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
  }

  export type invitationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "invite_code" | "invite_link" | "invited_email" | "invited_by" | "status" | "expires_at" | "used_at" | "used_by" | "created_at", ExtArgs["result"]["invitations"]>
  export type invitationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $invitationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invitations"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: number
      invite_code: string
      invite_link: string
      invited_email: string | null
      invited_by: number
      status: $Enums.InvitationStatus
      expires_at: Date
      used_at: Date | null
      used_by: number | null
      created_at: Date
    }, ExtArgs["result"]["invitations"]>
    composites: {}
  }

  type invitationsGetPayload<S extends boolean | null | undefined | invitationsDefaultArgs> = $Result.GetResult<Prisma.$invitationsPayload, S>

  type invitationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invitationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationsCountAggregateInputType | true
    }

  export interface invitationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invitations'], meta: { name: 'invitations' } }
    /**
     * Find zero or one Invitations that matches the filter.
     * @param {invitationsFindUniqueArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invitationsFindUniqueArgs>(args: SelectSubset<T, invitationsFindUniqueArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invitationsFindUniqueOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invitationsFindUniqueOrThrowArgs>(args: SelectSubset<T, invitationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invitationsFindFirstArgs>(args?: SelectSubset<T, invitationsFindFirstArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invitationsFindFirstOrThrowArgs>(args?: SelectSubset<T, invitationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitations.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationsWithIdOnly = await prisma.invitations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invitationsFindManyArgs>(args?: SelectSubset<T, invitationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitations.
     * @param {invitationsCreateArgs} args - Arguments to create a Invitations.
     * @example
     * // Create one Invitations
     * const Invitations = await prisma.invitations.create({
     *   data: {
     *     // ... data to create a Invitations
     *   }
     * })
     * 
     */
    create<T extends invitationsCreateArgs>(args: SelectSubset<T, invitationsCreateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {invitationsCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invitationsCreateManyArgs>(args?: SelectSubset<T, invitationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {invitationsCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invitationsCreateManyAndReturnArgs>(args?: SelectSubset<T, invitationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitations.
     * @param {invitationsDeleteArgs} args - Arguments to delete one Invitations.
     * @example
     * // Delete one Invitations
     * const Invitations = await prisma.invitations.delete({
     *   where: {
     *     // ... filter to delete one Invitations
     *   }
     * })
     * 
     */
    delete<T extends invitationsDeleteArgs>(args: SelectSubset<T, invitationsDeleteArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitations.
     * @param {invitationsUpdateArgs} args - Arguments to update one Invitations.
     * @example
     * // Update one Invitations
     * const invitations = await prisma.invitations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invitationsUpdateArgs>(args: SelectSubset<T, invitationsUpdateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {invitationsDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invitationsDeleteManyArgs>(args?: SelectSubset<T, invitationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invitationsUpdateManyArgs>(args: SelectSubset<T, invitationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {invitationsUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invitationsUpdateManyAndReturnArgs>(args: SelectSubset<T, invitationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitations.
     * @param {invitationsUpsertArgs} args - Arguments to update or create a Invitations.
     * @example
     * // Update or create a Invitations
     * const invitations = await prisma.invitations.upsert({
     *   create: {
     *     // ... data to create a Invitations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitations we want to update
     *   }
     * })
     */
    upsert<T extends invitationsUpsertArgs>(args: SelectSubset<T, invitationsUpsertArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitations.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends invitationsCountArgs>(
      args?: Subset<T, invitationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationsAggregateArgs>(args: Subset<T, InvitationsAggregateArgs>): Prisma.PrismaPromise<GetInvitationsAggregateType<T>>

    /**
     * Group by Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invitationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invitationsGroupByArgs['orderBy'] }
        : { orderBy?: invitationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invitationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invitations model
   */
  readonly fields: invitationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invitations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invitationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invitations model
   */
  interface invitationsFieldRefs {
    readonly id: FieldRef<"invitations", 'Int'>
    readonly company_id: FieldRef<"invitations", 'Int'>
    readonly invite_code: FieldRef<"invitations", 'String'>
    readonly invite_link: FieldRef<"invitations", 'String'>
    readonly invited_email: FieldRef<"invitations", 'String'>
    readonly invited_by: FieldRef<"invitations", 'Int'>
    readonly status: FieldRef<"invitations", 'InvitationStatus'>
    readonly expires_at: FieldRef<"invitations", 'DateTime'>
    readonly used_at: FieldRef<"invitations", 'DateTime'>
    readonly used_by: FieldRef<"invitations", 'Int'>
    readonly created_at: FieldRef<"invitations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invitations findUnique
   */
  export type invitationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findUniqueOrThrow
   */
  export type invitationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findFirst
   */
  export type invitationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findFirstOrThrow
   */
  export type invitationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findMany
   */
  export type invitationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations create
   */
  export type invitationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to create a invitations.
     */
    data: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
  }

  /**
   * invitations createMany
   */
  export type invitationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invitations createManyAndReturn
   */
  export type invitationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations update
   */
  export type invitationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to update a invitations.
     */
    data: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
    /**
     * Choose, which invitations to update.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations updateMany
   */
  export type invitationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
  }

  /**
   * invitations updateManyAndReturn
   */
  export type invitationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations upsert
   */
  export type invitationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The filter to search for the invitations to update in case it exists.
     */
    where: invitationsWhereUniqueInput
    /**
     * In case the invitations found by the `where` argument doesn't exist, create a new invitations with this data.
     */
    create: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
    /**
     * In case the invitations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
  }

  /**
   * invitations delete
   */
  export type invitationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter which invitations to delete.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations deleteMany
   */
  export type invitationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to delete
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to delete.
     */
    limit?: number
  }

  /**
   * invitations without action
   */
  export type invitationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    amount: number
    payment_date: number
    payment_method: number
    description: number
    created_at: number
    userId: number
    siteId: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    amount: number
    payment_date: Date
    payment_method: $Enums.PaymentMethod
    description: string | null
    created_at: Date
    userId: number
    siteId: number
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "payment_date" | "payment_method" | "description" | "created_at" | "userId" | "siteId", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      payment_date: Date
      payment_method: $Enums.PaymentMethod
      description: string | null
      created_at: Date
      userId: number
      siteId: number
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Float'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'PaymentMethod'>
    readonly description: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly userId: FieldRef<"payments", 'Int'>
    readonly siteId: FieldRef<"payments", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model sites
   */

  export type AggregateSites = {
    _count: SitesCountAggregateOutputType | null
    _avg: SitesAvgAggregateOutputType | null
    _sum: SitesSumAggregateOutputType | null
    _min: SitesMinAggregateOutputType | null
    _max: SitesMaxAggregateOutputType | null
  }

  export type SitesAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SitesSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SitesMinAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SitesMaxAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SitesCountAggregateOutputType = {
    id: number
    site_id: number
    site_name: number
    site_address: number
    created_at: number
    updated_at: number
    adminId: number
    apartment_count: number
    block_count: number
    company_id: number
    deleted_at: number
    site_status: number
    _all: number
  }


  export type SitesAvgAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SitesSumAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SitesMinAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SitesMaxAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SitesCountAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
    _all?: true
  }

  export type SitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sites to aggregate.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sites
    **/
    _count?: true | SitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitesMaxAggregateInputType
  }

  export type GetSitesAggregateType<T extends SitesAggregateArgs> = {
        [P in keyof T & keyof AggregateSites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSites[P]>
      : GetScalarType<T[P], AggregateSites[P]>
  }




  export type sitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sitesWhereInput
    orderBy?: sitesOrderByWithAggregationInput | sitesOrderByWithAggregationInput[]
    by: SitesScalarFieldEnum[] | SitesScalarFieldEnum
    having?: sitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitesCountAggregateInputType | true
    _avg?: SitesAvgAggregateInputType
    _sum?: SitesSumAggregateInputType
    _min?: SitesMinAggregateInputType
    _max?: SitesMaxAggregateInputType
  }

  export type SitesGroupByOutputType = {
    id: number
    site_id: string
    site_name: string
    site_address: string
    created_at: Date
    updated_at: Date
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus
    _count: SitesCountAggregateOutputType | null
    _avg: SitesAvgAggregateOutputType | null
    _sum: SitesSumAggregateOutputType | null
    _min: SitesMinAggregateOutputType | null
    _max: SitesMaxAggregateOutputType | null
  }

  type GetSitesGroupByPayload<T extends sitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitesGroupByOutputType[P]>
            : GetScalarType<T[P], SitesGroupByOutputType[P]>
        }
      >
    >


  export type sitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    announcements?: boolean | sites$announcementsArgs<ExtArgs>
    blocks?: boolean | sites$blocksArgs<ExtArgs>
    complaints?: boolean | sites$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | sites$employee_site_accessArgs<ExtArgs>
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
    social_amenities?: boolean | sites$social_amenitiesArgs<ExtArgs>
    users?: boolean | sites$usersArgs<ExtArgs>
    _count?: boolean | SitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectScalar = {
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
  }

  export type sitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "site_id" | "site_name" | "site_address" | "created_at" | "updated_at" | "adminId" | "apartment_count" | "block_count" | "company_id" | "deleted_at" | "site_status", ExtArgs["result"]["sites"]>
  export type sitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | sites$announcementsArgs<ExtArgs>
    blocks?: boolean | sites$blocksArgs<ExtArgs>
    complaints?: boolean | sites$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | sites$employee_site_accessArgs<ExtArgs>
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
    social_amenities?: boolean | sites$social_amenitiesArgs<ExtArgs>
    users?: boolean | sites$usersArgs<ExtArgs>
    _count?: boolean | SitesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
  }
  export type sitesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | sites$adminsArgs<ExtArgs>
    companies?: boolean | sites$companiesArgs<ExtArgs>
  }

  export type $sitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sites"
    objects: {
      announcements: Prisma.$announcementsPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs>[]
      complaints: Prisma.$complaintsPayload<ExtArgs>[]
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
      admins: Prisma.$adminsPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs> | null
      social_amenities: Prisma.$social_amenitiesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_id: string
      site_name: string
      site_address: string
      created_at: Date
      updated_at: Date
      adminId: number | null
      apartment_count: number | null
      block_count: number | null
      company_id: number | null
      deleted_at: Date | null
      site_status: $Enums.AccountStatus
    }, ExtArgs["result"]["sites"]>
    composites: {}
  }

  type sitesGetPayload<S extends boolean | null | undefined | sitesDefaultArgs> = $Result.GetResult<Prisma.$sitesPayload, S>

  type sitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SitesCountAggregateInputType | true
    }

  export interface sitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sites'], meta: { name: 'sites' } }
    /**
     * Find zero or one Sites that matches the filter.
     * @param {sitesFindUniqueArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sitesFindUniqueArgs>(args: SelectSubset<T, sitesFindUniqueArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sitesFindUniqueOrThrowArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sitesFindUniqueOrThrowArgs>(args: SelectSubset<T, sitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindFirstArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sitesFindFirstArgs>(args?: SelectSubset<T, sitesFindFirstArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindFirstOrThrowArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sitesFindFirstOrThrowArgs>(args?: SelectSubset<T, sitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.sites.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.sites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitesWithIdOnly = await prisma.sites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sitesFindManyArgs>(args?: SelectSubset<T, sitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sites.
     * @param {sitesCreateArgs} args - Arguments to create a Sites.
     * @example
     * // Create one Sites
     * const Sites = await prisma.sites.create({
     *   data: {
     *     // ... data to create a Sites
     *   }
     * })
     * 
     */
    create<T extends sitesCreateArgs>(args: SelectSubset<T, sitesCreateArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {sitesCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const sites = await prisma.sites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sitesCreateManyArgs>(args?: SelectSubset<T, sitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {sitesCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const sites = await prisma.sites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const sitesWithIdOnly = await prisma.sites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sitesCreateManyAndReturnArgs>(args?: SelectSubset<T, sitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sites.
     * @param {sitesDeleteArgs} args - Arguments to delete one Sites.
     * @example
     * // Delete one Sites
     * const Sites = await prisma.sites.delete({
     *   where: {
     *     // ... filter to delete one Sites
     *   }
     * })
     * 
     */
    delete<T extends sitesDeleteArgs>(args: SelectSubset<T, sitesDeleteArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sites.
     * @param {sitesUpdateArgs} args - Arguments to update one Sites.
     * @example
     * // Update one Sites
     * const sites = await prisma.sites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sitesUpdateArgs>(args: SelectSubset<T, sitesUpdateArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {sitesDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.sites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sitesDeleteManyArgs>(args?: SelectSubset<T, sitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const sites = await prisma.sites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sitesUpdateManyArgs>(args: SelectSubset<T, sitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {sitesUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const sites = await prisma.sites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const sitesWithIdOnly = await prisma.sites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sitesUpdateManyAndReturnArgs>(args: SelectSubset<T, sitesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sites.
     * @param {sitesUpsertArgs} args - Arguments to update or create a Sites.
     * @example
     * // Update or create a Sites
     * const sites = await prisma.sites.upsert({
     *   create: {
     *     // ... data to create a Sites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sites we want to update
     *   }
     * })
     */
    upsert<T extends sitesUpsertArgs>(args: SelectSubset<T, sitesUpsertArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.sites.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends sitesCountArgs>(
      args?: Subset<T, sitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitesAggregateArgs>(args: Subset<T, SitesAggregateArgs>): Prisma.PrismaPromise<GetSitesAggregateType<T>>

    /**
     * Group by Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sitesGroupByArgs['orderBy'] }
        : { orderBy?: sitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sites model
   */
  readonly fields: sitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcements<T extends sites$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, sites$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends sites$blocksArgs<ExtArgs> = {}>(args?: Subset<T, sites$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends sites$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, sites$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee_site_access<T extends sites$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, sites$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admins<T extends sites$adminsArgs<ExtArgs> = {}>(args?: Subset<T, sites$adminsArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends sites$companiesArgs<ExtArgs> = {}>(args?: Subset<T, sites$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    social_amenities<T extends sites$social_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, sites$social_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends sites$usersArgs<ExtArgs> = {}>(args?: Subset<T, sites$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sites model
   */
  interface sitesFieldRefs {
    readonly id: FieldRef<"sites", 'Int'>
    readonly site_id: FieldRef<"sites", 'String'>
    readonly site_name: FieldRef<"sites", 'String'>
    readonly site_address: FieldRef<"sites", 'String'>
    readonly created_at: FieldRef<"sites", 'DateTime'>
    readonly updated_at: FieldRef<"sites", 'DateTime'>
    readonly adminId: FieldRef<"sites", 'Int'>
    readonly apartment_count: FieldRef<"sites", 'Int'>
    readonly block_count: FieldRef<"sites", 'Int'>
    readonly company_id: FieldRef<"sites", 'Int'>
    readonly deleted_at: FieldRef<"sites", 'DateTime'>
    readonly site_status: FieldRef<"sites", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * sites findUnique
   */
  export type sitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites findUniqueOrThrow
   */
  export type sitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites findFirst
   */
  export type sitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sites.
     */
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites findFirstOrThrow
   */
  export type sitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sites.
     */
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites findMany
   */
  export type sitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites create
   */
  export type sitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The data needed to create a sites.
     */
    data: XOR<sitesCreateInput, sitesUncheckedCreateInput>
  }

  /**
   * sites createMany
   */
  export type sitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sites.
     */
    data: sitesCreateManyInput | sitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sites createManyAndReturn
   */
  export type sitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * The data used to create many sites.
     */
    data: sitesCreateManyInput | sitesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sites update
   */
  export type sitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The data needed to update a sites.
     */
    data: XOR<sitesUpdateInput, sitesUncheckedUpdateInput>
    /**
     * Choose, which sites to update.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites updateMany
   */
  export type sitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sites.
     */
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyInput>
    /**
     * Filter which sites to update
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to update.
     */
    limit?: number
  }

  /**
   * sites updateManyAndReturn
   */
  export type sitesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * The data used to update sites.
     */
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyInput>
    /**
     * Filter which sites to update
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sites upsert
   */
  export type sitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The filter to search for the sites to update in case it exists.
     */
    where: sitesWhereUniqueInput
    /**
     * In case the sites found by the `where` argument doesn't exist, create a new sites with this data.
     */
    create: XOR<sitesCreateInput, sitesUncheckedCreateInput>
    /**
     * In case the sites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sitesUpdateInput, sitesUncheckedUpdateInput>
  }

  /**
   * sites delete
   */
  export type sitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter which sites to delete.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites deleteMany
   */
  export type sitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sites to delete
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to delete.
     */
    limit?: number
  }

  /**
   * sites.announcements
   */
  export type sites$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: announcementsInclude<ExtArgs> | null
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    cursor?: announcementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * sites.blocks
   */
  export type sites$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    cursor?: blocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * sites.complaints
   */
  export type sites$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * sites.employee_site_access
   */
  export type sites$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * sites.admins
   */
  export type sites$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminsInclude<ExtArgs> | null
    where?: adminsWhereInput
  }

  /**
   * sites.companies
   */
  export type sites$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * sites.social_amenities
   */
  export type sites$social_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    where?: social_amenitiesWhereInput
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    cursor?: social_amenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * sites.users
   */
  export type sites$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * sites without action
   */
  export type sitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
  }


  /**
   * Model social_amenities
   */

  export type AggregateSocial_amenities = {
    _count: Social_amenitiesCountAggregateOutputType | null
    _avg: Social_amenitiesAvgAggregateOutputType | null
    _sum: Social_amenitiesSumAggregateOutputType | null
    _min: Social_amenitiesMinAggregateOutputType | null
    _max: Social_amenitiesMaxAggregateOutputType | null
  }

  export type Social_amenitiesAvgAggregateOutputType = {
    siteId: number | null
  }

  export type Social_amenitiesSumAggregateOutputType = {
    siteId: number | null
  }

  export type Social_amenitiesMinAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Social_amenitiesMaxAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Social_amenitiesCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    description: number
    status: number
    hours: number
    rules: number
    extra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Social_amenitiesAvgAggregateInputType = {
    siteId?: true
  }

  export type Social_amenitiesSumAggregateInputType = {
    siteId?: true
  }

  export type Social_amenitiesMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Social_amenitiesMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Social_amenitiesCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Social_amenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_amenities to aggregate.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned social_amenities
    **/
    _count?: true | Social_amenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Social_amenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Social_amenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Social_amenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Social_amenitiesMaxAggregateInputType
  }

  export type GetSocial_amenitiesAggregateType<T extends Social_amenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateSocial_amenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocial_amenities[P]>
      : GetScalarType<T[P], AggregateSocial_amenities[P]>
  }




  export type social_amenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_amenitiesWhereInput
    orderBy?: social_amenitiesOrderByWithAggregationInput | social_amenitiesOrderByWithAggregationInput[]
    by: Social_amenitiesScalarFieldEnum[] | Social_amenitiesScalarFieldEnum
    having?: social_amenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Social_amenitiesCountAggregateInputType | true
    _avg?: Social_amenitiesAvgAggregateInputType
    _sum?: Social_amenitiesSumAggregateInputType
    _min?: Social_amenitiesMinAggregateInputType
    _max?: Social_amenitiesMaxAggregateInputType
  }

  export type Social_amenitiesGroupByOutputType = {
    id: string
    siteId: number
    name: string
    description: string | null
    status: string
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date
    updatedAt: Date
    _count: Social_amenitiesCountAggregateOutputType | null
    _avg: Social_amenitiesAvgAggregateOutputType | null
    _sum: Social_amenitiesSumAggregateOutputType | null
    _min: Social_amenitiesMinAggregateOutputType | null
    _max: Social_amenitiesMaxAggregateOutputType | null
  }

  type GetSocial_amenitiesGroupByPayload<T extends social_amenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Social_amenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Social_amenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Social_amenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Social_amenitiesGroupByOutputType[P]>
        }
      >
    >


  export type social_amenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type social_amenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "name" | "description" | "status" | "hours" | "rules" | "extra" | "createdAt" | "updatedAt", ExtArgs["result"]["social_amenities"]>
  export type social_amenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type social_amenitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type social_amenitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }

  export type $social_amenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "social_amenities"
    objects: {
      sites: Prisma.$sitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: number
      name: string
      description: string | null
      status: string
      hours: string | null
      rules: string | null
      extra: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["social_amenities"]>
    composites: {}
  }

  type social_amenitiesGetPayload<S extends boolean | null | undefined | social_amenitiesDefaultArgs> = $Result.GetResult<Prisma.$social_amenitiesPayload, S>

  type social_amenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<social_amenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Social_amenitiesCountAggregateInputType | true
    }

  export interface social_amenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['social_amenities'], meta: { name: 'social_amenities' } }
    /**
     * Find zero or one Social_amenities that matches the filter.
     * @param {social_amenitiesFindUniqueArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends social_amenitiesFindUniqueArgs>(args: SelectSubset<T, social_amenitiesFindUniqueArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Social_amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {social_amenitiesFindUniqueOrThrowArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends social_amenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, social_amenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindFirstArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends social_amenitiesFindFirstArgs>(args?: SelectSubset<T, social_amenitiesFindFirstArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindFirstOrThrowArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends social_amenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, social_amenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Social_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Social_amenities
     * const social_amenities = await prisma.social_amenities.findMany()
     * 
     * // Get first 10 Social_amenities
     * const social_amenities = await prisma.social_amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends social_amenitiesFindManyArgs>(args?: SelectSubset<T, social_amenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Social_amenities.
     * @param {social_amenitiesCreateArgs} args - Arguments to create a Social_amenities.
     * @example
     * // Create one Social_amenities
     * const Social_amenities = await prisma.social_amenities.create({
     *   data: {
     *     // ... data to create a Social_amenities
     *   }
     * })
     * 
     */
    create<T extends social_amenitiesCreateArgs>(args: SelectSubset<T, social_amenitiesCreateArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Social_amenities.
     * @param {social_amenitiesCreateManyArgs} args - Arguments to create many Social_amenities.
     * @example
     * // Create many Social_amenities
     * const social_amenities = await prisma.social_amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends social_amenitiesCreateManyArgs>(args?: SelectSubset<T, social_amenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Social_amenities and returns the data saved in the database.
     * @param {social_amenitiesCreateManyAndReturnArgs} args - Arguments to create many Social_amenities.
     * @example
     * // Create many Social_amenities
     * const social_amenities = await prisma.social_amenities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Social_amenities and only return the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends social_amenitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, social_amenitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Social_amenities.
     * @param {social_amenitiesDeleteArgs} args - Arguments to delete one Social_amenities.
     * @example
     * // Delete one Social_amenities
     * const Social_amenities = await prisma.social_amenities.delete({
     *   where: {
     *     // ... filter to delete one Social_amenities
     *   }
     * })
     * 
     */
    delete<T extends social_amenitiesDeleteArgs>(args: SelectSubset<T, social_amenitiesDeleteArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Social_amenities.
     * @param {social_amenitiesUpdateArgs} args - Arguments to update one Social_amenities.
     * @example
     * // Update one Social_amenities
     * const social_amenities = await prisma.social_amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends social_amenitiesUpdateArgs>(args: SelectSubset<T, social_amenitiesUpdateArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Social_amenities.
     * @param {social_amenitiesDeleteManyArgs} args - Arguments to filter Social_amenities to delete.
     * @example
     * // Delete a few Social_amenities
     * const { count } = await prisma.social_amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends social_amenitiesDeleteManyArgs>(args?: SelectSubset<T, social_amenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Social_amenities
     * const social_amenities = await prisma.social_amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends social_amenitiesUpdateManyArgs>(args: SelectSubset<T, social_amenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_amenities and returns the data updated in the database.
     * @param {social_amenitiesUpdateManyAndReturnArgs} args - Arguments to update many Social_amenities.
     * @example
     * // Update many Social_amenities
     * const social_amenities = await prisma.social_amenities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Social_amenities and only return the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends social_amenitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, social_amenitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Social_amenities.
     * @param {social_amenitiesUpsertArgs} args - Arguments to update or create a Social_amenities.
     * @example
     * // Update or create a Social_amenities
     * const social_amenities = await prisma.social_amenities.upsert({
     *   create: {
     *     // ... data to create a Social_amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Social_amenities we want to update
     *   }
     * })
     */
    upsert<T extends social_amenitiesUpsertArgs>(args: SelectSubset<T, social_amenitiesUpsertArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesCountArgs} args - Arguments to filter Social_amenities to count.
     * @example
     * // Count the number of Social_amenities
     * const count = await prisma.social_amenities.count({
     *   where: {
     *     // ... the filter for the Social_amenities we want to count
     *   }
     * })
    **/
    count<T extends social_amenitiesCountArgs>(
      args?: Subset<T, social_amenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Social_amenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Social_amenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Social_amenitiesAggregateArgs>(args: Subset<T, Social_amenitiesAggregateArgs>): Prisma.PrismaPromise<GetSocial_amenitiesAggregateType<T>>

    /**
     * Group by Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends social_amenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: social_amenitiesGroupByArgs['orderBy'] }
        : { orderBy?: social_amenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, social_amenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocial_amenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the social_amenities model
   */
  readonly fields: social_amenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for social_amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__social_amenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the social_amenities model
   */
  interface social_amenitiesFieldRefs {
    readonly id: FieldRef<"social_amenities", 'String'>
    readonly siteId: FieldRef<"social_amenities", 'Int'>
    readonly name: FieldRef<"social_amenities", 'String'>
    readonly description: FieldRef<"social_amenities", 'String'>
    readonly status: FieldRef<"social_amenities", 'String'>
    readonly hours: FieldRef<"social_amenities", 'String'>
    readonly rules: FieldRef<"social_amenities", 'String'>
    readonly extra: FieldRef<"social_amenities", 'String'>
    readonly createdAt: FieldRef<"social_amenities", 'DateTime'>
    readonly updatedAt: FieldRef<"social_amenities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * social_amenities findUnique
   */
  export type social_amenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities findUniqueOrThrow
   */
  export type social_amenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities findFirst
   */
  export type social_amenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_amenities.
     */
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities findFirstOrThrow
   */
  export type social_amenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_amenities.
     */
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities findMany
   */
  export type social_amenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities create
   */
  export type social_amenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a social_amenities.
     */
    data: XOR<social_amenitiesCreateInput, social_amenitiesUncheckedCreateInput>
  }

  /**
   * social_amenities createMany
   */
  export type social_amenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many social_amenities.
     */
    data: social_amenitiesCreateManyInput | social_amenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * social_amenities createManyAndReturn
   */
  export type social_amenitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * The data used to create many social_amenities.
     */
    data: social_amenitiesCreateManyInput | social_amenitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_amenities update
   */
  export type social_amenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a social_amenities.
     */
    data: XOR<social_amenitiesUpdateInput, social_amenitiesUncheckedUpdateInput>
    /**
     * Choose, which social_amenities to update.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities updateMany
   */
  export type social_amenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update social_amenities.
     */
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which social_amenities to update
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to update.
     */
    limit?: number
  }

  /**
   * social_amenities updateManyAndReturn
   */
  export type social_amenitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * The data used to update social_amenities.
     */
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which social_amenities to update
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_amenities upsert
   */
  export type social_amenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the social_amenities to update in case it exists.
     */
    where: social_amenitiesWhereUniqueInput
    /**
     * In case the social_amenities found by the `where` argument doesn't exist, create a new social_amenities with this data.
     */
    create: XOR<social_amenitiesCreateInput, social_amenitiesUncheckedCreateInput>
    /**
     * In case the social_amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<social_amenitiesUpdateInput, social_amenitiesUncheckedUpdateInput>
  }

  /**
   * social_amenities delete
   */
  export type social_amenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter which social_amenities to delete.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities deleteMany
   */
  export type social_amenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_amenities to delete
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to delete.
     */
    limit?: number
  }

  /**
   * social_amenities without action
   */
  export type social_amenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    full_name: number
    phone_number: number
    password: number
    apartment_no: number
    created_at: number
    updated_at: number
    siteId: number
    code_expiry: number
    phone_verification_code: number
    reset_code: number
    reset_code_expiry: number
    account_status: number
    deleted_at: number
    last_login: number
    plates: number
    resident_count: number
    resident_type: number
    block_id: number
    is_password_set: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    full_name: string
    phone_number: string
    password: string | null
    apartment_no: string | null
    created_at: Date
    updated_at: Date
    siteId: number
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    complaints?: boolean | users$complaintsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "phone_number" | "password" | "apartment_no" | "created_at" | "updated_at" | "siteId" | "code_expiry" | "phone_verification_code" | "reset_code" | "reset_code_expiry" | "account_status" | "deleted_at" | "last_login" | "plates" | "resident_count" | "resident_type" | "block_id" | "is_password_set", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | users$complaintsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | users$blocksArgs<ExtArgs>
    sites?: boolean | sitesDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      complaints: Prisma.$complaintsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs> | null
      sites: Prisma.$sitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      phone_number: string
      password: string | null
      apartment_no: string | null
      created_at: Date
      updated_at: Date
      siteId: number
      code_expiry: Date | null
      phone_verification_code: string | null
      reset_code: string | null
      reset_code_expiry: Date | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
      plates: string | null
      resident_count: number | null
      resident_type: $Enums.ResidentType | null
      block_id: number | null
      is_password_set: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends users$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, users$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends users$blocksArgs<ExtArgs> = {}>(args?: Subset<T, users$blocksArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sites<T extends sitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sitesDefaultArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly full_name: FieldRef<"users", 'String'>
    readonly phone_number: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly apartment_no: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly siteId: FieldRef<"users", 'Int'>
    readonly code_expiry: FieldRef<"users", 'DateTime'>
    readonly phone_verification_code: FieldRef<"users", 'String'>
    readonly reset_code: FieldRef<"users", 'String'>
    readonly reset_code_expiry: FieldRef<"users", 'DateTime'>
    readonly account_status: FieldRef<"users", 'AccountStatus'>
    readonly deleted_at: FieldRef<"users", 'DateTime'>
    readonly last_login: FieldRef<"users", 'DateTime'>
    readonly plates: FieldRef<"users", 'String'>
    readonly resident_count: FieldRef<"users", 'Int'>
    readonly resident_type: FieldRef<"users", 'ResidentType'>
    readonly block_id: FieldRef<"users", 'Int'>
    readonly is_password_set: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.complaints
   */
  export type users$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints
     */
    omit?: complaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.blocks
   */
  export type users$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminsScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password: 'password',
    account_type: 'account_type',
    company_name: 'company_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    tokenExpiry: 'tokenExpiry',
    verificationToken: 'verificationToken',
    is_verified: 'is_verified',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    start_date: 'start_date',
    end_date: 'end_date'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const BlocksScalarFieldEnum: {
    id: 'id',
    block_name: 'block_name',
    site_id: 'site_id',
    created_at: 'created_at'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    company_code: 'company_code',
    account_status: 'account_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    manager_id: 'manager_id'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Company_employeesScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    company_id: 'company_id',
    joined_at: 'joined_at',
    status: 'status'
  };

  export type Company_employeesScalarFieldEnum = (typeof Company_employeesScalarFieldEnum)[keyof typeof Company_employeesScalarFieldEnum]


  export const ComplaintsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    status: 'status',
    siteId: 'siteId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    category: 'category'
  };

  export type ComplaintsScalarFieldEnum = (typeof ComplaintsScalarFieldEnum)[keyof typeof ComplaintsScalarFieldEnum]


  export const Employee_site_accessScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    site_id: 'site_id',
    granted_at: 'granted_at'
  };

  export type Employee_site_accessScalarFieldEnum = (typeof Employee_site_accessScalarFieldEnum)[keyof typeof Employee_site_accessScalarFieldEnum]


  export const InvitationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    invite_code: 'invite_code',
    invite_link: 'invite_link',
    invited_email: 'invited_email',
    invited_by: 'invited_by',
    status: 'status',
    expires_at: 'expires_at',
    used_at: 'used_at',
    used_by: 'used_by',
    created_at: 'created_at'
  };

  export type InvitationsScalarFieldEnum = (typeof InvitationsScalarFieldEnum)[keyof typeof InvitationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    description: 'description',
    created_at: 'created_at',
    userId: 'userId',
    siteId: 'siteId'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const SitesScalarFieldEnum: {
    id: 'id',
    site_id: 'site_id',
    site_name: 'site_name',
    site_address: 'site_address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    adminId: 'adminId',
    apartment_count: 'apartment_count',
    block_count: 'block_count',
    company_id: 'company_id',
    deleted_at: 'deleted_at',
    site_status: 'site_status'
  };

  export type SitesScalarFieldEnum = (typeof SitesScalarFieldEnum)[keyof typeof SitesScalarFieldEnum]


  export const Social_amenitiesScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    description: 'description',
    status: 'status',
    hours: 'hours',
    rules: 'rules',
    extra: 'extra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Social_amenitiesScalarFieldEnum = (typeof Social_amenitiesScalarFieldEnum)[keyof typeof Social_amenitiesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone_number: 'phone_number',
    password: 'password',
    apartment_no: 'apartment_no',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    code_expiry: 'code_expiry',
    phone_verification_code: 'phone_verification_code',
    reset_code: 'reset_code',
    reset_code_expiry: 'reset_code_expiry',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login',
    plates: 'plates',
    resident_count: 'resident_count',
    resident_type: 'resident_type',
    block_id: 'block_id',
    is_password_set: 'is_password_set'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'ResidentType'
   */
  export type EnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType'>
    


  /**
   * Reference to a field of type 'ResidentType[]'
   */
  export type ListEnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType[]'>
    
  /**
   * Deep Input Types
   */


  export type adminsWhereInput = {
    AND?: adminsWhereInput | adminsWhereInput[]
    OR?: adminsWhereInput[]
    NOT?: adminsWhereInput | adminsWhereInput[]
    id?: IntFilter<"admins"> | number
    full_name?: StringFilter<"admins"> | string
    email?: StringFilter<"admins"> | string
    password?: StringFilter<"admins"> | string
    account_type?: EnumAccountTypeFilter<"admins"> | $Enums.AccountType
    company_name?: StringNullableFilter<"admins"> | string | null
    created_at?: DateTimeFilter<"admins"> | Date | string
    updated_at?: DateTimeFilter<"admins"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"admins"> | Date | string | null
    verificationToken?: StringNullableFilter<"admins"> | string | null
    is_verified?: BoolFilter<"admins"> | boolean
    resetToken?: StringNullableFilter<"admins"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"admins"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"admins"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"admins"> | Date | string | null
    last_login?: DateTimeNullableFilter<"admins"> | Date | string | null
    companies?: CompaniesListRelationFilter
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    sites?: SitesListRelationFilter
  }

  export type adminsOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    companies?: companiesOrderByRelationAggregateInput
    company_employees?: company_employeesOrderByWithRelationInput
    sites?: sitesOrderByRelationAggregateInput
  }

  export type adminsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    verificationToken?: string
    AND?: adminsWhereInput | adminsWhereInput[]
    OR?: adminsWhereInput[]
    NOT?: adminsWhereInput | adminsWhereInput[]
    full_name?: StringFilter<"admins"> | string
    password?: StringFilter<"admins"> | string
    account_type?: EnumAccountTypeFilter<"admins"> | $Enums.AccountType
    company_name?: StringNullableFilter<"admins"> | string | null
    created_at?: DateTimeFilter<"admins"> | Date | string
    updated_at?: DateTimeFilter<"admins"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"admins"> | Date | string | null
    is_verified?: BoolFilter<"admins"> | boolean
    resetToken?: StringNullableFilter<"admins"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"admins"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"admins"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"admins"> | Date | string | null
    last_login?: DateTimeNullableFilter<"admins"> | Date | string | null
    companies?: CompaniesListRelationFilter
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    sites?: SitesListRelationFilter
  }, "id" | "email" | "verificationToken">

  export type adminsOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    _count?: adminsCountOrderByAggregateInput
    _avg?: adminsAvgOrderByAggregateInput
    _max?: adminsMaxOrderByAggregateInput
    _min?: adminsMinOrderByAggregateInput
    _sum?: adminsSumOrderByAggregateInput
  }

  export type adminsScalarWhereWithAggregatesInput = {
    AND?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[]
    OR?: adminsScalarWhereWithAggregatesInput[]
    NOT?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admins"> | number
    full_name?: StringWithAggregatesFilter<"admins"> | string
    email?: StringWithAggregatesFilter<"admins"> | string
    password?: StringWithAggregatesFilter<"admins"> | string
    account_type?: EnumAccountTypeWithAggregatesFilter<"admins"> | $Enums.AccountType
    company_name?: StringNullableWithAggregatesFilter<"admins"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"admins"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"admins"> | Date | string
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"admins"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"admins"> | string | null
    is_verified?: BoolWithAggregatesFilter<"admins"> | boolean
    resetToken?: StringNullableWithAggregatesFilter<"admins"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"admins"> | Date | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"admins"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"admins"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"admins"> | Date | string | null
  }

  export type announcementsWhereInput = {
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    id?: IntFilter<"announcements"> | number
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }

  export type announcementsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    sites?: sitesOrderByWithRelationInput
  }

  export type announcementsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }, "id">

  export type announcementsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    _count?: announcementsCountOrderByAggregateInput
    _avg?: announcementsAvgOrderByAggregateInput
    _max?: announcementsMaxOrderByAggregateInput
    _min?: announcementsMinOrderByAggregateInput
    _sum?: announcementsSumOrderByAggregateInput
  }

  export type announcementsScalarWhereWithAggregatesInput = {
    AND?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    OR?: announcementsScalarWhereWithAggregatesInput[]
    NOT?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"announcements"> | number
    title?: StringWithAggregatesFilter<"announcements"> | string
    content?: StringWithAggregatesFilter<"announcements"> | string
    created_at?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    siteId?: IntWithAggregatesFilter<"announcements"> | number
    start_date?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
  }

  export type blocksWhereInput = {
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
    users?: UsersListRelationFilter
  }

  export type blocksOrderByWithRelationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    sites?: sitesOrderByWithRelationInput
    users?: usersOrderByRelationAggregateInput
  }

  export type blocksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id_block_name?: blocksSite_idBlock_nameCompoundUniqueInput
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
    users?: UsersListRelationFilter
  }, "id" | "site_id_block_name">

  export type blocksOrderByWithAggregationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    OR?: blocksScalarWhereWithAggregatesInput[]
    NOT?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"blocks"> | number
    block_name?: StringWithAggregatesFilter<"blocks"> | string
    site_id?: IntWithAggregatesFilter<"blocks"> | number
    created_at?: DateTimeWithAggregatesFilter<"blocks"> | Date | string
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: IntFilter<"companies"> | number
    company_name?: StringFilter<"companies"> | string
    company_code?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
    admins?: XOR<AdminsScalarRelationFilter, adminsWhereInput>
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SitesListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    manager_id?: SortOrder
    admins?: adminsOrderByWithRelationInput
    company_employees?: company_employeesOrderByRelationAggregateInput
    invitations?: invitationsOrderByRelationAggregateInput
    sites?: sitesOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    company_code?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    company_name?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
    admins?: XOR<AdminsScalarRelationFilter, adminsWhereInput>
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SitesListRelationFilter
  }, "id" | "company_code">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    manager_id?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companies"> | number
    company_name?: StringWithAggregatesFilter<"companies"> | string
    company_code?: StringWithAggregatesFilter<"companies"> | string
    account_status?: EnumAccountStatusWithAggregatesFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    manager_id?: IntWithAggregatesFilter<"companies"> | number
  }

  export type company_employeesWhereInput = {
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    admins?: XOR<AdminsScalarRelationFilter, adminsWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }

  export type company_employeesOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    admins?: adminsOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
  }

  export type company_employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    admin_id?: number
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    admins?: XOR<AdminsScalarRelationFilter, adminsWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }, "id" | "admin_id">

  export type company_employeesOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    _count?: company_employeesCountOrderByAggregateInput
    _avg?: company_employeesAvgOrderByAggregateInput
    _max?: company_employeesMaxOrderByAggregateInput
    _min?: company_employeesMinOrderByAggregateInput
    _sum?: company_employeesSumOrderByAggregateInput
  }

  export type company_employeesScalarWhereWithAggregatesInput = {
    AND?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    OR?: company_employeesScalarWhereWithAggregatesInput[]
    NOT?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"company_employees"> | number
    admin_id?: IntWithAggregatesFilter<"company_employees"> | number
    company_id?: IntWithAggregatesFilter<"company_employees"> | number
    joined_at?: DateTimeWithAggregatesFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusWithAggregatesFilter<"company_employees"> | $Enums.AccountStatus
  }

  export type complaintsWhereInput = {
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    id?: IntFilter<"complaints"> | number
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type complaintsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    sites?: sitesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type complaintsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type complaintsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: complaintsCountOrderByAggregateInput
    _avg?: complaintsAvgOrderByAggregateInput
    _max?: complaintsMaxOrderByAggregateInput
    _min?: complaintsMinOrderByAggregateInput
    _sum?: complaintsSumOrderByAggregateInput
  }

  export type complaintsScalarWhereWithAggregatesInput = {
    AND?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    OR?: complaintsScalarWhereWithAggregatesInput[]
    NOT?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"complaints"> | number
    title?: StringWithAggregatesFilter<"complaints"> | string
    content?: StringWithAggregatesFilter<"complaints"> | string
    status?: EnumStatusWithAggregatesFilter<"complaints"> | $Enums.Status
    siteId?: IntWithAggregatesFilter<"complaints"> | number
    userId?: IntWithAggregatesFilter<"complaints"> | number
    created_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableWithAggregatesFilter<"complaints"> | $Enums.Category | null
  }

  export type employee_site_accessWhereInput = {
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }

  export type employee_site_accessOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    company_employees?: company_employeesOrderByWithRelationInput
    sites?: sitesOrderByWithRelationInput
  }

  export type employee_site_accessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employee_id_site_id?: employee_site_accessEmployee_idSite_idCompoundUniqueInput
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }, "id" | "employee_id_site_id">

  export type employee_site_accessOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    _count?: employee_site_accessCountOrderByAggregateInput
    _avg?: employee_site_accessAvgOrderByAggregateInput
    _max?: employee_site_accessMaxOrderByAggregateInput
    _min?: employee_site_accessMinOrderByAggregateInput
    _sum?: employee_site_accessSumOrderByAggregateInput
  }

  export type employee_site_accessScalarWhereWithAggregatesInput = {
    AND?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    OR?: employee_site_accessScalarWhereWithAggregatesInput[]
    NOT?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employee_site_access"> | number
    employee_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    site_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    granted_at?: DateTimeWithAggregatesFilter<"employee_site_access"> | Date | string
  }

  export type invitationsWhereInput = {
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type invitationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type invitationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invite_code?: string
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    company_id?: IntFilter<"invitations"> | number
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id" | "invite_code">

  export type invitationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: invitationsCountOrderByAggregateInput
    _avg?: invitationsAvgOrderByAggregateInput
    _max?: invitationsMaxOrderByAggregateInput
    _min?: invitationsMinOrderByAggregateInput
    _sum?: invitationsSumOrderByAggregateInput
  }

  export type invitationsScalarWhereWithAggregatesInput = {
    AND?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    OR?: invitationsScalarWhereWithAggregatesInput[]
    NOT?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"invitations"> | number
    company_id?: IntWithAggregatesFilter<"invitations"> | number
    invite_code?: StringWithAggregatesFilter<"invitations"> | string
    invite_link?: StringWithAggregatesFilter<"invitations"> | string
    invited_email?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    invited_by?: IntWithAggregatesFilter<"invitations"> | number
    status?: EnumInvitationStatusWithAggregatesFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"invitations"> | Date | string | null
    used_by?: IntNullableWithAggregatesFilter<"invitations"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    amount?: FloatWithAggregatesFilter<"payments"> | number
    payment_date?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    userId?: IntWithAggregatesFilter<"payments"> | number
    siteId?: IntWithAggregatesFilter<"payments"> | number
  }

  export type sitesWhereInput = {
    AND?: sitesWhereInput | sitesWhereInput[]
    OR?: sitesWhereInput[]
    NOT?: sitesWhereInput | sitesWhereInput[]
    id?: IntFilter<"sites"> | number
    site_id?: StringFilter<"sites"> | string
    site_name?: StringFilter<"sites"> | string
    site_address?: StringFilter<"sites"> | string
    created_at?: DateTimeFilter<"sites"> | Date | string
    updated_at?: DateTimeFilter<"sites"> | Date | string
    adminId?: IntNullableFilter<"sites"> | number | null
    apartment_count?: IntNullableFilter<"sites"> | number | null
    block_count?: IntNullableFilter<"sites"> | number | null
    company_id?: IntNullableFilter<"sites"> | number | null
    deleted_at?: DateTimeNullableFilter<"sites"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"sites"> | $Enums.AccountStatus
    announcements?: AnnouncementsListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintsListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    admins?: XOR<AdminsNullableScalarRelationFilter, adminsWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    social_amenities?: Social_amenitiesListRelationFilter
    users?: UsersListRelationFilter
  }

  export type sitesOrderByWithRelationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    announcements?: announcementsOrderByRelationAggregateInput
    blocks?: blocksOrderByRelationAggregateInput
    complaints?: complaintsOrderByRelationAggregateInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
    admins?: adminsOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    social_amenities?: social_amenitiesOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type sitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id?: string
    AND?: sitesWhereInput | sitesWhereInput[]
    OR?: sitesWhereInput[]
    NOT?: sitesWhereInput | sitesWhereInput[]
    site_name?: StringFilter<"sites"> | string
    site_address?: StringFilter<"sites"> | string
    created_at?: DateTimeFilter<"sites"> | Date | string
    updated_at?: DateTimeFilter<"sites"> | Date | string
    adminId?: IntNullableFilter<"sites"> | number | null
    apartment_count?: IntNullableFilter<"sites"> | number | null
    block_count?: IntNullableFilter<"sites"> | number | null
    company_id?: IntNullableFilter<"sites"> | number | null
    deleted_at?: DateTimeNullableFilter<"sites"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"sites"> | $Enums.AccountStatus
    announcements?: AnnouncementsListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintsListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    admins?: XOR<AdminsNullableScalarRelationFilter, adminsWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    social_amenities?: Social_amenitiesListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "site_id">

  export type sitesOrderByWithAggregationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    _count?: sitesCountOrderByAggregateInput
    _avg?: sitesAvgOrderByAggregateInput
    _max?: sitesMaxOrderByAggregateInput
    _min?: sitesMinOrderByAggregateInput
    _sum?: sitesSumOrderByAggregateInput
  }

  export type sitesScalarWhereWithAggregatesInput = {
    AND?: sitesScalarWhereWithAggregatesInput | sitesScalarWhereWithAggregatesInput[]
    OR?: sitesScalarWhereWithAggregatesInput[]
    NOT?: sitesScalarWhereWithAggregatesInput | sitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sites"> | number
    site_id?: StringWithAggregatesFilter<"sites"> | string
    site_name?: StringWithAggregatesFilter<"sites"> | string
    site_address?: StringWithAggregatesFilter<"sites"> | string
    created_at?: DateTimeWithAggregatesFilter<"sites"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"sites"> | Date | string
    adminId?: IntNullableWithAggregatesFilter<"sites"> | number | null
    apartment_count?: IntNullableWithAggregatesFilter<"sites"> | number | null
    block_count?: IntNullableWithAggregatesFilter<"sites"> | number | null
    company_id?: IntNullableWithAggregatesFilter<"sites"> | number | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"sites"> | Date | string | null
    site_status?: EnumAccountStatusWithAggregatesFilter<"sites"> | $Enums.AccountStatus
  }

  export type social_amenitiesWhereInput = {
    AND?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    OR?: social_amenitiesWhereInput[]
    NOT?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    id?: StringFilter<"social_amenities"> | string
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }

  export type social_amenitiesOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sites?: sitesOrderByWithRelationInput
  }

  export type social_amenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    OR?: social_amenitiesWhereInput[]
    NOT?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }, "id">

  export type social_amenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: social_amenitiesCountOrderByAggregateInput
    _avg?: social_amenitiesAvgOrderByAggregateInput
    _max?: social_amenitiesMaxOrderByAggregateInput
    _min?: social_amenitiesMinOrderByAggregateInput
    _sum?: social_amenitiesSumOrderByAggregateInput
  }

  export type social_amenitiesScalarWhereWithAggregatesInput = {
    AND?: social_amenitiesScalarWhereWithAggregatesInput | social_amenitiesScalarWhereWithAggregatesInput[]
    OR?: social_amenitiesScalarWhereWithAggregatesInput[]
    NOT?: social_amenitiesScalarWhereWithAggregatesInput | social_amenitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"social_amenities"> | string
    siteId?: IntWithAggregatesFilter<"social_amenities"> | number
    name?: StringWithAggregatesFilter<"social_amenities"> | string
    description?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    status?: StringWithAggregatesFilter<"social_amenities"> | string
    hours?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    rules?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    extra?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"social_amenities"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    full_name?: StringFilter<"users"> | string
    phone_number?: StringFilter<"users"> | string
    password?: StringNullableFilter<"users"> | string | null
    apartment_no?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    siteId?: IntFilter<"users"> | number
    code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"users"> | string | null
    reset_code?: StringNullableFilter<"users"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"users"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    plates?: StringNullableFilter<"users"> | string | null
    resident_count?: IntNullableFilter<"users"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"users"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"users"> | number | null
    is_password_set?: BoolFilter<"users"> | boolean
    complaints?: ComplaintsListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    complaints?: complaintsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    blocks?: blocksOrderByWithRelationInput
    sites?: sitesOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone_number?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    full_name?: StringFilter<"users"> | string
    password?: StringNullableFilter<"users"> | string | null
    apartment_no?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    siteId?: IntFilter<"users"> | number
    code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"users"> | string | null
    reset_code?: StringNullableFilter<"users"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"users"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    plates?: StringNullableFilter<"users"> | string | null
    resident_count?: IntNullableFilter<"users"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"users"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"users"> | number | null
    is_password_set?: BoolFilter<"users"> | boolean
    complaints?: ComplaintsListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    sites?: XOR<SitesScalarRelationFilter, sitesWhereInput>
  }, "id" | "phone_number">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    full_name?: StringWithAggregatesFilter<"users"> | string
    phone_number?: StringWithAggregatesFilter<"users"> | string
    password?: StringNullableWithAggregatesFilter<"users"> | string | null
    apartment_no?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    siteId?: IntWithAggregatesFilter<"users"> | number
    code_expiry?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    phone_verification_code?: StringNullableWithAggregatesFilter<"users"> | string | null
    reset_code?: StringNullableWithAggregatesFilter<"users"> | string | null
    reset_code_expiry?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"users"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    plates?: StringNullableWithAggregatesFilter<"users"> | string | null
    resident_count?: IntNullableWithAggregatesFilter<"users"> | number | null
    resident_type?: EnumResidentTypeNullableWithAggregatesFilter<"users"> | $Enums.ResidentType | null
    block_id?: IntNullableWithAggregatesFilter<"users"> | number | null
    is_password_set?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type adminsCreateInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    sites?: sitesCreateNestedManyWithoutAdminsInput
  }

  export type adminsUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    sites?: sitesUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type adminsUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    sites?: sitesUpdateManyWithoutAdminsNestedInput
  }

  export type adminsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    sites?: sitesUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type adminsCreateManyInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
  }

  export type adminsUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementsCreateInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
    sites: sitesCreateNestedOneWithoutAnnouncementsInput
  }

  export type announcementsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: sitesUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type announcementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateManyInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksCreateInput = {
    block_name: string
    created_at?: Date | string
    sites: sitesCreateNestedOneWithoutBlocksInput
    users?: usersCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
    users?: usersUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksUpdateInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: sitesUpdateOneRequiredWithoutBlocksNestedInput
    users?: usersUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksCreateManyInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
  }

  export type blocksUpdateManyMutationInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesCreateInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: adminsCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: sitesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: sitesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: adminsUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
  }

  export type companiesUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
  }

  export type company_employeesCreateInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: adminsCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUpdateInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: adminsUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesCreateManyInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type company_employeesUpdateManyMutationInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type company_employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type complaintsCreateInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
    sites: sitesCreateNestedOneWithoutComplaintsInput
    users: usersCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sites?: sitesUpdateOneRequiredWithoutComplaintsNestedInput
    users?: usersUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsCreateManyInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type employee_site_accessCreateInput = {
    granted_at?: Date | string
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
    sites: sitesCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
    sites?: sitesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessCreateManyInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateManyMutationInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
    companies: companiesCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateManyInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateManyMutationInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
    users: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsCreateManyInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type sitesCreateInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesUpdateInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type sitesCreateManyInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type sitesUpdateManyMutationInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type sitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type social_amenitiesCreateInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    sites: sitesCreateNestedOneWithoutSocial_amenitiesInput
  }

  export type social_amenitiesUncheckedCreateInput = {
    id: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: sitesUpdateOneRequiredWithoutSocial_amenitiesNestedInput
  }

  export type social_amenitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesCreateManyInput = {
    id: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    sites: sitesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    sites?: sitesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
  }

  export type usersUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type Company_employeesNullableScalarRelationFilter = {
    is?: company_employeesWhereInput | null
    isNot?: company_employeesWhereInput | null
  }

  export type SitesListRelationFilter = {
    every?: sitesWhereInput
    some?: sitesWhereInput
    none?: sitesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminsCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type adminsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type adminsMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type adminsMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type adminsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type SitesScalarRelationFilter = {
    is?: sitesWhereInput
    isNot?: sitesWhereInput
  }

  export type announcementsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type announcementsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type announcementsSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blocksSite_idBlock_nameCompoundUniqueInput = {
    site_id: number
    block_name: string
  }

  export type blocksCountOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
  }

  export type AdminsScalarRelationFilter = {
    is?: adminsWhereInput
    isNot?: adminsWhereInput
  }

  export type Company_employeesListRelationFilter = {
    every?: company_employeesWhereInput
    some?: company_employeesWhereInput
    none?: company_employeesWhereInput
  }

  export type InvitationsListRelationFilter = {
    every?: invitationsWhereInput
    some?: invitationsWhereInput
    none?: invitationsWhereInput
  }

  export type company_employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invitationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type Employee_site_accessListRelationFilter = {
    every?: employee_site_accessWhereInput
    some?: employee_site_accessWhereInput
    none?: employee_site_accessWhereInput
  }

  export type employee_site_accessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_employeesCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type company_employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type complaintsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type complaintsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type complaintsSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type Company_employeesScalarRelationFilter = {
    is?: company_employeesWhereInput
    isNot?: company_employeesWhereInput
  }

  export type employee_site_accessEmployee_idSite_idCompoundUniqueInput = {
    employee_id: number
    site_id: number
  }

  export type employee_site_accessCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type employee_site_accessMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type invitationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type invitationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type AnnouncementsListRelationFilter = {
    every?: announcementsWhereInput
    some?: announcementsWhereInput
    none?: announcementsWhereInput
  }

  export type BlocksListRelationFilter = {
    every?: blocksWhereInput
    some?: blocksWhereInput
    none?: blocksWhereInput
  }

  export type ComplaintsListRelationFilter = {
    every?: complaintsWhereInput
    some?: complaintsWhereInput
    none?: complaintsWhereInput
  }

  export type AdminsNullableScalarRelationFilter = {
    is?: adminsWhereInput | null
    isNot?: adminsWhereInput | null
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type Social_amenitiesListRelationFilter = {
    every?: social_amenitiesWhereInput
    some?: social_amenitiesWhereInput
    none?: social_amenitiesWhereInput
  }

  export type announcementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type complaintsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type social_amenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sitesCountOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type sitesAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type sitesMaxOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type sitesMinOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type sitesSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type social_amenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesAvgOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type social_amenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesSumOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type EnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type BlocksNullableScalarRelationFilter = {
    is?: blocksWhereInput | null
    isNot?: blocksWhereInput | null
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type EnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type companiesCreateNestedManyWithoutAdminsInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type company_employeesCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type sitesCreateNestedManyWithoutAdminsInput = {
    create?: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput> | sitesCreateWithoutAdminsInput[] | sitesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutAdminsInput | sitesCreateOrConnectWithoutAdminsInput[]
    createMany?: sitesCreateManyAdminsInputEnvelope
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type sitesUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput> | sitesCreateWithoutAdminsInput[] | sitesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutAdminsInput | sitesCreateOrConnectWithoutAdminsInput[]
    createMany?: sitesCreateManyAdminsInputEnvelope
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type companiesUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutAdminsInput | companiesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutAdminsInput | companiesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutAdminsInput | companiesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type company_employeesUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type sitesUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput> | sitesCreateWithoutAdminsInput[] | sitesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutAdminsInput | sitesCreateOrConnectWithoutAdminsInput[]
    upsert?: sitesUpsertWithWhereUniqueWithoutAdminsInput | sitesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: sitesCreateManyAdminsInputEnvelope
    set?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    disconnect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    delete?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    update?: sitesUpdateWithWhereUniqueWithoutAdminsInput | sitesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: sitesUpdateManyWithWhereWithoutAdminsInput | sitesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: sitesScalarWhereInput | sitesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companiesUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutAdminsInput | companiesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutAdminsInput | companiesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutAdminsInput | companiesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type sitesUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput> | sitesCreateWithoutAdminsInput[] | sitesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutAdminsInput | sitesCreateOrConnectWithoutAdminsInput[]
    upsert?: sitesUpsertWithWhereUniqueWithoutAdminsInput | sitesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: sitesCreateManyAdminsInputEnvelope
    set?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    disconnect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    delete?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    update?: sitesUpdateWithWhereUniqueWithoutAdminsInput | sitesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: sitesUpdateManyWithWhereWithoutAdminsInput | sitesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: sitesScalarWhereInput | sitesScalarWhereInput[]
  }

  export type sitesCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<sitesCreateWithoutAnnouncementsInput, sitesUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: sitesCreateOrConnectWithoutAnnouncementsInput
    connect?: sitesWhereUniqueInput
  }

  export type sitesUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<sitesCreateWithoutAnnouncementsInput, sitesUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: sitesCreateOrConnectWithoutAnnouncementsInput
    upsert?: sitesUpsertWithoutAnnouncementsInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutAnnouncementsInput, sitesUpdateWithoutAnnouncementsInput>, sitesUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type sitesCreateNestedOneWithoutBlocksInput = {
    create?: XOR<sitesCreateWithoutBlocksInput, sitesUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: sitesCreateOrConnectWithoutBlocksInput
    connect?: sitesWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutBlocksInput = {
    create?: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput> | usersCreateWithoutBlocksInput[] | usersUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBlocksInput | usersCreateOrConnectWithoutBlocksInput[]
    createMany?: usersCreateManyBlocksInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutBlocksInput = {
    create?: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput> | usersCreateWithoutBlocksInput[] | usersUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBlocksInput | usersCreateOrConnectWithoutBlocksInput[]
    createMany?: usersCreateManyBlocksInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type sitesUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<sitesCreateWithoutBlocksInput, sitesUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: sitesCreateOrConnectWithoutBlocksInput
    upsert?: sitesUpsertWithoutBlocksInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutBlocksInput, sitesUpdateWithoutBlocksInput>, sitesUncheckedUpdateWithoutBlocksInput>
  }

  export type usersUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput> | usersCreateWithoutBlocksInput[] | usersUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBlocksInput | usersCreateOrConnectWithoutBlocksInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBlocksInput | usersUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: usersCreateManyBlocksInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBlocksInput | usersUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBlocksInput | usersUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput> | usersCreateWithoutBlocksInput[] | usersUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBlocksInput | usersCreateOrConnectWithoutBlocksInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBlocksInput | usersUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: usersCreateManyBlocksInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBlocksInput | usersUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBlocksInput | usersUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type adminsCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<adminsCreateWithoutCompaniesInput, adminsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutCompaniesInput
    connect?: adminsWhereUniqueInput
  }

  export type company_employeesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type sitesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput> | sitesCreateWithoutCompaniesInput[] | sitesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutCompaniesInput | sitesCreateOrConnectWithoutCompaniesInput[]
    createMany?: sitesCreateManyCompaniesInputEnvelope
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type sitesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput> | sitesCreateWithoutCompaniesInput[] | sitesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutCompaniesInput | sitesCreateOrConnectWithoutCompaniesInput[]
    createMany?: sitesCreateManyCompaniesInputEnvelope
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
  }

  export type adminsUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<adminsCreateWithoutCompaniesInput, adminsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutCompaniesInput
    upsert?: adminsUpsertWithoutCompaniesInput
    connect?: adminsWhereUniqueInput
    update?: XOR<XOR<adminsUpdateToOneWithWhereWithoutCompaniesInput, adminsUpdateWithoutCompaniesInput>, adminsUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_employeesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type sitesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput> | sitesCreateWithoutCompaniesInput[] | sitesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutCompaniesInput | sitesCreateOrConnectWithoutCompaniesInput[]
    upsert?: sitesUpsertWithWhereUniqueWithoutCompaniesInput | sitesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: sitesCreateManyCompaniesInputEnvelope
    set?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    disconnect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    delete?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    update?: sitesUpdateWithWhereUniqueWithoutCompaniesInput | sitesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: sitesUpdateManyWithWhereWithoutCompaniesInput | sitesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: sitesScalarWhereInput | sitesScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type sitesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput> | sitesCreateWithoutCompaniesInput[] | sitesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: sitesCreateOrConnectWithoutCompaniesInput | sitesCreateOrConnectWithoutCompaniesInput[]
    upsert?: sitesUpsertWithWhereUniqueWithoutCompaniesInput | sitesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: sitesCreateManyCompaniesInputEnvelope
    set?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    disconnect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    delete?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    connect?: sitesWhereUniqueInput | sitesWhereUniqueInput[]
    update?: sitesUpdateWithWhereUniqueWithoutCompaniesInput | sitesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: sitesUpdateManyWithWhereWithoutCompaniesInput | sitesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: sitesScalarWhereInput | sitesScalarWhereInput[]
  }

  export type adminsCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<adminsCreateWithoutCompany_employeesInput, adminsUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutCompany_employeesInput
    connect?: adminsWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
  }

  export type employee_site_accessCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type adminsUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<adminsCreateWithoutCompany_employeesInput, adminsUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutCompany_employeesInput
    upsert?: adminsUpsertWithoutCompany_employeesInput
    connect?: adminsWhereUniqueInput
    update?: XOR<XOR<adminsUpdateToOneWithWhereWithoutCompany_employeesInput, adminsUpdateWithoutCompany_employeesInput>, adminsUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    upsert?: companiesUpsertWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_employeesInput, companiesUpdateWithoutCompany_employeesInput>, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type sitesCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<sitesCreateWithoutComplaintsInput, sitesUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: sitesCreateOrConnectWithoutComplaintsInput
    connect?: sitesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<usersCreateWithoutComplaintsInput, usersUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: usersCreateOrConnectWithoutComplaintsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type sitesUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<sitesCreateWithoutComplaintsInput, sitesUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: sitesCreateOrConnectWithoutComplaintsInput
    upsert?: sitesUpsertWithoutComplaintsInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutComplaintsInput, sitesUpdateWithoutComplaintsInput>, sitesUncheckedUpdateWithoutComplaintsInput>
  }

  export type usersUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<usersCreateWithoutComplaintsInput, usersUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: usersCreateOrConnectWithoutComplaintsInput
    upsert?: usersUpsertWithoutComplaintsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutComplaintsInput, usersUpdateWithoutComplaintsInput>, usersUncheckedUpdateWithoutComplaintsInput>
  }

  export type company_employeesCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
  }

  export type sitesCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<sitesCreateWithoutEmployee_site_accessInput, sitesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: sitesCreateOrConnectWithoutEmployee_site_accessInput
    connect?: sitesWhereUniqueInput
  }

  export type company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: company_employeesUpsertWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput, company_employeesUpdateWithoutEmployee_site_accessInput>, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type sitesUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<sitesCreateWithoutEmployee_site_accessInput, sitesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: sitesCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: sitesUpsertWithoutEmployee_site_accessInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutEmployee_site_accessInput, sitesUpdateWithoutEmployee_site_accessInput>, sitesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type companiesCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companiesUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    upsert?: companiesUpsertWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutInvitationsInput, companiesUpdateWithoutInvitationsInput>, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type usersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type announcementsCreateNestedManyWithoutSitesInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
  }

  export type blocksCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type complaintsCreateNestedManyWithoutSitesInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type employee_site_accessCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type adminsCreateNestedOneWithoutSitesInput = {
    create?: XOR<adminsCreateWithoutSitesInput, adminsUncheckedCreateWithoutSitesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutSitesInput
    connect?: adminsWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutSitesInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    connect?: companiesWhereUniqueInput
  }

  export type social_amenitiesCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutSitesInput = {
    create?: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput> | usersCreateWithoutSitesInput[] | usersUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutSitesInput | usersCreateOrConnectWithoutSitesInput[]
    createMany?: usersCreateManySitesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type announcementsUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
  }

  export type blocksUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type complaintsUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type social_amenitiesUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput> | usersCreateWithoutSitesInput[] | usersUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutSitesInput | usersCreateOrConnectWithoutSitesInput[]
    createMany?: usersCreateManySitesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type announcementsUpdateManyWithoutSitesNestedInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    upsert?: announcementsUpsertWithWhereUniqueWithoutSitesInput | announcementsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    set?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    disconnect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    delete?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    update?: announcementsUpdateWithWhereUniqueWithoutSitesInput | announcementsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: announcementsUpdateManyWithWhereWithoutSitesInput | announcementsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
  }

  export type blocksUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type complaintsUpdateManyWithoutSitesNestedInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutSitesInput | complaintsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutSitesInput | complaintsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutSitesInput | complaintsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type employee_site_accessUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type adminsUpdateOneWithoutSitesNestedInput = {
    create?: XOR<adminsCreateWithoutSitesInput, adminsUncheckedCreateWithoutSitesInput>
    connectOrCreate?: adminsCreateOrConnectWithoutSitesInput
    upsert?: adminsUpsertWithoutSitesInput
    disconnect?: adminsWhereInput | boolean
    delete?: adminsWhereInput | boolean
    connect?: adminsWhereUniqueInput
    update?: XOR<XOR<adminsUpdateToOneWithWhereWithoutSitesInput, adminsUpdateWithoutSitesInput>, adminsUncheckedUpdateWithoutSitesInput>
  }

  export type companiesUpdateOneWithoutSitesNestedInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    upsert?: companiesUpsertWithoutSitesInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutSitesInput, companiesUpdateWithoutSitesInput>, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type social_amenitiesUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    upsert?: social_amenitiesUpsertWithWhereUniqueWithoutSitesInput | social_amenitiesUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    set?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    disconnect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    delete?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    update?: social_amenitiesUpdateWithWhereUniqueWithoutSitesInput | social_amenitiesUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_amenitiesUpdateManyWithWhereWithoutSitesInput | social_amenitiesUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
  }

  export type usersUpdateManyWithoutSitesNestedInput = {
    create?: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput> | usersCreateWithoutSitesInput[] | usersUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutSitesInput | usersCreateOrConnectWithoutSitesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutSitesInput | usersUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: usersCreateManySitesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutSitesInput | usersUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutSitesInput | usersUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type announcementsUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput> | announcementsCreateWithoutSitesInput[] | announcementsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: announcementsCreateOrConnectWithoutSitesInput | announcementsCreateOrConnectWithoutSitesInput[]
    upsert?: announcementsUpsertWithWhereUniqueWithoutSitesInput | announcementsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: announcementsCreateManySitesInputEnvelope
    set?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    disconnect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    delete?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    connect?: announcementsWhereUniqueInput | announcementsWhereUniqueInput[]
    update?: announcementsUpdateWithWhereUniqueWithoutSitesInput | announcementsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: announcementsUpdateManyWithWhereWithoutSitesInput | announcementsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
  }

  export type blocksUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type complaintsUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput> | complaintsCreateWithoutSitesInput[] | complaintsUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutSitesInput | complaintsCreateOrConnectWithoutSitesInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutSitesInput | complaintsUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: complaintsCreateManySitesInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutSitesInput | complaintsUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutSitesInput | complaintsUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    upsert?: social_amenitiesUpsertWithWhereUniqueWithoutSitesInput | social_amenitiesUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    set?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    disconnect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    delete?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    update?: social_amenitiesUpdateWithWhereUniqueWithoutSitesInput | social_amenitiesUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_amenitiesUpdateManyWithWhereWithoutSitesInput | social_amenitiesUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput> | usersCreateWithoutSitesInput[] | usersUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutSitesInput | usersCreateOrConnectWithoutSitesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutSitesInput | usersUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: usersCreateManySitesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutSitesInput | usersUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutSitesInput | usersUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type sitesCreateNestedOneWithoutSocial_amenitiesInput = {
    create?: XOR<sitesCreateWithoutSocial_amenitiesInput, sitesUncheckedCreateWithoutSocial_amenitiesInput>
    connectOrCreate?: sitesCreateOrConnectWithoutSocial_amenitiesInput
    connect?: sitesWhereUniqueInput
  }

  export type sitesUpdateOneRequiredWithoutSocial_amenitiesNestedInput = {
    create?: XOR<sitesCreateWithoutSocial_amenitiesInput, sitesUncheckedCreateWithoutSocial_amenitiesInput>
    connectOrCreate?: sitesCreateOrConnectWithoutSocial_amenitiesInput
    upsert?: sitesUpsertWithoutSocial_amenitiesInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutSocial_amenitiesInput, sitesUpdateWithoutSocial_amenitiesInput>, sitesUncheckedUpdateWithoutSocial_amenitiesInput>
  }

  export type complaintsCreateNestedManyWithoutUsersInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type blocksCreateNestedOneWithoutUsersInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    connect?: blocksWhereUniqueInput
  }

  export type sitesCreateNestedOneWithoutUsersInput = {
    create?: XOR<sitesCreateWithoutUsersInput, sitesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: sitesCreateOrConnectWithoutUsersInput
    connect?: sitesWhereUniqueInput
  }

  export type complaintsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type NullableEnumResidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResidentType | null
  }

  export type complaintsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsersInput | complaintsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsersInput | complaintsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsersInput | complaintsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type blocksUpdateOneWithoutUsersNestedInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    upsert?: blocksUpsertWithoutUsersInput
    disconnect?: blocksWhereInput | boolean
    delete?: blocksWhereInput | boolean
    connect?: blocksWhereUniqueInput
    update?: XOR<XOR<blocksUpdateToOneWithWhereWithoutUsersInput, blocksUpdateWithoutUsersInput>, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type sitesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<sitesCreateWithoutUsersInput, sitesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: sitesCreateOrConnectWithoutUsersInput
    upsert?: sitesUpsertWithoutUsersInput
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutUsersInput, sitesUpdateWithoutUsersInput>, sitesUncheckedUpdateWithoutUsersInput>
  }

  export type complaintsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput> | complaintsCreateWithoutUsersInput[] | complaintsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsersInput | complaintsCreateOrConnectWithoutUsersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsersInput | complaintsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: complaintsCreateManyUsersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsersInput | complaintsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsersInput | complaintsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type companiesCreateWithoutAdminsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: sitesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: sitesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
  }

  export type companiesCreateManyAdminsInputEnvelope = {
    data: companiesCreateManyAdminsInput | companiesCreateManyAdminsInput[]
    skipDuplicates?: boolean
  }

  export type company_employeesCreateWithoutAdminsInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutAdminsInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
  }

  export type sitesCreateWithoutAdminsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutAdminsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutAdminsInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput>
  }

  export type sitesCreateManyAdminsInputEnvelope = {
    data: sitesCreateManyAdminsInput | sitesCreateManyAdminsInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithWhereUniqueWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
  }

  export type companiesUpdateManyWithWhereWithoutAdminsInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutAdminsInput>
  }

  export type companiesScalarWhereInput = {
    AND?: companiesScalarWhereInput | companiesScalarWhereInput[]
    OR?: companiesScalarWhereInput[]
    NOT?: companiesScalarWhereInput | companiesScalarWhereInput[]
    id?: IntFilter<"companies"> | number
    company_name?: StringFilter<"companies"> | string
    company_code?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
  }

  export type company_employeesUpsertWithoutAdminsInput = {
    update: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutAdminsInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type company_employeesUpdateWithoutAdminsInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type sitesUpsertWithWhereUniqueWithoutAdminsInput = {
    where: sitesWhereUniqueInput
    update: XOR<sitesUpdateWithoutAdminsInput, sitesUncheckedUpdateWithoutAdminsInput>
    create: XOR<sitesCreateWithoutAdminsInput, sitesUncheckedCreateWithoutAdminsInput>
  }

  export type sitesUpdateWithWhereUniqueWithoutAdminsInput = {
    where: sitesWhereUniqueInput
    data: XOR<sitesUpdateWithoutAdminsInput, sitesUncheckedUpdateWithoutAdminsInput>
  }

  export type sitesUpdateManyWithWhereWithoutAdminsInput = {
    where: sitesScalarWhereInput
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyWithoutAdminsInput>
  }

  export type sitesScalarWhereInput = {
    AND?: sitesScalarWhereInput | sitesScalarWhereInput[]
    OR?: sitesScalarWhereInput[]
    NOT?: sitesScalarWhereInput | sitesScalarWhereInput[]
    id?: IntFilter<"sites"> | number
    site_id?: StringFilter<"sites"> | string
    site_name?: StringFilter<"sites"> | string
    site_address?: StringFilter<"sites"> | string
    created_at?: DateTimeFilter<"sites"> | Date | string
    updated_at?: DateTimeFilter<"sites"> | Date | string
    adminId?: IntNullableFilter<"sites"> | number | null
    apartment_count?: IntNullableFilter<"sites"> | number | null
    block_count?: IntNullableFilter<"sites"> | number | null
    company_id?: IntNullableFilter<"sites"> | number | null
    deleted_at?: DateTimeNullableFilter<"sites"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"sites"> | $Enums.AccountStatus
  }

  export type sitesCreateWithoutAnnouncementsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutAnnouncementsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutAnnouncementsInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutAnnouncementsInput, sitesUncheckedCreateWithoutAnnouncementsInput>
  }

  export type sitesUpsertWithoutAnnouncementsInput = {
    update: XOR<sitesUpdateWithoutAnnouncementsInput, sitesUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<sitesCreateWithoutAnnouncementsInput, sitesUncheckedCreateWithoutAnnouncementsInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutAnnouncementsInput, sitesUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type sitesUpdateWithoutAnnouncementsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutAnnouncementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type sitesCreateWithoutBlocksInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutBlocksInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutBlocksInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutBlocksInput, sitesUncheckedCreateWithoutBlocksInput>
  }

  export type usersCreateWithoutBlocksInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    sites: sitesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBlocksInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput>
  }

  export type usersCreateManyBlocksInputEnvelope = {
    data: usersCreateManyBlocksInput | usersCreateManyBlocksInput[]
    skipDuplicates?: boolean
  }

  export type sitesUpsertWithoutBlocksInput = {
    update: XOR<sitesUpdateWithoutBlocksInput, sitesUncheckedUpdateWithoutBlocksInput>
    create: XOR<sitesCreateWithoutBlocksInput, sitesUncheckedCreateWithoutBlocksInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutBlocksInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutBlocksInput, sitesUncheckedUpdateWithoutBlocksInput>
  }

  export type sitesUpdateWithoutBlocksInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutBlocksInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutBlocksInput, usersUncheckedUpdateWithoutBlocksInput>
    create: XOR<usersCreateWithoutBlocksInput, usersUncheckedCreateWithoutBlocksInput>
  }

  export type usersUpdateWithWhereUniqueWithoutBlocksInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutBlocksInput, usersUncheckedUpdateWithoutBlocksInput>
  }

  export type usersUpdateManyWithWhereWithoutBlocksInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutBlocksInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: IntFilter<"users"> | number
    full_name?: StringFilter<"users"> | string
    phone_number?: StringFilter<"users"> | string
    password?: StringNullableFilter<"users"> | string | null
    apartment_no?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    siteId?: IntFilter<"users"> | number
    code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"users"> | string | null
    reset_code?: StringNullableFilter<"users"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"users"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    last_login?: DateTimeNullableFilter<"users"> | Date | string | null
    plates?: StringNullableFilter<"users"> | string | null
    resident_count?: IntNullableFilter<"users"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"users"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"users"> | number | null
    is_password_set?: BoolFilter<"users"> | boolean
  }

  export type adminsCreateWithoutCompaniesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    sites?: sitesCreateNestedManyWithoutAdminsInput
  }

  export type adminsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    sites?: sitesUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type adminsCreateOrConnectWithoutCompaniesInput = {
    where: adminsWhereUniqueInput
    create: XOR<adminsCreateWithoutCompaniesInput, adminsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesCreateWithoutCompaniesInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: adminsCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesCreateManyCompaniesInputEnvelope = {
    data: company_employeesCreateManyCompaniesInput | company_employeesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type invitationsCreateWithoutCompaniesInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsCreateOrConnectWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsCreateManyCompaniesInputEnvelope = {
    data: invitationsCreateManyCompaniesInput | invitationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type sitesCreateWithoutCompaniesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutCompaniesInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput>
  }

  export type sitesCreateManyCompaniesInputEnvelope = {
    data: sitesCreateManyCompaniesInput | sitesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type adminsUpsertWithoutCompaniesInput = {
    update: XOR<adminsUpdateWithoutCompaniesInput, adminsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<adminsCreateWithoutCompaniesInput, adminsUncheckedCreateWithoutCompaniesInput>
    where?: adminsWhereInput
  }

  export type adminsUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: adminsWhereInput
    data: XOR<adminsUpdateWithoutCompaniesInput, adminsUncheckedUpdateWithoutCompaniesInput>
  }

  export type adminsUpdateWithoutCompaniesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    sites?: sitesUpdateManyWithoutAdminsNestedInput
  }

  export type adminsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    sites?: sitesUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type company_employeesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    update: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    data: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_employeesUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_employeesScalarWhereInput
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_employeesScalarWhereInput = {
    AND?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    OR?: company_employeesScalarWhereInput[]
    NOT?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
  }

  export type invitationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    update: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    data: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type invitationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: invitationsScalarWhereInput
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type invitationsScalarWhereInput = {
    AND?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    OR?: invitationsScalarWhereInput[]
    NOT?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
  }

  export type sitesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: sitesWhereUniqueInput
    update: XOR<sitesUpdateWithoutCompaniesInput, sitesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<sitesCreateWithoutCompaniesInput, sitesUncheckedCreateWithoutCompaniesInput>
  }

  export type sitesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: sitesWhereUniqueInput
    data: XOR<sitesUpdateWithoutCompaniesInput, sitesUncheckedUpdateWithoutCompaniesInput>
  }

  export type sitesUpdateManyWithWhereWithoutCompaniesInput = {
    where: sitesScalarWhereInput
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type adminsCreateWithoutCompany_employeesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    sites?: sitesCreateNestedManyWithoutAdminsInput
  }

  export type adminsUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    sites?: sitesUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type adminsCreateOrConnectWithoutCompany_employeesInput = {
    where: adminsWhereUniqueInput
    create: XOR<adminsCreateWithoutCompany_employeesInput, adminsUncheckedCreateWithoutCompany_employeesInput>
  }

  export type companiesCreateWithoutCompany_employeesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: adminsCreateNestedOneWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: sitesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: sitesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_employeesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateWithoutCompany_employeesInput = {
    granted_at?: Date | string
    sites: sitesCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessCreateOrConnectWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateManyCompany_employeesInputEnvelope = {
    data: employee_site_accessCreateManyCompany_employeesInput | employee_site_accessCreateManyCompany_employeesInput[]
    skipDuplicates?: boolean
  }

  export type adminsUpsertWithoutCompany_employeesInput = {
    update: XOR<adminsUpdateWithoutCompany_employeesInput, adminsUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<adminsCreateWithoutCompany_employeesInput, adminsUncheckedCreateWithoutCompany_employeesInput>
    where?: adminsWhereInput
  }

  export type adminsUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: adminsWhereInput
    data: XOR<adminsUpdateWithoutCompany_employeesInput, adminsUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type adminsUpdateWithoutCompany_employeesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    sites?: sitesUpdateManyWithoutAdminsNestedInput
  }

  export type adminsUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    sites?: sitesUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type companiesUpsertWithoutCompany_employeesInput = {
    update: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateWithoutCompany_employeesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: adminsUpdateOneRequiredWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput>
  }

  export type employee_site_accessScalarWhereInput = {
    AND?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    OR?: employee_site_accessScalarWhereInput[]
    NOT?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
  }

  export type sitesCreateWithoutComplaintsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutComplaintsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutComplaintsInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutComplaintsInput, sitesUncheckedCreateWithoutComplaintsInput>
  }

  export type usersCreateWithoutComplaintsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    sites: sitesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutComplaintsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutComplaintsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutComplaintsInput, usersUncheckedCreateWithoutComplaintsInput>
  }

  export type sitesUpsertWithoutComplaintsInput = {
    update: XOR<sitesUpdateWithoutComplaintsInput, sitesUncheckedUpdateWithoutComplaintsInput>
    create: XOR<sitesCreateWithoutComplaintsInput, sitesUncheckedCreateWithoutComplaintsInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutComplaintsInput, sitesUncheckedUpdateWithoutComplaintsInput>
  }

  export type sitesUpdateWithoutComplaintsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type usersUpsertWithoutComplaintsInput = {
    update: XOR<usersUpdateWithoutComplaintsInput, usersUncheckedUpdateWithoutComplaintsInput>
    create: XOR<usersCreateWithoutComplaintsInput, usersUncheckedCreateWithoutComplaintsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutComplaintsInput, usersUncheckedUpdateWithoutComplaintsInput>
  }

  export type usersUpdateWithoutComplaintsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    sites?: sitesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type company_employeesCreateWithoutEmployee_site_accessInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: adminsCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type company_employeesCreateOrConnectWithoutEmployee_site_accessInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type sitesCreateWithoutEmployee_site_accessInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutEmployee_site_accessInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutEmployee_site_accessInput, sitesUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpsertWithoutEmployee_site_accessInput = {
    update: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpdateWithoutEmployee_site_accessInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: adminsUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type sitesUpsertWithoutEmployee_site_accessInput = {
    update: XOR<sitesUpdateWithoutEmployee_site_accessInput, sitesUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<sitesCreateWithoutEmployee_site_accessInput, sitesUncheckedCreateWithoutEmployee_site_accessInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutEmployee_site_accessInput, sitesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type sitesUpdateWithoutEmployee_site_accessInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type companiesCreateWithoutInvitationsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: adminsCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    sites?: sitesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutInvitationsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: sitesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutInvitationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
  }

  export type companiesUpsertWithoutInvitationsInput = {
    update: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type companiesUpdateWithoutInvitationsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: adminsUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersCreateWithoutPaymentsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    sites: sitesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    sites?: sitesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type announcementsCreateWithoutSitesInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsUncheckedCreateWithoutSitesInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type announcementsCreateOrConnectWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    create: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput>
  }

  export type announcementsCreateManySitesInputEnvelope = {
    data: announcementsCreateManySitesInput | announcementsCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutSitesInput = {
    block_name: string
    created_at?: Date | string
    users?: usersCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutSitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
    users?: usersUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksCreateOrConnectWithoutSitesInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksCreateManySitesInputEnvelope = {
    data: blocksCreateManySitesInput | blocksCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type complaintsCreateWithoutSitesInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
    users: usersCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateWithoutSitesInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsCreateOrConnectWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput>
  }

  export type complaintsCreateManySitesInputEnvelope = {
    data: complaintsCreateManySitesInput | complaintsCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type employee_site_accessCreateWithoutSitesInput = {
    granted_at?: Date | string
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutSitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessCreateOrConnectWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessCreateManySitesInputEnvelope = {
    data: employee_site_accessCreateManySitesInput | employee_site_accessCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type adminsCreateWithoutSitesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
  }

  export type adminsUncheckedCreateWithoutSitesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
  }

  export type adminsCreateOrConnectWithoutSitesInput = {
    where: adminsWhereUniqueInput
    create: XOR<adminsCreateWithoutSitesInput, adminsUncheckedCreateWithoutSitesInput>
  }

  export type companiesCreateWithoutSitesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: adminsCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutSitesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutSitesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesCreateWithoutSitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUncheckedCreateWithoutSitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesCreateOrConnectWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    create: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesCreateManySitesInputEnvelope = {
    data: social_amenitiesCreateManySitesInput | social_amenitiesCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutSitesInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: complaintsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSitesInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: complaintsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSitesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput>
  }

  export type usersCreateManySitesInputEnvelope = {
    data: usersCreateManySitesInput | usersCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type announcementsUpsertWithWhereUniqueWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    update: XOR<announcementsUpdateWithoutSitesInput, announcementsUncheckedUpdateWithoutSitesInput>
    create: XOR<announcementsCreateWithoutSitesInput, announcementsUncheckedCreateWithoutSitesInput>
  }

  export type announcementsUpdateWithWhereUniqueWithoutSitesInput = {
    where: announcementsWhereUniqueInput
    data: XOR<announcementsUpdateWithoutSitesInput, announcementsUncheckedUpdateWithoutSitesInput>
  }

  export type announcementsUpdateManyWithWhereWithoutSitesInput = {
    where: announcementsScalarWhereInput
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyWithoutSitesInput>
  }

  export type announcementsScalarWhereInput = {
    AND?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
    OR?: announcementsScalarWhereInput[]
    NOT?: announcementsScalarWhereInput | announcementsScalarWhereInput[]
    id?: IntFilter<"announcements"> | number
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    created_at?: DateTimeFilter<"announcements"> | Date | string
    updated_at?: DateTimeFilter<"announcements"> | Date | string
    siteId?: IntFilter<"announcements"> | number
    start_date?: DateTimeFilter<"announcements"> | Date | string
    end_date?: DateTimeFilter<"announcements"> | Date | string
  }

  export type blocksUpsertWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    update: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksUpdateWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    data: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
  }

  export type blocksUpdateManyWithWhereWithoutSitesInput = {
    where: blocksScalarWhereInput
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyWithoutSitesInput>
  }

  export type blocksScalarWhereInput = {
    AND?: blocksScalarWhereInput | blocksScalarWhereInput[]
    OR?: blocksScalarWhereInput[]
    NOT?: blocksScalarWhereInput | blocksScalarWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
  }

  export type complaintsUpsertWithWhereUniqueWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutSitesInput, complaintsUncheckedUpdateWithoutSitesInput>
    create: XOR<complaintsCreateWithoutSitesInput, complaintsUncheckedCreateWithoutSitesInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutSitesInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutSitesInput, complaintsUncheckedUpdateWithoutSitesInput>
  }

  export type complaintsUpdateManyWithWhereWithoutSitesInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutSitesInput>
  }

  export type complaintsScalarWhereInput = {
    AND?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    OR?: complaintsScalarWhereInput[]
    NOT?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    id?: IntFilter<"complaints"> | number
    title?: StringFilter<"complaints"> | string
    content?: StringFilter<"complaints"> | string
    status?: EnumStatusFilter<"complaints"> | $Enums.Status
    siteId?: IntFilter<"complaints"> | number
    userId?: IntFilter<"complaints"> | number
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    category?: EnumCategoryNullableFilter<"complaints"> | $Enums.Category | null
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutSitesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutSitesInput>
  }

  export type adminsUpsertWithoutSitesInput = {
    update: XOR<adminsUpdateWithoutSitesInput, adminsUncheckedUpdateWithoutSitesInput>
    create: XOR<adminsCreateWithoutSitesInput, adminsUncheckedCreateWithoutSitesInput>
    where?: adminsWhereInput
  }

  export type adminsUpdateToOneWithWhereWithoutSitesInput = {
    where?: adminsWhereInput
    data: XOR<adminsUpdateWithoutSitesInput, adminsUncheckedUpdateWithoutSitesInput>
  }

  export type adminsUpdateWithoutSitesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
  }

  export type adminsUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
  }

  export type companiesUpsertWithoutSitesInput = {
    update: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutSitesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type companiesUpdateWithoutSitesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: adminsUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type social_amenitiesUpsertWithWhereUniqueWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    update: XOR<social_amenitiesUpdateWithoutSitesInput, social_amenitiesUncheckedUpdateWithoutSitesInput>
    create: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesUpdateWithWhereUniqueWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    data: XOR<social_amenitiesUpdateWithoutSitesInput, social_amenitiesUncheckedUpdateWithoutSitesInput>
  }

  export type social_amenitiesUpdateManyWithWhereWithoutSitesInput = {
    where: social_amenitiesScalarWhereInput
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyWithoutSitesInput>
  }

  export type social_amenitiesScalarWhereInput = {
    AND?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
    OR?: social_amenitiesScalarWhereInput[]
    NOT?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
    id?: StringFilter<"social_amenities"> | string
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutSitesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutSitesInput, usersUncheckedUpdateWithoutSitesInput>
    create: XOR<usersCreateWithoutSitesInput, usersUncheckedCreateWithoutSitesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutSitesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutSitesInput, usersUncheckedUpdateWithoutSitesInput>
  }

  export type usersUpdateManyWithWhereWithoutSitesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutSitesInput>
  }

  export type sitesCreateWithoutSocial_amenitiesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    users?: usersCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutSocial_amenitiesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    users?: usersUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutSocial_amenitiesInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutSocial_amenitiesInput, sitesUncheckedCreateWithoutSocial_amenitiesInput>
  }

  export type sitesUpsertWithoutSocial_amenitiesInput = {
    update: XOR<sitesUpdateWithoutSocial_amenitiesInput, sitesUncheckedUpdateWithoutSocial_amenitiesInput>
    create: XOR<sitesCreateWithoutSocial_amenitiesInput, sitesUncheckedCreateWithoutSocial_amenitiesInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutSocial_amenitiesInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutSocial_amenitiesInput, sitesUncheckedUpdateWithoutSocial_amenitiesInput>
  }

  export type sitesUpdateWithoutSocial_amenitiesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutSocial_amenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type complaintsCreateWithoutUsersInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
    sites: sitesCreateNestedOneWithoutComplaintsInput
  }

  export type complaintsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type complaintsCreateOrConnectWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput>
  }

  export type complaintsCreateManyUsersInputEnvelope = {
    data: complaintsCreateManyUsersInput | complaintsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutUsersInput = {
    block_name: string
    created_at?: Date | string
    sites: sitesCreateNestedOneWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutUsersInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
  }

  export type blocksCreateOrConnectWithoutUsersInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
  }

  export type sitesCreateWithoutUsersInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsCreateNestedManyWithoutSitesInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: complaintsCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admins?: adminsCreateNestedOneWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateWithoutUsersInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: announcementsUncheckedCreateNestedManyWithoutSitesInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: complaintsUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesCreateOrConnectWithoutUsersInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutUsersInput, sitesUncheckedCreateWithoutUsersInput>
  }

  export type complaintsUpsertWithWhereUniqueWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutUsersInput, complaintsUncheckedUpdateWithoutUsersInput>
    create: XOR<complaintsCreateWithoutUsersInput, complaintsUncheckedCreateWithoutUsersInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutUsersInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutUsersInput, complaintsUncheckedUpdateWithoutUsersInput>
  }

  export type complaintsUpdateManyWithWhereWithoutUsersInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
  }

  export type blocksUpsertWithoutUsersInput = {
    update: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    where?: blocksWhereInput
  }

  export type blocksUpdateToOneWithWhereWithoutUsersInput = {
    where?: blocksWhereInput
    data: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type blocksUpdateWithoutUsersInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: sitesUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sitesUpsertWithoutUsersInput = {
    update: XOR<sitesUpdateWithoutUsersInput, sitesUncheckedUpdateWithoutUsersInput>
    create: XOR<sitesCreateWithoutUsersInput, sitesUncheckedCreateWithoutUsersInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutUsersInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutUsersInput, sitesUncheckedUpdateWithoutUsersInput>
  }

  export type sitesUpdateWithoutUsersInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type companiesCreateManyAdminsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type sitesCreateManyAdminsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type companiesUpdateWithoutAdminsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: sitesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateManyWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sitesUpdateWithoutAdminsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateManyWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type usersCreateManyBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
  }

  export type usersUpdateWithoutBlocksInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    sites?: sitesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type company_employeesCreateManyCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type invitationsCreateManyCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type sitesCreateManyCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type company_employeesUpdateWithoutCompaniesInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: adminsUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type invitationsUpdateWithoutCompaniesInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sitesUpdateWithoutCompaniesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUpdateManyWithoutSitesNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admins?: adminsUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: usersUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: announcementsUncheckedUpdateManyWithoutSitesNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: complaintsUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: usersUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type employee_site_accessCreateManyCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateWithoutCompany_employeesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: sitesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateManySitesInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type blocksCreateManySitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
  }

  export type complaintsCreateManySitesInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type employee_site_accessCreateManySitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
  }

  export type social_amenitiesCreateManySitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManySitesInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
  }

  export type announcementsUpdateWithoutSitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksUpdateWithoutSitesInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUpdateWithoutSitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    users?: usersUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type employee_site_accessUpdateWithoutSitesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateManyWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutSitesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: complaintsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintsCreateManyUsersInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at: Date | string
    category?: $Enums.Category | null
  }

  export type paymentsCreateManyUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type complaintsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sites?: sitesUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type complaintsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type complaintsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type paymentsUpdateWithoutUsersInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}