
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Site
 * 
 */
export type Site = $Result.DefaultSelection<Prisma.$SitePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model social_amenities
 * 
 */
export type social_amenities = $Result.DefaultSelection<Prisma.$social_amenitiesPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model blocks
 * 
 */
export type blocks = $Result.DefaultSelection<Prisma.$blocksPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model company_employees
 * 
 */
export type company_employees = $Result.DefaultSelection<Prisma.$company_employeesPayload>
/**
 * Model employee_site_access
 * 
 */
export type employee_site_access = $Result.DefaultSelection<Prisma.$employee_site_accessPayload>
/**
 * Model invitations
 * 
 */
export type invitations = $Result.DefaultSelection<Prisma.$invitationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  MASTER_ADMIN: 'MASTER_ADMIN',
  COMPANY_MANAGER: 'COMPANY_MANAGER',
  COMPANY_EMPLOYEE: 'COMPANY_EMPLOYEE',
  SITE_USER: 'SITE_USER'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const Category: {
  MAINTENANCE: 'MAINTENANCE',
  COMPLAINT: 'COMPLAINT',
  REQUEST: 'REQUEST',
  OTHER: 'OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const Status: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ResidentType: {
  OWNER: 'OWNER',
  HIRER: 'HIRER'
};

export type ResidentType = (typeof ResidentType)[keyof typeof ResidentType]

}

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ResidentType = $Enums.ResidentType

export const ResidentType: typeof $Enums.ResidentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.social_amenities`: Exposes CRUD operations for the **social_amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Social_amenities
    * const social_amenities = await prisma.social_amenities.findMany()
    * ```
    */
  get social_amenities(): Prisma.social_amenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_employees`: Exposes CRUD operations for the **company_employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_employees
    * const company_employees = await prisma.company_employees.findMany()
    * ```
    */
  get company_employees(): Prisma.company_employeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee_site_access`: Exposes CRUD operations for the **employee_site_access** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_site_accesses
    * const employee_site_accesses = await prisma.employee_site_access.findMany()
    * ```
    */
  get employee_site_access(): Prisma.employee_site_accessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitations`: Exposes CRUD operations for the **invitations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitations.findMany()
    * ```
    */
  get invitations(): Prisma.invitationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    Site: 'Site',
    User: 'User',
    social_amenities: 'social_amenities',
    Announcement: 'Announcement',
    Complaint: 'Complaint',
    blocks: 'blocks',
    companies: 'companies',
    company_employees: 'company_employees',
    employee_site_access: 'employee_site_access',
    invitations: 'invitations',
    payments: 'payments'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "site" | "user" | "social_amenities" | "announcement" | "complaint" | "blocks" | "companies" | "company_employees" | "employee_site_access" | "invitations" | "payments"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Site: {
        payload: Prisma.$SitePayload<ExtArgs>
        fields: Prisma.SiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findFirst: {
            args: Prisma.SiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findMany: {
            args: Prisma.SiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          create: {
            args: Prisma.SiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          createMany: {
            args: Prisma.SiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          delete: {
            args: Prisma.SiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          update: {
            args: Prisma.SiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          deleteMany: {
            args: Prisma.SiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          upsert: {
            args: Prisma.SiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          aggregate: {
            args: Prisma.SiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite>
          }
          groupBy: {
            args: Prisma.SiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      social_amenities: {
        payload: Prisma.$social_amenitiesPayload<ExtArgs>
        fields: Prisma.social_amenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.social_amenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.social_amenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          findFirst: {
            args: Prisma.social_amenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.social_amenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          findMany: {
            args: Prisma.social_amenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          create: {
            args: Prisma.social_amenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          createMany: {
            args: Prisma.social_amenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.social_amenitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          delete: {
            args: Prisma.social_amenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          update: {
            args: Prisma.social_amenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          deleteMany: {
            args: Prisma.social_amenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.social_amenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.social_amenitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>[]
          }
          upsert: {
            args: Prisma.social_amenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_amenitiesPayload>
          }
          aggregate: {
            args: Prisma.Social_amenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocial_amenities>
          }
          groupBy: {
            args: Prisma.social_amenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Social_amenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.social_amenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Social_amenitiesCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplaintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      blocks: {
        payload: Prisma.$blocksPayload<ExtArgs>
        fields: Prisma.blocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blocksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blocksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findFirst: {
            args: Prisma.blocksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blocksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findMany: {
            args: Prisma.blocksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          create: {
            args: Prisma.blocksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          createMany: {
            args: Prisma.blocksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blocksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          delete: {
            args: Prisma.blocksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          update: {
            args: Prisma.blocksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          deleteMany: {
            args: Prisma.blocksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blocksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blocksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          upsert: {
            args: Prisma.blocksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.blocksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.blocksCountArgs<ExtArgs>
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      company_employees: {
        payload: Prisma.$company_employeesPayload<ExtArgs>
        fields: Prisma.company_employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findFirst: {
            args: Prisma.company_employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          findMany: {
            args: Prisma.company_employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          create: {
            args: Prisma.company_employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          createMany: {
            args: Prisma.company_employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_employeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          delete: {
            args: Prisma.company_employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          update: {
            args: Prisma.company_employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          deleteMany: {
            args: Prisma.company_employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_employeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>[]
          }
          upsert: {
            args: Prisma.company_employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_employeesPayload>
          }
          aggregate: {
            args: Prisma.Company_employeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_employees>
          }
          groupBy: {
            args: Prisma.company_employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_employeesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_employeesCountAggregateOutputType> | number
          }
        }
      }
      employee_site_access: {
        payload: Prisma.$employee_site_accessPayload<ExtArgs>
        fields: Prisma.employee_site_accessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employee_site_accessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employee_site_accessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findFirst: {
            args: Prisma.employee_site_accessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employee_site_accessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          findMany: {
            args: Prisma.employee_site_accessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          create: {
            args: Prisma.employee_site_accessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          createMany: {
            args: Prisma.employee_site_accessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employee_site_accessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          delete: {
            args: Prisma.employee_site_accessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          update: {
            args: Prisma.employee_site_accessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          deleteMany: {
            args: Prisma.employee_site_accessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employee_site_accessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employee_site_accessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>[]
          }
          upsert: {
            args: Prisma.employee_site_accessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_site_accessPayload>
          }
          aggregate: {
            args: Prisma.Employee_site_accessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_site_access>
          }
          groupBy: {
            args: Prisma.employee_site_accessGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessGroupByOutputType>[]
          }
          count: {
            args: Prisma.employee_site_accessCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_site_accessCountAggregateOutputType> | number
          }
        }
      }
      invitations: {
        payload: Prisma.$invitationsPayload<ExtArgs>
        fields: Prisma.invitationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invitationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invitationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findFirst: {
            args: Prisma.invitationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invitationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findMany: {
            args: Prisma.invitationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          create: {
            args: Prisma.invitationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          createMany: {
            args: Prisma.invitationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invitationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          delete: {
            args: Prisma.invitationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          update: {
            args: Prisma.invitationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          deleteMany: {
            args: Prisma.invitationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invitationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invitationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          upsert: {
            args: Prisma.invitationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          aggregate: {
            args: Prisma.InvitationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitations>
          }
          groupBy: {
            args: Prisma.invitationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invitationsCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    site?: SiteOmit
    user?: UserOmit
    social_amenities?: social_amenitiesOmit
    announcement?: AnnouncementOmit
    complaint?: ComplaintOmit
    blocks?: blocksOmit
    companies?: companiesOmit
    company_employees?: company_employeesOmit
    employee_site_access?: employee_site_accessOmit
    invitations?: invitationsOmit
    payments?: paymentsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    companies: number
    sites_created: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | AdminCountOutputTypeCountCompaniesArgs
    sites_created?: boolean | AdminCountOutputTypeCountSites_createdArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }


  /**
   * Count Type SiteCountOutputType
   */

  export type SiteCountOutputType = {
    announcements: number
    blocks: number
    complaints: number
    employee_site_access: number
    social_amenities: number
    users: number
  }

  export type SiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | SiteCountOutputTypeCountAnnouncementsArgs
    blocks?: boolean | SiteCountOutputTypeCountBlocksArgs
    complaints?: boolean | SiteCountOutputTypeCountComplaintsArgs
    employee_site_access?: boolean | SiteCountOutputTypeCountEmployee_site_accessArgs
    social_amenities?: boolean | SiteCountOutputTypeCountSocial_amenitiesArgs
    users?: boolean | SiteCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCountOutputType
     */
    select?: SiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountSocial_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_amenitiesWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    complaints: number
    payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | UserCountOutputTypeCountComplaintsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type BlocksCountOutputType
   */

  export type BlocksCountOutputType = {
    users: number
  }

  export type BlocksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BlocksCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocksCountOutputType
     */
    select?: BlocksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocksCountOutputType without action
   */
  export type BlocksCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    company_employees: number
    invitations: number
    sites: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | CompaniesCountOutputTypeCountCompany_employeesArgs
    invitations?: boolean | CompaniesCountOutputTypeCountInvitationsArgs
    sites?: boolean | CompaniesCountOutputTypeCountSitesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }


  /**
   * Count Type Company_employeesCountOutputType
   */

  export type Company_employeesCountOutputType = {
    employee_site_access: number
  }

  export type Company_employeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_site_access?: boolean | Company_employeesCountOutputTypeCountEmployee_site_accessArgs
  }

  // Custom InputTypes
  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company_employeesCountOutputType
     */
    select?: Company_employeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Company_employeesCountOutputType without action
   */
  export type Company_employeesCountOutputTypeCountEmployee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    account_type: $Enums.AccountType | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password: number
    account_type: number
    company_name: number
    created_at: number
    updated_at: number
    tokenExpiry: number
    verificationToken: number
    is_verified: number
    resetToken: number
    resetTokenExpiry: number
    account_status: number
    deleted_at: number
    last_login: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password?: true
    account_type?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    tokenExpiry?: true
    verificationToken?: true
    is_verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name: string | null
    created_at: Date
    updated_at: Date
    tokenExpiry: Date | null
    verificationToken: string | null
    is_verified: boolean
    resetToken: string | null
    resetTokenExpiry: Date | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    companies?: boolean | Admin$companiesArgs<ExtArgs>
    company_employees?: boolean | Admin$company_employeesArgs<ExtArgs>
    sites_created?: boolean | Admin$sites_createdArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    account_type?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tokenExpiry?: boolean
    verificationToken?: boolean
    is_verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password" | "account_type" | "company_name" | "created_at" | "updated_at" | "tokenExpiry" | "verificationToken" | "is_verified" | "resetToken" | "resetTokenExpiry" | "account_status" | "deleted_at" | "last_login", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | Admin$companiesArgs<ExtArgs>
    company_employees?: boolean | Admin$company_employeesArgs<ExtArgs>
    sites_created?: boolean | Admin$sites_createdArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>[]
      company_employees: Prisma.$company_employeesPayload<ExtArgs> | null
      sites_created: Prisma.$SitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      password: string
      account_type: $Enums.AccountType
      company_name: string | null
      created_at: Date
      updated_at: Date
      tokenExpiry: Date | null
      verificationToken: string | null
      is_verified: boolean
      resetToken: string | null
      resetTokenExpiry: Date | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends Admin$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_employees<T extends Admin$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$company_employeesArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sites_created<T extends Admin$sites_createdArgs<ExtArgs> = {}>(args?: Subset<T, Admin$sites_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly full_name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly account_type: FieldRef<"Admin", 'AccountType'>
    readonly company_name: FieldRef<"Admin", 'String'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
    readonly updated_at: FieldRef<"Admin", 'DateTime'>
    readonly tokenExpiry: FieldRef<"Admin", 'DateTime'>
    readonly verificationToken: FieldRef<"Admin", 'String'>
    readonly is_verified: FieldRef<"Admin", 'Boolean'>
    readonly resetToken: FieldRef<"Admin", 'String'>
    readonly resetTokenExpiry: FieldRef<"Admin", 'DateTime'>
    readonly account_status: FieldRef<"Admin", 'AccountStatus'>
    readonly deleted_at: FieldRef<"Admin", 'DateTime'>
    readonly last_login: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.companies
   */
  export type Admin$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    cursor?: companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * Admin.company_employees
   */
  export type Admin$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
  }

  /**
   * Admin.sites_created
   */
  export type Admin$sites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Site
   */

  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SiteSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
  }

  export type SiteMinAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SiteMaxAggregateOutputType = {
    id: number | null
    site_id: string | null
    site_name: string | null
    site_address: string | null
    created_at: Date | null
    updated_at: Date | null
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    site_id: number
    site_name: number
    site_address: number
    created_at: number
    updated_at: number
    adminId: number
    apartment_count: number
    block_count: number
    company_id: number
    deleted_at: number
    site_status: number
    _all: number
  }


  export type SiteAvgAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SiteSumAggregateInputType = {
    id?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
  }

  export type SiteMinAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    site_id?: true
    site_name?: true
    site_address?: true
    created_at?: true
    updated_at?: true
    adminId?: true
    apartment_count?: true
    block_count?: true
    company_id?: true
    deleted_at?: true
    site_status?: true
    _all?: true
  }

  export type SiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithAggregationInput | SiteOrderByWithAggregationInput[]
    by: SiteScalarFieldEnum[] | SiteScalarFieldEnum
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _avg?: SiteAvgAggregateInputType
    _sum?: SiteSumAggregateInputType
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }

  export type SiteGroupByOutputType = {
    id: number
    site_id: string
    site_name: string
    site_address: string
    created_at: Date
    updated_at: Date
    adminId: number | null
    apartment_count: number | null
    block_count: number | null
    company_id: number | null
    deleted_at: Date | null
    site_status: $Enums.AccountStatus
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    announcements?: boolean | Site$announcementsArgs<ExtArgs>
    blocks?: boolean | Site$blocksArgs<ExtArgs>
    complaints?: boolean | Site$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | Site$employee_site_accessArgs<ExtArgs>
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
    social_amenities?: boolean | Site$social_amenitiesArgs<ExtArgs>
    users?: boolean | Site$usersArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectScalar = {
    id?: boolean
    site_id?: boolean
    site_name?: boolean
    site_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    adminId?: boolean
    apartment_count?: boolean
    block_count?: boolean
    company_id?: boolean
    deleted_at?: boolean
    site_status?: boolean
  }

  export type SiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "site_id" | "site_name" | "site_address" | "created_at" | "updated_at" | "adminId" | "apartment_count" | "block_count" | "company_id" | "deleted_at" | "site_status", ExtArgs["result"]["site"]>
  export type SiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | Site$announcementsArgs<ExtArgs>
    blocks?: boolean | Site$blocksArgs<ExtArgs>
    complaints?: boolean | Site$complaintsArgs<ExtArgs>
    employee_site_access?: boolean | Site$employee_site_accessArgs<ExtArgs>
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
    social_amenities?: boolean | Site$social_amenitiesArgs<ExtArgs>
    users?: boolean | Site$usersArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }
  export type SiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Site$adminArgs<ExtArgs>
    companies?: boolean | Site$companiesArgs<ExtArgs>
  }

  export type $SitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Site"
    objects: {
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs> | null
      social_amenities: Prisma.$social_amenitiesPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_id: string
      site_name: string
      site_address: string
      created_at: Date
      updated_at: Date
      adminId: number | null
      apartment_count: number | null
      block_count: number | null
      company_id: number | null
      deleted_at: Date | null
      site_status: $Enums.AccountStatus
    }, ExtArgs["result"]["site"]>
    composites: {}
  }

  type SiteGetPayload<S extends boolean | null | undefined | SiteDefaultArgs> = $Result.GetResult<Prisma.$SitePayload, S>

  type SiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Site'], meta: { name: 'Site' } }
    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteFindUniqueArgs>(args: SelectSubset<T, SiteFindUniqueArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Site that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteFindFirstArgs>(args?: SelectSubset<T, SiteFindFirstArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteFindManyArgs>(args?: SelectSubset<T, SiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
     */
    create<T extends SiteCreateArgs>(args: SelectSubset<T, SiteCreateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCreateManyArgs>(args?: SelectSubset<T, SiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {SiteCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
     */
    delete<T extends SiteDeleteArgs>(args: SelectSubset<T, SiteDeleteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteUpdateArgs>(args: SelectSubset<T, SiteUpdateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteDeleteManyArgs>(args?: SelectSubset<T, SiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteUpdateManyArgs>(args: SelectSubset<T, SiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {SiteUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
     */
    upsert<T extends SiteUpsertArgs>(args: SelectSubset<T, SiteUpsertArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Site model
   */
  readonly fields: SiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcements<T extends Site$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Site$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends Site$blocksArgs<ExtArgs> = {}>(args?: Subset<T, Site$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Site$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Site$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee_site_access<T extends Site$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, Site$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends Site$adminArgs<ExtArgs> = {}>(args?: Subset<T, Site$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends Site$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Site$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    social_amenities<T extends Site$social_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Site$social_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Site$usersArgs<ExtArgs> = {}>(args?: Subset<T, Site$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Site model
   */
  interface SiteFieldRefs {
    readonly id: FieldRef<"Site", 'Int'>
    readonly site_id: FieldRef<"Site", 'String'>
    readonly site_name: FieldRef<"Site", 'String'>
    readonly site_address: FieldRef<"Site", 'String'>
    readonly created_at: FieldRef<"Site", 'DateTime'>
    readonly updated_at: FieldRef<"Site", 'DateTime'>
    readonly adminId: FieldRef<"Site", 'Int'>
    readonly apartment_count: FieldRef<"Site", 'Int'>
    readonly block_count: FieldRef<"Site", 'Int'>
    readonly company_id: FieldRef<"Site", 'Int'>
    readonly deleted_at: FieldRef<"Site", 'DateTime'>
    readonly site_status: FieldRef<"Site", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * Site findUnique
   */
  export type SiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findFirst
   */
  export type SiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findMany
   */
  export type SiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site create
   */
  export type SiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }

  /**
   * Site createMany
   */
  export type SiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Site createManyAndReturn
   */
  export type SiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site update
   */
  export type SiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
  }

  /**
   * Site updateManyAndReturn
   */
  export type SiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site upsert
   */
  export type SiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }

  /**
   * Site delete
   */
  export type SiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to delete.
     */
    limit?: number
  }

  /**
   * Site.announcements
   */
  export type Site$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Site.blocks
   */
  export type Site$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    cursor?: blocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Site.complaints
   */
  export type Site$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Site.employee_site_access
   */
  export type Site$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * Site.admin
   */
  export type Site$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Site.companies
   */
  export type Site$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * Site.social_amenities
   */
  export type Site$social_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    where?: social_amenitiesWhereInput
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    cursor?: social_amenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * Site.users
   */
  export type Site$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Site without action
   */
  export type SiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    resident_count: number | null
    block_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number: string | null
    password: string | null
    apartment_no: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus | null
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    full_name: number
    phone_number: number
    password: number
    apartment_no: number
    created_at: number
    updated_at: number
    siteId: number
    code_expiry: number
    phone_verification_code: number
    reset_code: number
    reset_code_expiry: number
    account_status: number
    deleted_at: number
    last_login: number
    plates: number
    resident_count: number
    resident_type: number
    block_id: number
    is_password_set: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    siteId?: true
    resident_count?: true
    block_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    password?: true
    apartment_no?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    code_expiry?: true
    phone_verification_code?: true
    reset_code?: true
    reset_code_expiry?: true
    account_status?: true
    deleted_at?: true
    last_login?: true
    plates?: true
    resident_count?: true
    resident_type?: true
    block_id?: true
    is_password_set?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    full_name: string
    phone_number: string
    password: string | null
    apartment_no: string | null
    created_at: Date
    updated_at: Date
    siteId: number
    code_expiry: Date | null
    phone_verification_code: string | null
    reset_code: string | null
    reset_code_expiry: Date | null
    account_status: $Enums.AccountStatus
    deleted_at: Date | null
    last_login: Date | null
    plates: string | null
    resident_count: number | null
    resident_type: $Enums.ResidentType | null
    block_id: number | null
    is_password_set: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    password?: boolean
    apartment_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    code_expiry?: boolean
    phone_verification_code?: boolean
    reset_code?: boolean
    reset_code_expiry?: boolean
    account_status?: boolean
    deleted_at?: boolean
    last_login?: boolean
    plates?: boolean
    resident_count?: boolean
    resident_type?: boolean
    block_id?: boolean
    is_password_set?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "phone_number" | "password" | "apartment_no" | "created_at" | "updated_at" | "siteId" | "code_expiry" | "phone_verification_code" | "reset_code" | "reset_code_expiry" | "account_status" | "deleted_at" | "last_login" | "plates" | "resident_count" | "resident_type" | "block_id" | "is_password_set", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | User$blocksArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      blocks: Prisma.$blocksPayload<ExtArgs> | null
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      phone_number: string
      password: string | null
      apartment_no: string | null
      created_at: Date
      updated_at: Date
      siteId: number
      code_expiry: Date | null
      phone_verification_code: string | null
      reset_code: string | null
      reset_code_expiry: Date | null
      account_status: $Enums.AccountStatus
      deleted_at: Date | null
      last_login: Date | null
      plates: string | null
      resident_count: number | null
      resident_type: $Enums.ResidentType | null
      block_id: number | null
      is_password_set: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends User$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocks<T extends User$blocksArgs<ExtArgs> = {}>(args?: Subset<T, User$blocksArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly apartment_no: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly siteId: FieldRef<"User", 'Int'>
    readonly code_expiry: FieldRef<"User", 'DateTime'>
    readonly phone_verification_code: FieldRef<"User", 'String'>
    readonly reset_code: FieldRef<"User", 'String'>
    readonly reset_code_expiry: FieldRef<"User", 'DateTime'>
    readonly account_status: FieldRef<"User", 'AccountStatus'>
    readonly deleted_at: FieldRef<"User", 'DateTime'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly plates: FieldRef<"User", 'String'>
    readonly resident_count: FieldRef<"User", 'Int'>
    readonly resident_type: FieldRef<"User", 'ResidentType'>
    readonly block_id: FieldRef<"User", 'Int'>
    readonly is_password_set: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.complaints
   */
  export type User$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * User.blocks
   */
  export type User$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    where?: blocksWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model social_amenities
   */

  export type AggregateSocial_amenities = {
    _count: Social_amenitiesCountAggregateOutputType | null
    _avg: Social_amenitiesAvgAggregateOutputType | null
    _sum: Social_amenitiesSumAggregateOutputType | null
    _min: Social_amenitiesMinAggregateOutputType | null
    _max: Social_amenitiesMaxAggregateOutputType | null
  }

  export type Social_amenitiesAvgAggregateOutputType = {
    siteId: number | null
  }

  export type Social_amenitiesSumAggregateOutputType = {
    siteId: number | null
  }

  export type Social_amenitiesMinAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Social_amenitiesMaxAggregateOutputType = {
    id: string | null
    siteId: number | null
    name: string | null
    description: string | null
    status: string | null
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Social_amenitiesCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    description: number
    status: number
    hours: number
    rules: number
    extra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Social_amenitiesAvgAggregateInputType = {
    siteId?: true
  }

  export type Social_amenitiesSumAggregateInputType = {
    siteId?: true
  }

  export type Social_amenitiesMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Social_amenitiesMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Social_amenitiesCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    description?: true
    status?: true
    hours?: true
    rules?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Social_amenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_amenities to aggregate.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned social_amenities
    **/
    _count?: true | Social_amenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Social_amenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Social_amenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Social_amenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Social_amenitiesMaxAggregateInputType
  }

  export type GetSocial_amenitiesAggregateType<T extends Social_amenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateSocial_amenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocial_amenities[P]>
      : GetScalarType<T[P], AggregateSocial_amenities[P]>
  }




  export type social_amenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_amenitiesWhereInput
    orderBy?: social_amenitiesOrderByWithAggregationInput | social_amenitiesOrderByWithAggregationInput[]
    by: Social_amenitiesScalarFieldEnum[] | Social_amenitiesScalarFieldEnum
    having?: social_amenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Social_amenitiesCountAggregateInputType | true
    _avg?: Social_amenitiesAvgAggregateInputType
    _sum?: Social_amenitiesSumAggregateInputType
    _min?: Social_amenitiesMinAggregateInputType
    _max?: Social_amenitiesMaxAggregateInputType
  }

  export type Social_amenitiesGroupByOutputType = {
    id: string
    siteId: number
    name: string
    description: string | null
    status: string
    hours: string | null
    rules: string | null
    extra: string | null
    createdAt: Date
    updatedAt: Date
    _count: Social_amenitiesCountAggregateOutputType | null
    _avg: Social_amenitiesAvgAggregateOutputType | null
    _sum: Social_amenitiesSumAggregateOutputType | null
    _min: Social_amenitiesMinAggregateOutputType | null
    _max: Social_amenitiesMaxAggregateOutputType | null
  }

  type GetSocial_amenitiesGroupByPayload<T extends social_amenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Social_amenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Social_amenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Social_amenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Social_amenitiesGroupByOutputType[P]>
        }
      >
    >


  export type social_amenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_amenities"]>

  export type social_amenitiesSelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    hours?: boolean
    rules?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type social_amenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteId" | "name" | "description" | "status" | "hours" | "rules" | "extra" | "createdAt" | "updatedAt", ExtArgs["result"]["social_amenities"]>
  export type social_amenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type social_amenitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type social_amenitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $social_amenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "social_amenities"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteId: number
      name: string
      description: string | null
      status: string
      hours: string | null
      rules: string | null
      extra: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["social_amenities"]>
    composites: {}
  }

  type social_amenitiesGetPayload<S extends boolean | null | undefined | social_amenitiesDefaultArgs> = $Result.GetResult<Prisma.$social_amenitiesPayload, S>

  type social_amenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<social_amenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Social_amenitiesCountAggregateInputType | true
    }

  export interface social_amenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['social_amenities'], meta: { name: 'social_amenities' } }
    /**
     * Find zero or one Social_amenities that matches the filter.
     * @param {social_amenitiesFindUniqueArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends social_amenitiesFindUniqueArgs>(args: SelectSubset<T, social_amenitiesFindUniqueArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Social_amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {social_amenitiesFindUniqueOrThrowArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends social_amenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, social_amenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindFirstArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends social_amenitiesFindFirstArgs>(args?: SelectSubset<T, social_amenitiesFindFirstArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindFirstOrThrowArgs} args - Arguments to find a Social_amenities
     * @example
     * // Get one Social_amenities
     * const social_amenities = await prisma.social_amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends social_amenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, social_amenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Social_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Social_amenities
     * const social_amenities = await prisma.social_amenities.findMany()
     * 
     * // Get first 10 Social_amenities
     * const social_amenities = await prisma.social_amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends social_amenitiesFindManyArgs>(args?: SelectSubset<T, social_amenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Social_amenities.
     * @param {social_amenitiesCreateArgs} args - Arguments to create a Social_amenities.
     * @example
     * // Create one Social_amenities
     * const Social_amenities = await prisma.social_amenities.create({
     *   data: {
     *     // ... data to create a Social_amenities
     *   }
     * })
     * 
     */
    create<T extends social_amenitiesCreateArgs>(args: SelectSubset<T, social_amenitiesCreateArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Social_amenities.
     * @param {social_amenitiesCreateManyArgs} args - Arguments to create many Social_amenities.
     * @example
     * // Create many Social_amenities
     * const social_amenities = await prisma.social_amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends social_amenitiesCreateManyArgs>(args?: SelectSubset<T, social_amenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Social_amenities and returns the data saved in the database.
     * @param {social_amenitiesCreateManyAndReturnArgs} args - Arguments to create many Social_amenities.
     * @example
     * // Create many Social_amenities
     * const social_amenities = await prisma.social_amenities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Social_amenities and only return the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends social_amenitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, social_amenitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Social_amenities.
     * @param {social_amenitiesDeleteArgs} args - Arguments to delete one Social_amenities.
     * @example
     * // Delete one Social_amenities
     * const Social_amenities = await prisma.social_amenities.delete({
     *   where: {
     *     // ... filter to delete one Social_amenities
     *   }
     * })
     * 
     */
    delete<T extends social_amenitiesDeleteArgs>(args: SelectSubset<T, social_amenitiesDeleteArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Social_amenities.
     * @param {social_amenitiesUpdateArgs} args - Arguments to update one Social_amenities.
     * @example
     * // Update one Social_amenities
     * const social_amenities = await prisma.social_amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends social_amenitiesUpdateArgs>(args: SelectSubset<T, social_amenitiesUpdateArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Social_amenities.
     * @param {social_amenitiesDeleteManyArgs} args - Arguments to filter Social_amenities to delete.
     * @example
     * // Delete a few Social_amenities
     * const { count } = await prisma.social_amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends social_amenitiesDeleteManyArgs>(args?: SelectSubset<T, social_amenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Social_amenities
     * const social_amenities = await prisma.social_amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends social_amenitiesUpdateManyArgs>(args: SelectSubset<T, social_amenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_amenities and returns the data updated in the database.
     * @param {social_amenitiesUpdateManyAndReturnArgs} args - Arguments to update many Social_amenities.
     * @example
     * // Update many Social_amenities
     * const social_amenities = await prisma.social_amenities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Social_amenities and only return the `id`
     * const social_amenitiesWithIdOnly = await prisma.social_amenities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends social_amenitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, social_amenitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Social_amenities.
     * @param {social_amenitiesUpsertArgs} args - Arguments to update or create a Social_amenities.
     * @example
     * // Update or create a Social_amenities
     * const social_amenities = await prisma.social_amenities.upsert({
     *   create: {
     *     // ... data to create a Social_amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Social_amenities we want to update
     *   }
     * })
     */
    upsert<T extends social_amenitiesUpsertArgs>(args: SelectSubset<T, social_amenitiesUpsertArgs<ExtArgs>>): Prisma__social_amenitiesClient<$Result.GetResult<Prisma.$social_amenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesCountArgs} args - Arguments to filter Social_amenities to count.
     * @example
     * // Count the number of Social_amenities
     * const count = await prisma.social_amenities.count({
     *   where: {
     *     // ... the filter for the Social_amenities we want to count
     *   }
     * })
    **/
    count<T extends social_amenitiesCountArgs>(
      args?: Subset<T, social_amenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Social_amenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Social_amenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Social_amenitiesAggregateArgs>(args: Subset<T, Social_amenitiesAggregateArgs>): Prisma.PrismaPromise<GetSocial_amenitiesAggregateType<T>>

    /**
     * Group by Social_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_amenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends social_amenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: social_amenitiesGroupByArgs['orderBy'] }
        : { orderBy?: social_amenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, social_amenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocial_amenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the social_amenities model
   */
  readonly fields: social_amenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for social_amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__social_amenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the social_amenities model
   */
  interface social_amenitiesFieldRefs {
    readonly id: FieldRef<"social_amenities", 'String'>
    readonly siteId: FieldRef<"social_amenities", 'Int'>
    readonly name: FieldRef<"social_amenities", 'String'>
    readonly description: FieldRef<"social_amenities", 'String'>
    readonly status: FieldRef<"social_amenities", 'String'>
    readonly hours: FieldRef<"social_amenities", 'String'>
    readonly rules: FieldRef<"social_amenities", 'String'>
    readonly extra: FieldRef<"social_amenities", 'String'>
    readonly createdAt: FieldRef<"social_amenities", 'DateTime'>
    readonly updatedAt: FieldRef<"social_amenities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * social_amenities findUnique
   */
  export type social_amenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities findUniqueOrThrow
   */
  export type social_amenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities findFirst
   */
  export type social_amenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_amenities.
     */
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities findFirstOrThrow
   */
  export type social_amenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_amenities.
     */
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities findMany
   */
  export type social_amenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which social_amenities to fetch.
     */
    where?: social_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_amenities to fetch.
     */
    orderBy?: social_amenitiesOrderByWithRelationInput | social_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing social_amenities.
     */
    cursor?: social_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_amenities.
     */
    skip?: number
    distinct?: Social_amenitiesScalarFieldEnum | Social_amenitiesScalarFieldEnum[]
  }

  /**
   * social_amenities create
   */
  export type social_amenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a social_amenities.
     */
    data: XOR<social_amenitiesCreateInput, social_amenitiesUncheckedCreateInput>
  }

  /**
   * social_amenities createMany
   */
  export type social_amenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many social_amenities.
     */
    data: social_amenitiesCreateManyInput | social_amenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * social_amenities createManyAndReturn
   */
  export type social_amenitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * The data used to create many social_amenities.
     */
    data: social_amenitiesCreateManyInput | social_amenitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_amenities update
   */
  export type social_amenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a social_amenities.
     */
    data: XOR<social_amenitiesUpdateInput, social_amenitiesUncheckedUpdateInput>
    /**
     * Choose, which social_amenities to update.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities updateMany
   */
  export type social_amenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update social_amenities.
     */
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which social_amenities to update
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to update.
     */
    limit?: number
  }

  /**
   * social_amenities updateManyAndReturn
   */
  export type social_amenitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * The data used to update social_amenities.
     */
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which social_amenities to update
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_amenities upsert
   */
  export type social_amenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the social_amenities to update in case it exists.
     */
    where: social_amenitiesWhereUniqueInput
    /**
     * In case the social_amenities found by the `where` argument doesn't exist, create a new social_amenities with this data.
     */
    create: XOR<social_amenitiesCreateInput, social_amenitiesUncheckedCreateInput>
    /**
     * In case the social_amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<social_amenitiesUpdateInput, social_amenitiesUncheckedUpdateInput>
  }

  /**
   * social_amenities delete
   */
  export type social_amenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
    /**
     * Filter which social_amenities to delete.
     */
    where: social_amenitiesWhereUniqueInput
  }

  /**
   * social_amenities deleteMany
   */
  export type social_amenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_amenities to delete
     */
    where?: social_amenitiesWhereInput
    /**
     * Limit how many social_amenities to delete.
     */
    limit?: number
  }

  /**
   * social_amenities without action
   */
  export type social_amenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_amenities
     */
    select?: social_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_amenities
     */
    omit?: social_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_amenitiesInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementSumAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    siteId: number | null
    start_date: Date | null
    end_date: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    created_at: number
    updated_at: number
    siteId: number
    start_date: number
    end_date: number
    _all: number
  }


  export type AnnouncementAvgAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementSumAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
    siteId?: true
    start_date?: true
    end_date?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _avg?: AnnouncementAvgAggregateInputType
    _sum?: AnnouncementSumAggregateInputType
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: number
    title: string
    content: string
    created_at: Date
    updated_at: Date
    siteId: number
    start_date: Date
    end_date: Date
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    siteId?: boolean
    start_date?: boolean
    end_date?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "created_at" | "updated_at" | "siteId" | "start_date" | "end_date", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      created_at: Date
      updated_at: Date
      siteId: number
      start_date: Date
      end_date: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'Int'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly created_at: FieldRef<"Announcement", 'DateTime'>
    readonly updated_at: FieldRef<"Announcement", 'DateTime'>
    readonly siteId: FieldRef<"Announcement", 'Int'>
    readonly start_date: FieldRef<"Announcement", 'DateTime'>
    readonly end_date: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    userId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: $Enums.Status | null
    siteId: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    category: $Enums.Category | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    title: number
    content: number
    status: number
    siteId: number
    userId: number
    created_at: number
    updated_at: number
    category: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    siteId?: true
    userId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    siteId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    category?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    title: string
    content: string
    status: $Enums.Status
    siteId: number
    userId: number
    created_at: Date
    updated_at: Date
    category: $Enums.Category | null
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    siteId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "status" | "siteId" | "userId" | "created_at" | "updated_at" | "category", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComplaintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComplaintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | SiteDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      site: Prisma.$SitePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      status: $Enums.Status
      siteId: number
      userId: number
      created_at: Date
      updated_at: Date
      category: $Enums.Category | null
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {ComplaintCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintWithIdOnly = await prisma.complaint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints and returns the data updated in the database.
     * @param {ComplaintUpdateManyAndReturnArgs} args - Arguments to update many Complaints.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Complaints and only return the `id`
     * const complaintWithIdOnly = await prisma.complaint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplaintUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplaintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly title: FieldRef<"Complaint", 'String'>
    readonly content: FieldRef<"Complaint", 'String'>
    readonly status: FieldRef<"Complaint", 'Status'>
    readonly siteId: FieldRef<"Complaint", 'Int'>
    readonly userId: FieldRef<"Complaint", 'Int'>
    readonly created_at: FieldRef<"Complaint", 'DateTime'>
    readonly updated_at: FieldRef<"Complaint", 'DateTime'>
    readonly category: FieldRef<"Complaint", 'Category'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint createManyAndReturn
   */
  export type ComplaintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint updateManyAndReturn
   */
  export type ComplaintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    id: number | null
    site_id: number | null
  }

  export type BlocksSumAggregateOutputType = {
    id: number | null
    site_id: number | null
  }

  export type BlocksMinAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
  }

  export type BlocksMaxAggregateOutputType = {
    id: number | null
    block_name: string | null
    site_id: number | null
    created_at: Date | null
  }

  export type BlocksCountAggregateOutputType = {
    id: number
    block_name: number
    site_id: number
    created_at: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    id?: true
    site_id?: true
  }

  export type BlocksSumAggregateInputType = {
    id?: true
    site_id?: true
  }

  export type BlocksMinAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
  }

  export type BlocksMaxAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
  }

  export type BlocksCountAggregateInputType = {
    id?: true
    block_name?: true
    site_id?: true
    created_at?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to aggregate.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type blocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithAggregationInput | blocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    id: number
    block_name: string
    site_id: number
    created_at: Date
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends blocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectScalar = {
    id?: boolean
    block_name?: boolean
    site_id?: boolean
    created_at?: boolean
  }

  export type blocksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block_name" | "site_id" | "created_at", ExtArgs["result"]["blocks"]>
  export type blocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
    users?: boolean | blocks$usersArgs<ExtArgs>
    _count?: boolean | BlocksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type blocksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type blocksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $blocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blocks"
    objects: {
      sites: Prisma.$SitePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block_name: string
      site_id: number
      created_at: Date
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }

  type blocksGetPayload<S extends boolean | null | undefined | blocksDefaultArgs> = $Result.GetResult<Prisma.$blocksPayload, S>

  type blocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blocksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface blocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blocks'], meta: { name: 'blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blocksFindUniqueArgs>(args: SelectSubset<T, blocksFindUniqueArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs>(args: SelectSubset<T, blocksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blocksFindFirstArgs>(args?: SelectSubset<T, blocksFindFirstArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs>(args?: SelectSubset<T, blocksFindFirstOrThrowArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blocksWithIdOnly = await prisma.blocks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blocksFindManyArgs>(args?: SelectSubset<T, blocksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
     */
    create<T extends blocksCreateArgs>(args: SelectSubset<T, blocksCreateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blocksCreateManyArgs>(args?: SelectSubset<T, blocksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {blocksCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blocksCreateManyAndReturnArgs>(args?: SelectSubset<T, blocksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
     */
    delete<T extends blocksDeleteArgs>(args: SelectSubset<T, blocksDeleteArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blocksUpdateArgs>(args: SelectSubset<T, blocksUpdateArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blocksDeleteManyArgs>(args?: SelectSubset<T, blocksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blocksUpdateManyArgs>(args: SelectSubset<T, blocksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {blocksUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blocksWithIdOnly = await prisma.blocks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blocksUpdateManyAndReturnArgs>(args: SelectSubset<T, blocksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
     */
    upsert<T extends blocksUpsertArgs>(args: SelectSubset<T, blocksUpsertArgs<ExtArgs>>): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blocksGroupByArgs['orderBy'] }
        : { orderBy?: blocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blocks model
   */
  readonly fields: blocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends blocks$usersArgs<ExtArgs> = {}>(args?: Subset<T, blocks$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blocks model
   */
  interface blocksFieldRefs {
    readonly id: FieldRef<"blocks", 'Int'>
    readonly block_name: FieldRef<"blocks", 'String'>
    readonly site_id: FieldRef<"blocks", 'Int'>
    readonly created_at: FieldRef<"blocks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blocks findUnique
   */
  export type blocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks findFirst
   */
  export type blocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks findMany
   */
  export type blocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * blocks create
   */
  export type blocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to create a blocks.
     */
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }

  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blocks createManyAndReturn
   */
  export type blocksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks update
   */
  export type blocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The data needed to update a blocks.
     */
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
  }

  /**
   * blocks updateManyAndReturn
   */
  export type blocksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * blocks upsert
   */
  export type blocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * The filter to search for the blocks to update in case it exists.
     */
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     */
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }

  /**
   * blocks delete
   */
  export type blocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
    /**
     * Filter which blocks to delete.
     */
    where: blocksWhereUniqueInput
  }

  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blocksWhereInput
    /**
     * Limit how many blocks to delete.
     */
    limit?: number
  }

  /**
   * blocks.users
   */
  export type blocks$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * blocks without action
   */
  export type blocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blocks
     */
    omit?: blocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blocksInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
    manager_id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number | null
    manager_id: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    manager_id: number | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number | null
    company_name: string | null
    company_code: string | null
    account_status: $Enums.AccountStatus | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    manager_id: number | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    company_name: number
    company_code: number
    account_status: number
    created_at: number
    updated_at: number
    deleted_at: number
    manager_id: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    manager_id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    manager_id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    company_name?: true
    company_code?: true
    account_status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    manager_id?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: number
    company_name: string
    company_code: string
    account_status: $Enums.AccountStatus
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    manager_id: number
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    company_name?: boolean
    company_code?: boolean
    account_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    manager_id?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "company_code" | "account_status" | "created_at" | "updated_at" | "deleted_at" | "manager_id", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    company_employees?: boolean | companies$company_employeesArgs<ExtArgs>
    invitations?: boolean | companies$invitationsArgs<ExtArgs>
    sites?: boolean | companies$sitesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>
      company_employees: Prisma.$company_employeesPayload<ExtArgs>[]
      invitations: Prisma.$invitationsPayload<ExtArgs>[]
      sites: Prisma.$SitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_name: string
      company_code: string
      account_status: $Enums.AccountStatus
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      manager_id: number
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company_employees<T extends companies$company_employeesArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends companies$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, companies$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sites<T extends companies$sitesArgs<ExtArgs> = {}>(args?: Subset<T, companies$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'Int'>
    readonly company_name: FieldRef<"companies", 'String'>
    readonly company_code: FieldRef<"companies", 'String'>
    readonly account_status: FieldRef<"companies", 'AccountStatus'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
    readonly deleted_at: FieldRef<"companies", 'DateTime'>
    readonly manager_id: FieldRef<"companies", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.company_employees
   */
  export type companies$company_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    cursor?: company_employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * companies.invitations
   */
  export type companies$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    cursor?: invitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * companies.sites
   */
  export type companies$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model company_employees
   */

  export type AggregateCompany_employees = {
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  export type Company_employeesAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
  }

  export type Company_employeesMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
  }

  export type Company_employeesMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    company_id: number | null
    joined_at: Date | null
    status: $Enums.AccountStatus | null
  }

  export type Company_employeesCountAggregateOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: number
    status: number
    _all: number
  }


  export type Company_employeesAvgAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesSumAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
  }

  export type Company_employeesMinAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
  }

  export type Company_employeesMaxAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
  }

  export type Company_employeesCountAggregateInputType = {
    id?: true
    admin_id?: true
    company_id?: true
    joined_at?: true
    status?: true
    _all?: true
  }

  export type Company_employeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to aggregate.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_employees
    **/
    _count?: true | Company_employeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_employeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_employeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_employeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_employeesMaxAggregateInputType
  }

  export type GetCompany_employeesAggregateType<T extends Company_employeesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_employees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_employees[P]>
      : GetScalarType<T[P], AggregateCompany_employees[P]>
  }




  export type company_employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_employeesWhereInput
    orderBy?: company_employeesOrderByWithAggregationInput | company_employeesOrderByWithAggregationInput[]
    by: Company_employeesScalarFieldEnum[] | Company_employeesScalarFieldEnum
    having?: company_employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_employeesCountAggregateInputType | true
    _avg?: Company_employeesAvgAggregateInputType
    _sum?: Company_employeesSumAggregateInputType
    _min?: Company_employeesMinAggregateInputType
    _max?: Company_employeesMaxAggregateInputType
  }

  export type Company_employeesGroupByOutputType = {
    id: number
    admin_id: number
    company_id: number
    joined_at: Date
    status: $Enums.AccountStatus
    _count: Company_employeesCountAggregateOutputType | null
    _avg: Company_employeesAvgAggregateOutputType | null
    _sum: Company_employeesSumAggregateOutputType | null
    _min: Company_employeesMinAggregateOutputType | null
    _max: Company_employeesMaxAggregateOutputType | null
  }

  type GetCompany_employeesGroupByPayload<T extends company_employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_employeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_employeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_employeesGroupByOutputType[P]>
        }
      >
    >


  export type company_employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_employees"]>

  export type company_employeesSelectScalar = {
    id?: boolean
    admin_id?: boolean
    company_id?: boolean
    joined_at?: boolean
    status?: boolean
  }

  export type company_employeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "company_id" | "joined_at" | "status", ExtArgs["result"]["company_employees"]>
  export type company_employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    employee_site_access?: boolean | company_employees$employee_site_accessArgs<ExtArgs>
    _count?: boolean | Company_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type company_employeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admins?: boolean | AdminDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_employees"
    objects: {
      admins: Prisma.$AdminPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      employee_site_access: Prisma.$employee_site_accessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      company_id: number
      joined_at: Date
      status: $Enums.AccountStatus
    }, ExtArgs["result"]["company_employees"]>
    composites: {}
  }

  type company_employeesGetPayload<S extends boolean | null | undefined | company_employeesDefaultArgs> = $Result.GetResult<Prisma.$company_employeesPayload, S>

  type company_employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_employeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_employeesCountAggregateInputType | true
    }

  export interface company_employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_employees'], meta: { name: 'company_employees' } }
    /**
     * Find zero or one Company_employees that matches the filter.
     * @param {company_employeesFindUniqueArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_employeesFindUniqueArgs>(args: SelectSubset<T, company_employeesFindUniqueArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_employeesFindUniqueOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_employeesFindFirstArgs>(args?: SelectSubset<T, company_employeesFindFirstArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindFirstOrThrowArgs} args - Arguments to find a Company_employees
     * @example
     * // Get one Company_employees
     * const company_employees = await prisma.company_employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_employees
     * const company_employees = await prisma.company_employees.findMany()
     * 
     * // Get first 10 Company_employees
     * const company_employees = await prisma.company_employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_employeesFindManyArgs>(args?: SelectSubset<T, company_employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_employees.
     * @param {company_employeesCreateArgs} args - Arguments to create a Company_employees.
     * @example
     * // Create one Company_employees
     * const Company_employees = await prisma.company_employees.create({
     *   data: {
     *     // ... data to create a Company_employees
     *   }
     * })
     * 
     */
    create<T extends company_employeesCreateArgs>(args: SelectSubset<T, company_employeesCreateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_employees.
     * @param {company_employeesCreateManyArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_employeesCreateManyArgs>(args?: SelectSubset<T, company_employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_employees and returns the data saved in the database.
     * @param {company_employeesCreateManyAndReturnArgs} args - Arguments to create many Company_employees.
     * @example
     * // Create many Company_employees
     * const company_employees = await prisma.company_employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_employeesCreateManyAndReturnArgs>(args?: SelectSubset<T, company_employeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_employees.
     * @param {company_employeesDeleteArgs} args - Arguments to delete one Company_employees.
     * @example
     * // Delete one Company_employees
     * const Company_employees = await prisma.company_employees.delete({
     *   where: {
     *     // ... filter to delete one Company_employees
     *   }
     * })
     * 
     */
    delete<T extends company_employeesDeleteArgs>(args: SelectSubset<T, company_employeesDeleteArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_employees.
     * @param {company_employeesUpdateArgs} args - Arguments to update one Company_employees.
     * @example
     * // Update one Company_employees
     * const company_employees = await prisma.company_employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_employeesUpdateArgs>(args: SelectSubset<T, company_employeesUpdateArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_employees.
     * @param {company_employeesDeleteManyArgs} args - Arguments to filter Company_employees to delete.
     * @example
     * // Delete a few Company_employees
     * const { count } = await prisma.company_employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_employeesDeleteManyArgs>(args?: SelectSubset<T, company_employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_employeesUpdateManyArgs>(args: SelectSubset<T, company_employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_employees and returns the data updated in the database.
     * @param {company_employeesUpdateManyAndReturnArgs} args - Arguments to update many Company_employees.
     * @example
     * // Update many Company_employees
     * const company_employees = await prisma.company_employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_employees and only return the `id`
     * const company_employeesWithIdOnly = await prisma.company_employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_employeesUpdateManyAndReturnArgs>(args: SelectSubset<T, company_employeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_employees.
     * @param {company_employeesUpsertArgs} args - Arguments to update or create a Company_employees.
     * @example
     * // Update or create a Company_employees
     * const company_employees = await prisma.company_employees.upsert({
     *   create: {
     *     // ... data to create a Company_employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_employees we want to update
     *   }
     * })
     */
    upsert<T extends company_employeesUpsertArgs>(args: SelectSubset<T, company_employeesUpsertArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesCountArgs} args - Arguments to filter Company_employees to count.
     * @example
     * // Count the number of Company_employees
     * const count = await prisma.company_employees.count({
     *   where: {
     *     // ... the filter for the Company_employees we want to count
     *   }
     * })
    **/
    count<T extends company_employeesCountArgs>(
      args?: Subset<T, company_employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_employeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_employeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_employeesAggregateArgs>(args: Subset<T, Company_employeesAggregateArgs>): Prisma.PrismaPromise<GetCompany_employeesAggregateType<T>>

    /**
     * Group by Company_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_employeesGroupByArgs['orderBy'] }
        : { orderBy?: company_employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_employeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_employees model
   */
  readonly fields: company_employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admins<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee_site_access<T extends company_employees$employee_site_accessArgs<ExtArgs> = {}>(args?: Subset<T, company_employees$employee_site_accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_employees model
   */
  interface company_employeesFieldRefs {
    readonly id: FieldRef<"company_employees", 'Int'>
    readonly admin_id: FieldRef<"company_employees", 'Int'>
    readonly company_id: FieldRef<"company_employees", 'Int'>
    readonly joined_at: FieldRef<"company_employees", 'DateTime'>
    readonly status: FieldRef<"company_employees", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * company_employees findUnique
   */
  export type company_employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findUniqueOrThrow
   */
  export type company_employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees findFirst
   */
  export type company_employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findFirstOrThrow
   */
  export type company_employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_employees.
     */
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees findMany
   */
  export type company_employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter, which company_employees to fetch.
     */
    where?: company_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_employees to fetch.
     */
    orderBy?: company_employeesOrderByWithRelationInput | company_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_employees.
     */
    cursor?: company_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_employees.
     */
    skip?: number
    distinct?: Company_employeesScalarFieldEnum | Company_employeesScalarFieldEnum[]
  }

  /**
   * company_employees create
   */
  export type company_employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_employees.
     */
    data: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
  }

  /**
   * company_employees createMany
   */
  export type company_employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_employees createManyAndReturn
   */
  export type company_employeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to create many company_employees.
     */
    data: company_employeesCreateManyInput | company_employeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees update
   */
  export type company_employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_employees.
     */
    data: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
    /**
     * Choose, which company_employees to update.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees updateMany
   */
  export type company_employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
  }

  /**
   * company_employees updateManyAndReturn
   */
  export type company_employeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * The data used to update company_employees.
     */
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyInput>
    /**
     * Filter which company_employees to update
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_employees upsert
   */
  export type company_employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_employees to update in case it exists.
     */
    where: company_employeesWhereUniqueInput
    /**
     * In case the company_employees found by the `where` argument doesn't exist, create a new company_employees with this data.
     */
    create: XOR<company_employeesCreateInput, company_employeesUncheckedCreateInput>
    /**
     * In case the company_employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_employeesUpdateInput, company_employeesUncheckedUpdateInput>
  }

  /**
   * company_employees delete
   */
  export type company_employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
    /**
     * Filter which company_employees to delete.
     */
    where: company_employeesWhereUniqueInput
  }

  /**
   * company_employees deleteMany
   */
  export type company_employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_employees to delete
     */
    where?: company_employeesWhereInput
    /**
     * Limit how many company_employees to delete.
     */
    limit?: number
  }

  /**
   * company_employees.employee_site_access
   */
  export type company_employees$employee_site_accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    cursor?: employee_site_accessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * company_employees without action
   */
  export type company_employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_employees
     */
    select?: company_employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_employees
     */
    omit?: company_employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_employeesInclude<ExtArgs> | null
  }


  /**
   * Model employee_site_access
   */

  export type AggregateEmployee_site_access = {
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  export type Employee_site_accessAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
  }

  export type Employee_site_accessMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
  }

  export type Employee_site_accessMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    site_id: number | null
    granted_at: Date | null
  }

  export type Employee_site_accessCountAggregateOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: number
    _all: number
  }


  export type Employee_site_accessAvgAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessSumAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
  }

  export type Employee_site_accessMinAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
  }

  export type Employee_site_accessMaxAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
  }

  export type Employee_site_accessCountAggregateInputType = {
    id?: true
    employee_id?: true
    site_id?: true
    granted_at?: true
    _all?: true
  }

  export type Employee_site_accessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_access to aggregate.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employee_site_accesses
    **/
    _count?: true | Employee_site_accessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Employee_site_accessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Employee_site_accessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_site_accessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type GetEmployee_site_accessAggregateType<T extends Employee_site_accessAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_site_access]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_site_access[P]>
      : GetScalarType<T[P], AggregateEmployee_site_access[P]>
  }




  export type employee_site_accessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_site_accessWhereInput
    orderBy?: employee_site_accessOrderByWithAggregationInput | employee_site_accessOrderByWithAggregationInput[]
    by: Employee_site_accessScalarFieldEnum[] | Employee_site_accessScalarFieldEnum
    having?: employee_site_accessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_site_accessCountAggregateInputType | true
    _avg?: Employee_site_accessAvgAggregateInputType
    _sum?: Employee_site_accessSumAggregateInputType
    _min?: Employee_site_accessMinAggregateInputType
    _max?: Employee_site_accessMaxAggregateInputType
  }

  export type Employee_site_accessGroupByOutputType = {
    id: number
    employee_id: number
    site_id: number
    granted_at: Date
    _count: Employee_site_accessCountAggregateOutputType | null
    _avg: Employee_site_accessAvgAggregateOutputType | null
    _sum: Employee_site_accessSumAggregateOutputType | null
    _min: Employee_site_accessMinAggregateOutputType | null
    _max: Employee_site_accessMaxAggregateOutputType | null
  }

  type GetEmployee_site_accessGroupByPayload<T extends employee_site_accessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_site_accessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_site_accessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_site_accessGroupByOutputType[P]>
        }
      >
    >


  export type employee_site_accessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_site_access"]>

  export type employee_site_accessSelectScalar = {
    id?: boolean
    employee_id?: boolean
    site_id?: boolean
    granted_at?: boolean
  }

  export type employee_site_accessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "site_id" | "granted_at", ExtArgs["result"]["employee_site_access"]>
  export type employee_site_accessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type employee_site_accessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_employees?: boolean | company_employeesDefaultArgs<ExtArgs>
    sites?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $employee_site_accessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee_site_access"
    objects: {
      company_employees: Prisma.$company_employeesPayload<ExtArgs>
      sites: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number
      site_id: number
      granted_at: Date
    }, ExtArgs["result"]["employee_site_access"]>
    composites: {}
  }

  type employee_site_accessGetPayload<S extends boolean | null | undefined | employee_site_accessDefaultArgs> = $Result.GetResult<Prisma.$employee_site_accessPayload, S>

  type employee_site_accessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employee_site_accessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Employee_site_accessCountAggregateInputType | true
    }

  export interface employee_site_accessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee_site_access'], meta: { name: 'employee_site_access' } }
    /**
     * Find zero or one Employee_site_access that matches the filter.
     * @param {employee_site_accessFindUniqueArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employee_site_accessFindUniqueArgs>(args: SelectSubset<T, employee_site_accessFindUniqueArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee_site_access that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employee_site_accessFindUniqueOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employee_site_accessFindUniqueOrThrowArgs>(args: SelectSubset<T, employee_site_accessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employee_site_accessFindFirstArgs>(args?: SelectSubset<T, employee_site_accessFindFirstArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_site_access that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindFirstOrThrowArgs} args - Arguments to find a Employee_site_access
     * @example
     * // Get one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employee_site_accessFindFirstOrThrowArgs>(args?: SelectSubset<T, employee_site_accessFindFirstOrThrowArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employee_site_accesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany()
     * 
     * // Get first 10 Employee_site_accesses
     * const employee_site_accesses = await prisma.employee_site_access.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employee_site_accessFindManyArgs>(args?: SelectSubset<T, employee_site_accessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee_site_access.
     * @param {employee_site_accessCreateArgs} args - Arguments to create a Employee_site_access.
     * @example
     * // Create one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.create({
     *   data: {
     *     // ... data to create a Employee_site_access
     *   }
     * })
     * 
     */
    create<T extends employee_site_accessCreateArgs>(args: SelectSubset<T, employee_site_accessCreateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employee_site_accesses.
     * @param {employee_site_accessCreateManyArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employee_site_accessCreateManyArgs>(args?: SelectSubset<T, employee_site_accessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employee_site_accesses and returns the data saved in the database.
     * @param {employee_site_accessCreateManyAndReturnArgs} args - Arguments to create many Employee_site_accesses.
     * @example
     * // Create many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employee_site_accessCreateManyAndReturnArgs>(args?: SelectSubset<T, employee_site_accessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee_site_access.
     * @param {employee_site_accessDeleteArgs} args - Arguments to delete one Employee_site_access.
     * @example
     * // Delete one Employee_site_access
     * const Employee_site_access = await prisma.employee_site_access.delete({
     *   where: {
     *     // ... filter to delete one Employee_site_access
     *   }
     * })
     * 
     */
    delete<T extends employee_site_accessDeleteArgs>(args: SelectSubset<T, employee_site_accessDeleteArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee_site_access.
     * @param {employee_site_accessUpdateArgs} args - Arguments to update one Employee_site_access.
     * @example
     * // Update one Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employee_site_accessUpdateArgs>(args: SelectSubset<T, employee_site_accessUpdateArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employee_site_accesses.
     * @param {employee_site_accessDeleteManyArgs} args - Arguments to filter Employee_site_accesses to delete.
     * @example
     * // Delete a few Employee_site_accesses
     * const { count } = await prisma.employee_site_access.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employee_site_accessDeleteManyArgs>(args?: SelectSubset<T, employee_site_accessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employee_site_accessUpdateManyArgs>(args: SelectSubset<T, employee_site_accessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_site_accesses and returns the data updated in the database.
     * @param {employee_site_accessUpdateManyAndReturnArgs} args - Arguments to update many Employee_site_accesses.
     * @example
     * // Update many Employee_site_accesses
     * const employee_site_access = await prisma.employee_site_access.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employee_site_accesses and only return the `id`
     * const employee_site_accessWithIdOnly = await prisma.employee_site_access.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employee_site_accessUpdateManyAndReturnArgs>(args: SelectSubset<T, employee_site_accessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee_site_access.
     * @param {employee_site_accessUpsertArgs} args - Arguments to update or create a Employee_site_access.
     * @example
     * // Update or create a Employee_site_access
     * const employee_site_access = await prisma.employee_site_access.upsert({
     *   create: {
     *     // ... data to create a Employee_site_access
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_site_access we want to update
     *   }
     * })
     */
    upsert<T extends employee_site_accessUpsertArgs>(args: SelectSubset<T, employee_site_accessUpsertArgs<ExtArgs>>): Prisma__employee_site_accessClient<$Result.GetResult<Prisma.$employee_site_accessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employee_site_accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessCountArgs} args - Arguments to filter Employee_site_accesses to count.
     * @example
     * // Count the number of Employee_site_accesses
     * const count = await prisma.employee_site_access.count({
     *   where: {
     *     // ... the filter for the Employee_site_accesses we want to count
     *   }
     * })
    **/
    count<T extends employee_site_accessCountArgs>(
      args?: Subset<T, employee_site_accessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_site_accessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_site_accessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_site_accessAggregateArgs>(args: Subset<T, Employee_site_accessAggregateArgs>): Prisma.PrismaPromise<GetEmployee_site_accessAggregateType<T>>

    /**
     * Group by Employee_site_access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_site_accessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employee_site_accessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employee_site_accessGroupByArgs['orderBy'] }
        : { orderBy?: employee_site_accessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employee_site_accessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_site_accessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee_site_access model
   */
  readonly fields: employee_site_accessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee_site_access.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employee_site_accessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_employees<T extends company_employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, company_employeesDefaultArgs<ExtArgs>>): Prisma__company_employeesClient<$Result.GetResult<Prisma.$company_employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sites<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee_site_access model
   */
  interface employee_site_accessFieldRefs {
    readonly id: FieldRef<"employee_site_access", 'Int'>
    readonly employee_id: FieldRef<"employee_site_access", 'Int'>
    readonly site_id: FieldRef<"employee_site_access", 'Int'>
    readonly granted_at: FieldRef<"employee_site_access", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employee_site_access findUnique
   */
  export type employee_site_accessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findUniqueOrThrow
   */
  export type employee_site_accessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access findFirst
   */
  export type employee_site_accessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findFirstOrThrow
   */
  export type employee_site_accessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_access to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_site_accesses.
     */
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access findMany
   */
  export type employee_site_accessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter, which employee_site_accesses to fetch.
     */
    where?: employee_site_accessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_site_accesses to fetch.
     */
    orderBy?: employee_site_accessOrderByWithRelationInput | employee_site_accessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employee_site_accesses.
     */
    cursor?: employee_site_accessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_site_accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_site_accesses.
     */
    skip?: number
    distinct?: Employee_site_accessScalarFieldEnum | Employee_site_accessScalarFieldEnum[]
  }

  /**
   * employee_site_access create
   */
  export type employee_site_accessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to create a employee_site_access.
     */
    data: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
  }

  /**
   * employee_site_access createMany
   */
  export type employee_site_accessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee_site_access createManyAndReturn
   */
  export type employee_site_accessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to create many employee_site_accesses.
     */
    data: employee_site_accessCreateManyInput | employee_site_accessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access update
   */
  export type employee_site_accessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The data needed to update a employee_site_access.
     */
    data: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
    /**
     * Choose, which employee_site_access to update.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access updateMany
   */
  export type employee_site_accessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
  }

  /**
   * employee_site_access updateManyAndReturn
   */
  export type employee_site_accessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * The data used to update employee_site_accesses.
     */
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyInput>
    /**
     * Filter which employee_site_accesses to update
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee_site_access upsert
   */
  export type employee_site_accessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * The filter to search for the employee_site_access to update in case it exists.
     */
    where: employee_site_accessWhereUniqueInput
    /**
     * In case the employee_site_access found by the `where` argument doesn't exist, create a new employee_site_access with this data.
     */
    create: XOR<employee_site_accessCreateInput, employee_site_accessUncheckedCreateInput>
    /**
     * In case the employee_site_access was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employee_site_accessUpdateInput, employee_site_accessUncheckedUpdateInput>
  }

  /**
   * employee_site_access delete
   */
  export type employee_site_accessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
    /**
     * Filter which employee_site_access to delete.
     */
    where: employee_site_accessWhereUniqueInput
  }

  /**
   * employee_site_access deleteMany
   */
  export type employee_site_accessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_site_accesses to delete
     */
    where?: employee_site_accessWhereInput
    /**
     * Limit how many employee_site_accesses to delete.
     */
    limit?: number
  }

  /**
   * employee_site_access without action
   */
  export type employee_site_accessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_site_access
     */
    select?: employee_site_accessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_site_access
     */
    omit?: employee_site_accessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_site_accessInclude<ExtArgs> | null
  }


  /**
   * Model invitations
   */

  export type AggregateInvitations = {
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  export type InvitationsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsSumAggregateOutputType = {
    id: number | null
    company_id: number | null
    invited_by: number | null
    used_by: number | null
  }

  export type InvitationsMinAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsMaxAggregateOutputType = {
    id: number | null
    company_id: number | null
    invite_code: string | null
    invite_link: string | null
    invited_email: string | null
    invited_by: number | null
    status: $Enums.InvitationStatus | null
    expires_at: Date | null
    used_at: Date | null
    used_by: number | null
    created_at: Date | null
  }

  export type InvitationsCountAggregateOutputType = {
    id: number
    company_id: number
    invite_code: number
    invite_link: number
    invited_email: number
    invited_by: number
    status: number
    expires_at: number
    used_at: number
    used_by: number
    created_at: number
    _all: number
  }


  export type InvitationsAvgAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsSumAggregateInputType = {
    id?: true
    company_id?: true
    invited_by?: true
    used_by?: true
  }

  export type InvitationsMinAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
  }

  export type InvitationsCountAggregateInputType = {
    id?: true
    company_id?: true
    invite_code?: true
    invite_link?: true
    invited_email?: true
    invited_by?: true
    status?: true
    expires_at?: true
    used_at?: true
    used_by?: true
    created_at?: true
    _all?: true
  }

  export type InvitationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to aggregate.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invitations
    **/
    _count?: true | InvitationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationsMaxAggregateInputType
  }

  export type GetInvitationsAggregateType<T extends InvitationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitations[P]>
      : GetScalarType<T[P], AggregateInvitations[P]>
  }




  export type invitationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithAggregationInput | invitationsOrderByWithAggregationInput[]
    by: InvitationsScalarFieldEnum[] | InvitationsScalarFieldEnum
    having?: invitationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationsCountAggregateInputType | true
    _avg?: InvitationsAvgAggregateInputType
    _sum?: InvitationsSumAggregateInputType
    _min?: InvitationsMinAggregateInputType
    _max?: InvitationsMaxAggregateInputType
  }

  export type InvitationsGroupByOutputType = {
    id: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email: string | null
    invited_by: number
    status: $Enums.InvitationStatus
    expires_at: Date
    used_at: Date | null
    used_by: number | null
    created_at: Date
    _count: InvitationsCountAggregateOutputType | null
    _avg: InvitationsAvgAggregateOutputType | null
    _sum: InvitationsSumAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  type GetInvitationsGroupByPayload<T extends invitationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
        }
      >
    >


  export type invitationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    invite_code?: boolean
    invite_link?: boolean
    invited_email?: boolean
    invited_by?: boolean
    status?: boolean
    expires_at?: boolean
    used_at?: boolean
    used_by?: boolean
    created_at?: boolean
  }

  export type invitationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "invite_code" | "invite_link" | "invited_email" | "invited_by" | "status" | "expires_at" | "used_at" | "used_by" | "created_at", ExtArgs["result"]["invitations"]>
  export type invitationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $invitationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invitations"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: number
      invite_code: string
      invite_link: string
      invited_email: string | null
      invited_by: number
      status: $Enums.InvitationStatus
      expires_at: Date
      used_at: Date | null
      used_by: number | null
      created_at: Date
    }, ExtArgs["result"]["invitations"]>
    composites: {}
  }

  type invitationsGetPayload<S extends boolean | null | undefined | invitationsDefaultArgs> = $Result.GetResult<Prisma.$invitationsPayload, S>

  type invitationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invitationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationsCountAggregateInputType | true
    }

  export interface invitationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invitations'], meta: { name: 'invitations' } }
    /**
     * Find zero or one Invitations that matches the filter.
     * @param {invitationsFindUniqueArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invitationsFindUniqueArgs>(args: SelectSubset<T, invitationsFindUniqueArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invitationsFindUniqueOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invitationsFindUniqueOrThrowArgs>(args: SelectSubset<T, invitationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invitationsFindFirstArgs>(args?: SelectSubset<T, invitationsFindFirstArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invitationsFindFirstOrThrowArgs>(args?: SelectSubset<T, invitationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitations.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationsWithIdOnly = await prisma.invitations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invitationsFindManyArgs>(args?: SelectSubset<T, invitationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitations.
     * @param {invitationsCreateArgs} args - Arguments to create a Invitations.
     * @example
     * // Create one Invitations
     * const Invitations = await prisma.invitations.create({
     *   data: {
     *     // ... data to create a Invitations
     *   }
     * })
     * 
     */
    create<T extends invitationsCreateArgs>(args: SelectSubset<T, invitationsCreateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {invitationsCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invitationsCreateManyArgs>(args?: SelectSubset<T, invitationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {invitationsCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invitationsCreateManyAndReturnArgs>(args?: SelectSubset<T, invitationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitations.
     * @param {invitationsDeleteArgs} args - Arguments to delete one Invitations.
     * @example
     * // Delete one Invitations
     * const Invitations = await prisma.invitations.delete({
     *   where: {
     *     // ... filter to delete one Invitations
     *   }
     * })
     * 
     */
    delete<T extends invitationsDeleteArgs>(args: SelectSubset<T, invitationsDeleteArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitations.
     * @param {invitationsUpdateArgs} args - Arguments to update one Invitations.
     * @example
     * // Update one Invitations
     * const invitations = await prisma.invitations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invitationsUpdateArgs>(args: SelectSubset<T, invitationsUpdateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {invitationsDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invitationsDeleteManyArgs>(args?: SelectSubset<T, invitationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invitationsUpdateManyArgs>(args: SelectSubset<T, invitationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {invitationsUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invitationsUpdateManyAndReturnArgs>(args: SelectSubset<T, invitationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitations.
     * @param {invitationsUpsertArgs} args - Arguments to update or create a Invitations.
     * @example
     * // Update or create a Invitations
     * const invitations = await prisma.invitations.upsert({
     *   create: {
     *     // ... data to create a Invitations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitations we want to update
     *   }
     * })
     */
    upsert<T extends invitationsUpsertArgs>(args: SelectSubset<T, invitationsUpsertArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitations.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends invitationsCountArgs>(
      args?: Subset<T, invitationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationsAggregateArgs>(args: Subset<T, InvitationsAggregateArgs>): Prisma.PrismaPromise<GetInvitationsAggregateType<T>>

    /**
     * Group by Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invitationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invitationsGroupByArgs['orderBy'] }
        : { orderBy?: invitationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invitationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invitations model
   */
  readonly fields: invitationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invitations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invitationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invitations model
   */
  interface invitationsFieldRefs {
    readonly id: FieldRef<"invitations", 'Int'>
    readonly company_id: FieldRef<"invitations", 'Int'>
    readonly invite_code: FieldRef<"invitations", 'String'>
    readonly invite_link: FieldRef<"invitations", 'String'>
    readonly invited_email: FieldRef<"invitations", 'String'>
    readonly invited_by: FieldRef<"invitations", 'Int'>
    readonly status: FieldRef<"invitations", 'InvitationStatus'>
    readonly expires_at: FieldRef<"invitations", 'DateTime'>
    readonly used_at: FieldRef<"invitations", 'DateTime'>
    readonly used_by: FieldRef<"invitations", 'Int'>
    readonly created_at: FieldRef<"invitations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invitations findUnique
   */
  export type invitationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findUniqueOrThrow
   */
  export type invitationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findFirst
   */
  export type invitationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findFirstOrThrow
   */
  export type invitationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findMany
   */
  export type invitationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations create
   */
  export type invitationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to create a invitations.
     */
    data: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
  }

  /**
   * invitations createMany
   */
  export type invitationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invitations createManyAndReturn
   */
  export type invitationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations update
   */
  export type invitationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to update a invitations.
     */
    data: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
    /**
     * Choose, which invitations to update.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations updateMany
   */
  export type invitationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
  }

  /**
   * invitations updateManyAndReturn
   */
  export type invitationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations upsert
   */
  export type invitationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The filter to search for the invitations to update in case it exists.
     */
    where: invitationsWhereUniqueInput
    /**
     * In case the invitations found by the `where` argument doesn't exist, create a new invitations with this data.
     */
    create: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
    /**
     * In case the invitations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
  }

  /**
   * invitations delete
   */
  export type invitationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter which invitations to delete.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations deleteMany
   */
  export type invitationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to delete
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to delete.
     */
    limit?: number
  }

  /**
   * invitations without action
   */
  export type invitationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.PaymentMethod | null
    description: string | null
    created_at: Date | null
    userId: number | null
    siteId: number | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    amount: number
    payment_date: number
    payment_method: number
    description: number
    created_at: number
    userId: number
    siteId: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    description?: true
    created_at?: true
    userId?: true
    siteId?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    amount: number
    payment_date: Date
    payment_method: $Enums.PaymentMethod
    description: string | null
    created_at: Date
    userId: number
    siteId: number
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    description?: boolean
    created_at?: boolean
    userId?: boolean
    siteId?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "payment_date" | "payment_method" | "description" | "created_at" | "userId" | "siteId", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      payment_date: Date
      payment_method: $Enums.PaymentMethod
      description: string | null
      created_at: Date
      userId: number
      siteId: number
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Float'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'PaymentMethod'>
    readonly description: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly userId: FieldRef<"payments", 'Int'>
    readonly siteId: FieldRef<"payments", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password: 'password',
    account_type: 'account_type',
    company_name: 'company_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    tokenExpiry: 'tokenExpiry',
    verificationToken: 'verificationToken',
    is_verified: 'is_verified',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    site_id: 'site_id',
    site_name: 'site_name',
    site_address: 'site_address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    adminId: 'adminId',
    apartment_count: 'apartment_count',
    block_count: 'block_count',
    company_id: 'company_id',
    deleted_at: 'deleted_at',
    site_status: 'site_status'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone_number: 'phone_number',
    password: 'password',
    apartment_no: 'apartment_no',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    code_expiry: 'code_expiry',
    phone_verification_code: 'phone_verification_code',
    reset_code: 'reset_code',
    reset_code_expiry: 'reset_code_expiry',
    account_status: 'account_status',
    deleted_at: 'deleted_at',
    last_login: 'last_login',
    plates: 'plates',
    resident_count: 'resident_count',
    resident_type: 'resident_type',
    block_id: 'block_id',
    is_password_set: 'is_password_set'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Social_amenitiesScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    description: 'description',
    status: 'status',
    hours: 'hours',
    rules: 'rules',
    extra: 'extra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Social_amenitiesScalarFieldEnum = (typeof Social_amenitiesScalarFieldEnum)[keyof typeof Social_amenitiesScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    siteId: 'siteId',
    start_date: 'start_date',
    end_date: 'end_date'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    status: 'status',
    siteId: 'siteId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    category: 'category'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const BlocksScalarFieldEnum: {
    id: 'id',
    block_name: 'block_name',
    site_id: 'site_id',
    created_at: 'created_at'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    company_code: 'company_code',
    account_status: 'account_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    manager_id: 'manager_id'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Company_employeesScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    company_id: 'company_id',
    joined_at: 'joined_at',
    status: 'status'
  };

  export type Company_employeesScalarFieldEnum = (typeof Company_employeesScalarFieldEnum)[keyof typeof Company_employeesScalarFieldEnum]


  export const Employee_site_accessScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    site_id: 'site_id',
    granted_at: 'granted_at'
  };

  export type Employee_site_accessScalarFieldEnum = (typeof Employee_site_accessScalarFieldEnum)[keyof typeof Employee_site_accessScalarFieldEnum]


  export const InvitationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    invite_code: 'invite_code',
    invite_link: 'invite_link',
    invited_email: 'invited_email',
    invited_by: 'invited_by',
    status: 'status',
    expires_at: 'expires_at',
    used_at: 'used_at',
    used_by: 'used_by',
    created_at: 'created_at'
  };

  export type InvitationsScalarFieldEnum = (typeof InvitationsScalarFieldEnum)[keyof typeof InvitationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    description: 'description',
    created_at: 'created_at',
    userId: 'userId',
    siteId: 'siteId'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'ResidentType'
   */
  export type EnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType'>
    


  /**
   * Reference to a field of type 'ResidentType[]'
   */
  export type ListEnumResidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentType[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    full_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    account_type?: EnumAccountTypeFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableFilter<"Admin"> | string | null
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    verificationToken?: StringNullableFilter<"Admin"> | string | null
    is_verified?: BoolFilter<"Admin"> | boolean
    resetToken?: StringNullableFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    companies?: CompaniesListRelationFilter
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    sites_created?: SiteListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    companies?: companiesOrderByRelationAggregateInput
    company_employees?: company_employeesOrderByWithRelationInput
    sites_created?: SiteOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    verificationToken?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    full_name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    account_type?: EnumAccountTypeFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableFilter<"Admin"> | string | null
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    is_verified?: BoolFilter<"Admin"> | boolean
    resetToken?: StringNullableFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    companies?: CompaniesListRelationFilter
    company_employees?: XOR<Company_employeesNullableScalarRelationFilter, company_employeesWhereInput> | null
    sites_created?: SiteListRelationFilter
  }, "id" | "email" | "verificationToken">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    full_name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    account_type?: EnumAccountTypeWithAggregatesFilter<"Admin"> | $Enums.AccountType
    company_name?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    is_verified?: BoolWithAggregatesFilter<"Admin"> | boolean
    resetToken?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"Admin"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
  }

  export type SiteWhereInput = {
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    id?: IntFilter<"Site"> | number
    site_id?: StringFilter<"Site"> | string
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
    announcements?: AnnouncementListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    social_amenities?: Social_amenitiesListRelationFilter
    users?: UserListRelationFilter
  }

  export type SiteOrderByWithRelationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    announcements?: AnnouncementOrderByRelationAggregateInput
    blocks?: blocksOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    social_amenities?: social_amenitiesOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type SiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id?: string
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
    announcements?: AnnouncementListRelationFilter
    blocks?: BlocksListRelationFilter
    complaints?: ComplaintListRelationFilter
    employee_site_access?: Employee_site_accessListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    social_amenities?: Social_amenitiesListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "site_id">

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrderInput | SortOrder
    apartment_count?: SortOrderInput | SortOrder
    block_count?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    site_status?: SortOrder
    _count?: SiteCountOrderByAggregateInput
    _avg?: SiteAvgOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
    _sum?: SiteSumOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    OR?: SiteScalarWhereWithAggregatesInput[]
    NOT?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Site"> | number
    site_id?: StringWithAggregatesFilter<"Site"> | string
    site_name?: StringWithAggregatesFilter<"Site"> | string
    site_address?: StringWithAggregatesFilter<"Site"> | string
    created_at?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    adminId?: IntNullableWithAggregatesFilter<"Site"> | number | null
    apartment_count?: IntNullableWithAggregatesFilter<"Site"> | number | null
    block_count?: IntNullableWithAggregatesFilter<"Site"> | number | null
    company_id?: IntNullableWithAggregatesFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusWithAggregatesFilter<"Site"> | $Enums.AccountStatus
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
    complaints?: ComplaintListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    complaints?: ComplaintOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    blocks?: blocksOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
    complaints?: ComplaintListRelationFilter
    payments?: PaymentsListRelationFilter
    blocks?: XOR<BlocksNullableScalarRelationFilter, blocksWhereInput> | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id" | "phone_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrderInput | SortOrder
    apartment_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrderInput | SortOrder
    phone_verification_code?: SortOrderInput | SortOrder
    reset_code?: SortOrderInput | SortOrder
    reset_code_expiry?: SortOrderInput | SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    plates?: SortOrderInput | SortOrder
    resident_count?: SortOrderInput | SortOrder
    resident_type?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    is_password_set?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    full_name?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    apartment_no?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    siteId?: IntWithAggregatesFilter<"User"> | number
    code_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_code?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    account_status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    plates?: StringNullableWithAggregatesFilter<"User"> | string | null
    resident_count?: IntNullableWithAggregatesFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableWithAggregatesFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableWithAggregatesFilter<"User"> | number | null
    is_password_set?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type social_amenitiesWhereInput = {
    AND?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    OR?: social_amenitiesWhereInput[]
    NOT?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    id?: StringFilter<"social_amenities"> | string
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type social_amenitiesOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sites?: SiteOrderByWithRelationInput
  }

  export type social_amenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    OR?: social_amenitiesWhereInput[]
    NOT?: social_amenitiesWhereInput | social_amenitiesWhereInput[]
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type social_amenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    hours?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: social_amenitiesCountOrderByAggregateInput
    _avg?: social_amenitiesAvgOrderByAggregateInput
    _max?: social_amenitiesMaxOrderByAggregateInput
    _min?: social_amenitiesMinOrderByAggregateInput
    _sum?: social_amenitiesSumOrderByAggregateInput
  }

  export type social_amenitiesScalarWhereWithAggregatesInput = {
    AND?: social_amenitiesScalarWhereWithAggregatesInput | social_amenitiesScalarWhereWithAggregatesInput[]
    OR?: social_amenitiesScalarWhereWithAggregatesInput[]
    NOT?: social_amenitiesScalarWhereWithAggregatesInput | social_amenitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"social_amenities"> | string
    siteId?: IntWithAggregatesFilter<"social_amenities"> | number
    name?: StringWithAggregatesFilter<"social_amenities"> | string
    description?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    status?: StringWithAggregatesFilter<"social_amenities"> | string
    hours?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    rules?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    extra?: StringNullableWithAggregatesFilter<"social_amenities"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"social_amenities"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    updated_at?: DateTimeFilter<"Announcement"> | Date | string
    siteId?: IntFilter<"Announcement"> | number
    start_date?: DateTimeFilter<"Announcement"> | Date | string
    end_date?: DateTimeFilter<"Announcement"> | Date | string
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    site?: SiteOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    updated_at?: DateTimeFilter<"Announcement"> | Date | string
    siteId?: IntFilter<"Announcement"> | number
    start_date?: DateTimeFilter<"Announcement"> | Date | string
    end_date?: DateTimeFilter<"Announcement"> | Date | string
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _avg?: AnnouncementAvgOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
    _sum?: AnnouncementSumOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Announcement"> | number
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    created_at?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    siteId?: IntWithAggregatesFilter<"Announcement"> | number
    start_date?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    content?: StringFilter<"Complaint"> | string
    status?: EnumStatusFilter<"Complaint"> | $Enums.Status
    siteId?: IntFilter<"Complaint"> | number
    userId?: IntFilter<"Complaint"> | number
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    category?: EnumCategoryNullableFilter<"Complaint"> | $Enums.Category | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    site?: SiteOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    title?: StringFilter<"Complaint"> | string
    content?: StringFilter<"Complaint"> | string
    status?: EnumStatusFilter<"Complaint"> | $Enums.Status
    siteId?: IntFilter<"Complaint"> | number
    userId?: IntFilter<"Complaint"> | number
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    category?: EnumCategoryNullableFilter<"Complaint"> | $Enums.Category | null
    site?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    title?: StringWithAggregatesFilter<"Complaint"> | string
    content?: StringWithAggregatesFilter<"Complaint"> | string
    status?: EnumStatusWithAggregatesFilter<"Complaint"> | $Enums.Status
    siteId?: IntWithAggregatesFilter<"Complaint"> | number
    userId?: IntWithAggregatesFilter<"Complaint"> | number
    created_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    category?: EnumCategoryNullableWithAggregatesFilter<"Complaint"> | $Enums.Category | null
  }

  export type blocksWhereInput = {
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: UserListRelationFilter
  }

  export type blocksOrderByWithRelationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    sites?: SiteOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type blocksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    site_id_block_name?: blocksSite_idBlock_nameCompoundUniqueInput
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
    users?: UserListRelationFilter
  }, "id" | "site_id_block_name">

  export type blocksOrderByWithAggregationInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    OR?: blocksScalarWhereWithAggregatesInput[]
    NOT?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"blocks"> | number
    block_name?: StringWithAggregatesFilter<"blocks"> | string
    site_id?: IntWithAggregatesFilter<"blocks"> | number
    created_at?: DateTimeWithAggregatesFilter<"blocks"> | Date | string
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: IntFilter<"companies"> | number
    company_name?: StringFilter<"companies"> | string
    company_code?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SiteListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    manager_id?: SortOrder
    admins?: AdminOrderByWithRelationInput
    company_employees?: company_employeesOrderByRelationAggregateInput
    invitations?: invitationsOrderByRelationAggregateInput
    sites?: SiteOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    company_code?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    company_name?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    company_employees?: Company_employeesListRelationFilter
    invitations?: InvitationsListRelationFilter
    sites?: SiteListRelationFilter
  }, "id" | "company_code">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    manager_id?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companies"> | number
    company_name?: StringWithAggregatesFilter<"companies"> | string
    company_code?: StringWithAggregatesFilter<"companies"> | string
    account_status?: EnumAccountStatusWithAggregatesFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    manager_id?: IntWithAggregatesFilter<"companies"> | number
  }

  export type company_employeesWhereInput = {
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }

  export type company_employeesOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    admins?: AdminOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    employee_site_access?: employee_site_accessOrderByRelationAggregateInput
  }

  export type company_employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    admin_id?: number
    AND?: company_employeesWhereInput | company_employeesWhereInput[]
    OR?: company_employeesWhereInput[]
    NOT?: company_employeesWhereInput | company_employeesWhereInput[]
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
    admins?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    employee_site_access?: Employee_site_accessListRelationFilter
  }, "id" | "admin_id">

  export type company_employeesOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
    _count?: company_employeesCountOrderByAggregateInput
    _avg?: company_employeesAvgOrderByAggregateInput
    _max?: company_employeesMaxOrderByAggregateInput
    _min?: company_employeesMinOrderByAggregateInput
    _sum?: company_employeesSumOrderByAggregateInput
  }

  export type company_employeesScalarWhereWithAggregatesInput = {
    AND?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    OR?: company_employeesScalarWhereWithAggregatesInput[]
    NOT?: company_employeesScalarWhereWithAggregatesInput | company_employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"company_employees"> | number
    admin_id?: IntWithAggregatesFilter<"company_employees"> | number
    company_id?: IntWithAggregatesFilter<"company_employees"> | number
    joined_at?: DateTimeWithAggregatesFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusWithAggregatesFilter<"company_employees"> | $Enums.AccountStatus
  }

  export type employee_site_accessWhereInput = {
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }

  export type employee_site_accessOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    company_employees?: company_employeesOrderByWithRelationInput
    sites?: SiteOrderByWithRelationInput
  }

  export type employee_site_accessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employee_id_site_id?: employee_site_accessEmployee_idSite_idCompoundUniqueInput
    AND?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    OR?: employee_site_accessWhereInput[]
    NOT?: employee_site_accessWhereInput | employee_site_accessWhereInput[]
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
    company_employees?: XOR<Company_employeesScalarRelationFilter, company_employeesWhereInput>
    sites?: XOR<SiteScalarRelationFilter, SiteWhereInput>
  }, "id" | "employee_id_site_id">

  export type employee_site_accessOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
    _count?: employee_site_accessCountOrderByAggregateInput
    _avg?: employee_site_accessAvgOrderByAggregateInput
    _max?: employee_site_accessMaxOrderByAggregateInput
    _min?: employee_site_accessMinOrderByAggregateInput
    _sum?: employee_site_accessSumOrderByAggregateInput
  }

  export type employee_site_accessScalarWhereWithAggregatesInput = {
    AND?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    OR?: employee_site_accessScalarWhereWithAggregatesInput[]
    NOT?: employee_site_accessScalarWhereWithAggregatesInput | employee_site_accessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employee_site_access"> | number
    employee_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    site_id?: IntWithAggregatesFilter<"employee_site_access"> | number
    granted_at?: DateTimeWithAggregatesFilter<"employee_site_access"> | Date | string
  }

  export type invitationsWhereInput = {
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type invitationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type invitationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invite_code?: string
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    company_id?: IntFilter<"invitations"> | number
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id" | "invite_code">

  export type invitationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrderInput | SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    used_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: invitationsCountOrderByAggregateInput
    _avg?: invitationsAvgOrderByAggregateInput
    _max?: invitationsMaxOrderByAggregateInput
    _min?: invitationsMinOrderByAggregateInput
    _sum?: invitationsSumOrderByAggregateInput
  }

  export type invitationsScalarWhereWithAggregatesInput = {
    AND?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    OR?: invitationsScalarWhereWithAggregatesInput[]
    NOT?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"invitations"> | number
    company_id?: IntWithAggregatesFilter<"invitations"> | number
    invite_code?: StringWithAggregatesFilter<"invitations"> | string
    invite_link?: StringWithAggregatesFilter<"invitations"> | string
    invited_email?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    invited_by?: IntWithAggregatesFilter<"invitations"> | number
    status?: EnumInvitationStatusWithAggregatesFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"invitations"> | Date | string | null
    used_by?: IntNullableWithAggregatesFilter<"invitations"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    amount?: FloatWithAggregatesFilter<"payments"> | number
    payment_date?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    userId?: IntWithAggregatesFilter<"payments"> | number
    siteId?: IntWithAggregatesFilter<"payments"> | number
  }

  export type AdminCreateInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
  }

  export type AdminUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteCreateInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteUpdateInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateManyInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type SiteUpdateManyMutationInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type UserCreateInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: ComplaintCreateNestedManyWithoutUserInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
  }

  export type UserUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type social_amenitiesCreateInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    sites: SiteCreateNestedOneWithoutSocial_amenitiesInput
  }

  export type social_amenitiesUncheckedCreateInput = {
    id: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateOneRequiredWithoutSocial_amenitiesNestedInput
  }

  export type social_amenitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesCreateManyInput = {
    id: string
    siteId: number
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    start_date: Date | string
    end_date: Date | string
    site: SiteCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type AnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    start_date: Date | string
    end_date: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    site: SiteCreateNestedOneWithoutComplaintsInput
    user: UserCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type ComplaintUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    site?: SiteUpdateOneRequiredWithoutComplaintsNestedInput
    user?: UserUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type ComplaintCreateManyInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type ComplaintUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type blocksCreateInput = {
    block_name: string
    created_at?: Date | string
    sites: SiteCreateNestedOneWithoutBlocksInput
    users?: UserCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksUpdateInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateOneRequiredWithoutBlocksNestedInput
    users?: UserUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksCreateManyInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
  }

  export type blocksUpdateManyMutationInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesCreateInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
  }

  export type companiesUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
  }

  export type company_employeesCreateInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUpdateInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesCreateManyInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type company_employeesUpdateManyMutationInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type company_employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type employee_site_accessCreateInput = {
    granted_at?: Date | string
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
    sites: SiteCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
    sites?: SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessCreateManyInput = {
    id?: number
    employee_id: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateManyMutationInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
    companies: companiesCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateManyInput = {
    id?: number
    company_id: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUpdateManyMutationInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
    users: UserCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsCreateManyInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    userId: number
    siteId: number
  }

  export type paymentsUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type Company_employeesNullableScalarRelationFilter = {
    is?: company_employeesWhereInput | null
    isNot?: company_employeesWhereInput | null
  }

  export type SiteListRelationFilter = {
    every?: SiteWhereInput
    some?: SiteWhereInput
    none?: SiteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    account_type?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tokenExpiry?: SortOrder
    verificationToken?: SortOrder
    is_verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type BlocksListRelationFilter = {
    every?: blocksWhereInput
    some?: blocksWhereInput
    none?: blocksWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type Employee_site_accessListRelationFilter = {
    every?: employee_site_accessWhereInput
    some?: employee_site_accessWhereInput
    none?: employee_site_accessWhereInput
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type Social_amenitiesListRelationFilter = {
    every?: social_amenitiesWhereInput
    some?: social_amenitiesWhereInput
    none?: social_amenitiesWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employee_site_accessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type social_amenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
    site_name?: SortOrder
    site_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
    deleted_at?: SortOrder
    site_status?: SortOrder
  }

  export type SiteSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    apartment_count?: SortOrder
    block_count?: SortOrder
    company_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type BlocksNullableScalarRelationFilter = {
    is?: blocksWhereInput | null
    isNot?: blocksWhereInput | null
  }

  export type SiteScalarRelationFilter = {
    is?: SiteWhereInput
    isNot?: SiteWhereInput
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    apartment_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    code_expiry?: SortOrder
    phone_verification_code?: SortOrder
    reset_code?: SortOrder
    reset_code_expiry?: SortOrder
    account_status?: SortOrder
    deleted_at?: SortOrder
    last_login?: SortOrder
    plates?: SortOrder
    resident_count?: SortOrder
    resident_type?: SortOrder
    block_id?: SortOrder
    is_password_set?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    resident_count?: SortOrder
    block_id?: SortOrder
  }

  export type EnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type social_amenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesAvgOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type social_amenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hours?: SortOrder
    rules?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type social_amenitiesSumOrderByAggregateInput = {
    siteId?: SortOrder
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type AnnouncementAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    siteId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type AnnouncementSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    userId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type blocksSite_idBlock_nameCompoundUniqueInput = {
    site_id: number
    block_name: string
  }

  export type blocksCountOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    id?: SortOrder
    block_name?: SortOrder
    site_id?: SortOrder
    created_at?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    id?: SortOrder
    site_id?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type Company_employeesListRelationFilter = {
    every?: company_employeesWhereInput
    some?: company_employeesWhereInput
    none?: company_employeesWhereInput
  }

  export type InvitationsListRelationFilter = {
    every?: invitationsWhereInput
    some?: invitationsWhereInput
    none?: invitationsWhereInput
  }

  export type company_employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invitationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_code?: SortOrder
    account_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    manager_id?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type company_employeesCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type company_employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
    joined_at?: SortOrder
    status?: SortOrder
  }

  export type company_employeesSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    company_id?: SortOrder
  }

  export type Company_employeesScalarRelationFilter = {
    is?: company_employeesWhereInput
    isNot?: company_employeesWhereInput
  }

  export type employee_site_accessEmployee_idSite_idCompoundUniqueInput = {
    employee_id: number
    site_id: number
  }

  export type employee_site_accessCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type employee_site_accessMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
    granted_at?: SortOrder
  }

  export type employee_site_accessSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    site_id?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type invitationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type invitationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invite_code?: SortOrder
    invite_link?: SortOrder
    invited_email?: SortOrder
    invited_by?: SortOrder
    status?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    used_by?: SortOrder
    created_at?: SortOrder
  }

  export type invitationsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    invited_by?: SortOrder
    used_by?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    siteId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type companiesCreateNestedManyWithoutAdminsInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type company_employeesCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type SiteCreateNestedManyWithoutAdminInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedOneWithoutAdminsInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    connect?: company_employeesWhereUniqueInput
  }

  export type SiteUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type companiesUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutAdminsInput | companiesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutAdminsInput | companiesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutAdminsInput | companiesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type company_employeesUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type SiteUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutAdminInput | SiteUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutAdminInput | SiteUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutAdminInput | SiteUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companiesUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput> | companiesCreateWithoutAdminsInput[] | companiesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutAdminsInput | companiesCreateOrConnectWithoutAdminsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutAdminsInput | companiesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: companiesCreateManyAdminsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutAdminsInput | companiesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutAdminsInput | companiesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutAdminsInput
    upsert?: company_employeesUpsertWithoutAdminsInput
    disconnect?: company_employeesWhereInput | boolean
    delete?: company_employeesWhereInput | boolean
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutAdminsInput, company_employeesUpdateWithoutAdminsInput>, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type SiteUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput> | SiteCreateWithoutAdminInput[] | SiteUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutAdminInput | SiteCreateOrConnectWithoutAdminInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutAdminInput | SiteUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SiteCreateManyAdminInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutAdminInput | SiteUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutAdminInput | SiteUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AnnouncementCreateNestedManyWithoutSiteInput = {
    create?: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput> | AnnouncementCreateWithoutSiteInput[] | AnnouncementUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutSiteInput | AnnouncementCreateOrConnectWithoutSiteInput[]
    createMany?: AnnouncementCreateManySiteInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type blocksCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutSiteInput = {
    create?: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput> | ComplaintCreateWithoutSiteInput[] | ComplaintUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSiteInput | ComplaintCreateOrConnectWithoutSiteInput[]
    createMany?: ComplaintCreateManySiteInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type employee_site_accessCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutSites_createdInput = {
    create?: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSites_createdInput
    connect?: AdminWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutSitesInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    connect?: companiesWhereUniqueInput
  }

  export type social_amenitiesCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutSiteInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput> | AnnouncementCreateWithoutSiteInput[] | AnnouncementUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutSiteInput | AnnouncementCreateOrConnectWithoutSiteInput[]
    createMany?: AnnouncementCreateManySiteInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type blocksUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput> | ComplaintCreateWithoutSiteInput[] | ComplaintUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSiteInput | ComplaintCreateOrConnectWithoutSiteInput[]
    createMany?: ComplaintCreateManySiteInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type social_amenitiesUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnnouncementUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput> | AnnouncementCreateWithoutSiteInput[] | AnnouncementUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutSiteInput | AnnouncementCreateOrConnectWithoutSiteInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutSiteInput | AnnouncementUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AnnouncementCreateManySiteInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutSiteInput | AnnouncementUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutSiteInput | AnnouncementUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type blocksUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput> | ComplaintCreateWithoutSiteInput[] | ComplaintUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSiteInput | ComplaintCreateOrConnectWithoutSiteInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSiteInput | ComplaintUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ComplaintCreateManySiteInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSiteInput | ComplaintUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSiteInput | ComplaintUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type employee_site_accessUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type AdminUpdateOneWithoutSites_createdNestedInput = {
    create?: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSites_createdInput
    upsert?: AdminUpsertWithoutSites_createdInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSites_createdInput, AdminUpdateWithoutSites_createdInput>, AdminUncheckedUpdateWithoutSites_createdInput>
  }

  export type companiesUpdateOneWithoutSitesNestedInput = {
    create?: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutSitesInput
    upsert?: companiesUpsertWithoutSitesInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutSitesInput, companiesUpdateWithoutSitesInput>, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type social_amenitiesUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    upsert?: social_amenitiesUpsertWithWhereUniqueWithoutSitesInput | social_amenitiesUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    set?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    disconnect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    delete?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    update?: social_amenitiesUpdateWithWhereUniqueWithoutSitesInput | social_amenitiesUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_amenitiesUpdateManyWithWhereWithoutSitesInput | social_amenitiesUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
  }

  export type UserUpdateManyWithoutSiteNestedInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSiteInput | UserUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSiteInput | UserUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSiteInput | UserUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput> | AnnouncementCreateWithoutSiteInput[] | AnnouncementUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutSiteInput | AnnouncementCreateOrConnectWithoutSiteInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutSiteInput | AnnouncementUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: AnnouncementCreateManySiteInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutSiteInput | AnnouncementUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutSiteInput | AnnouncementUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type blocksUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput> | blocksCreateWithoutSitesInput[] | blocksUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: blocksCreateOrConnectWithoutSitesInput | blocksCreateOrConnectWithoutSitesInput[]
    upsert?: blocksUpsertWithWhereUniqueWithoutSitesInput | blocksUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: blocksCreateManySitesInputEnvelope
    set?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    disconnect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    delete?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    connect?: blocksWhereUniqueInput | blocksWhereUniqueInput[]
    update?: blocksUpdateWithWhereUniqueWithoutSitesInput | blocksUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: blocksUpdateManyWithWhereWithoutSitesInput | blocksUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: blocksScalarWhereInput | blocksScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput> | ComplaintCreateWithoutSiteInput[] | ComplaintUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSiteInput | ComplaintCreateOrConnectWithoutSiteInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSiteInput | ComplaintUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ComplaintCreateManySiteInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSiteInput | ComplaintUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSiteInput | ComplaintUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput> | employee_site_accessCreateWithoutSitesInput[] | employee_site_accessUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutSitesInput | employee_site_accessCreateOrConnectWithoutSitesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutSitesInput | employee_site_accessUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: employee_site_accessCreateManySitesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutSitesInput | employee_site_accessUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutSitesInput | employee_site_accessUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput> | social_amenitiesCreateWithoutSitesInput[] | social_amenitiesUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_amenitiesCreateOrConnectWithoutSitesInput | social_amenitiesCreateOrConnectWithoutSitesInput[]
    upsert?: social_amenitiesUpsertWithWhereUniqueWithoutSitesInput | social_amenitiesUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_amenitiesCreateManySitesInputEnvelope
    set?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    disconnect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    delete?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    connect?: social_amenitiesWhereUniqueInput | social_amenitiesWhereUniqueInput[]
    update?: social_amenitiesUpdateWithWhereUniqueWithoutSitesInput | social_amenitiesUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_amenitiesUpdateManyWithWhereWithoutSitesInput | social_amenitiesUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput> | UserCreateWithoutSiteInput[] | UserUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSiteInput | UserCreateOrConnectWithoutSiteInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSiteInput | UserUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: UserCreateManySiteInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSiteInput | UserUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSiteInput | UserUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ComplaintCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type blocksCreateNestedOneWithoutUsersInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    connect?: blocksWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutUsersInput = {
    create?: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SiteCreateOrConnectWithoutUsersInput
    connect?: SiteWhereUniqueInput
  }

  export type ComplaintUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type NullableEnumResidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResidentType | null
  }

  export type ComplaintUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutUserInput | ComplaintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutUserInput | ComplaintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutUserInput | ComplaintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type blocksUpdateOneWithoutUsersNestedInput = {
    create?: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    connectOrCreate?: blocksCreateOrConnectWithoutUsersInput
    upsert?: blocksUpsertWithoutUsersInput
    disconnect?: blocksWhereInput | boolean
    delete?: blocksWhereInput | boolean
    connect?: blocksWhereUniqueInput
    update?: XOR<XOR<blocksUpdateToOneWithWhereWithoutUsersInput, blocksUpdateWithoutUsersInput>, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type SiteUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SiteCreateOrConnectWithoutUsersInput
    upsert?: SiteUpsertWithoutUsersInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutUsersInput, SiteUpdateWithoutUsersInput>, SiteUncheckedUpdateWithoutUsersInput>
  }

  export type ComplaintUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutUserInput | ComplaintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutUserInput | ComplaintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutUserInput | ComplaintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutSocial_amenitiesInput = {
    create?: XOR<SiteCreateWithoutSocial_amenitiesInput, SiteUncheckedCreateWithoutSocial_amenitiesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSocial_amenitiesInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutSocial_amenitiesNestedInput = {
    create?: XOR<SiteCreateWithoutSocial_amenitiesInput, SiteUncheckedCreateWithoutSocial_amenitiesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSocial_amenitiesInput
    upsert?: SiteUpsertWithoutSocial_amenitiesInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutSocial_amenitiesInput, SiteUpdateWithoutSocial_amenitiesInput>, SiteUncheckedUpdateWithoutSocial_amenitiesInput>
  }

  export type SiteCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAnnouncementsInput
    connect?: SiteWhereUniqueInput
  }

  export type SiteUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutAnnouncementsInput
    upsert?: SiteUpsertWithoutAnnouncementsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutAnnouncementsInput, SiteUpdateWithoutAnnouncementsInput>, SiteUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SiteCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutComplaintsInput
    connect?: SiteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type SiteUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutComplaintsInput
    upsert?: SiteUpsertWithoutComplaintsInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutComplaintsInput, SiteUpdateWithoutComplaintsInput>, SiteUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    upsert?: UserUpsertWithoutComplaintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplaintsInput, UserUpdateWithoutComplaintsInput>, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type SiteCreateNestedOneWithoutBlocksInput = {
    create?: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutBlocksInput
    connect?: SiteWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutBlocksInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBlocksInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SiteUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: SiteCreateOrConnectWithoutBlocksInput
    upsert?: SiteUpsertWithoutBlocksInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutBlocksInput, SiteUpdateWithoutBlocksInput>, SiteUncheckedUpdateWithoutBlocksInput>
  }

  export type UserUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBlocksInput | UserUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBlocksInput | UserUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBlocksInput | UserUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBlocksNestedInput = {
    create?: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput> | UserCreateWithoutBlocksInput[] | UserUncheckedCreateWithoutBlocksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBlocksInput | UserCreateOrConnectWithoutBlocksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBlocksInput | UserUpsertWithWhereUniqueWithoutBlocksInput[]
    createMany?: UserCreateManyBlocksInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBlocksInput | UserUpdateWithWhereUniqueWithoutBlocksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBlocksInput | UserUpdateManyWithWhereWithoutBlocksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<AdminCreateWithoutCompaniesInput, AdminUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompaniesInput
    connect?: AdminWhereUniqueInput
  }

  export type company_employeesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type SiteCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type company_employeesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
  }

  export type invitationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type SiteUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<AdminCreateWithoutCompaniesInput, AdminUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompaniesInput
    upsert?: AdminUpsertWithoutCompaniesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCompaniesInput, AdminUpdateWithoutCompaniesInput>, AdminUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_employeesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type SiteUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCompaniesInput | SiteUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCompaniesInput | SiteUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCompaniesInput | SiteUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput> | company_employeesCreateWithoutCompaniesInput[] | company_employeesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_employeesCreateOrConnectWithoutCompaniesInput | company_employeesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_employeesUpsertWithWhereUniqueWithoutCompaniesInput | company_employeesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_employeesCreateManyCompaniesInputEnvelope
    set?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    disconnect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    delete?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    connect?: company_employeesWhereUniqueInput | company_employeesWhereUniqueInput[]
    update?: company_employeesUpdateWithWhereUniqueWithoutCompaniesInput | company_employeesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_employeesUpdateManyWithWhereWithoutCompaniesInput | company_employeesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput> | invitationsCreateWithoutCompaniesInput[] | invitationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutCompaniesInput | invitationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutCompaniesInput | invitationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: invitationsCreateManyCompaniesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutCompaniesInput | invitationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutCompaniesInput | invitationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type SiteUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput> | SiteCreateWithoutCompaniesInput[] | SiteUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutCompaniesInput | SiteCreateOrConnectWithoutCompaniesInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutCompaniesInput | SiteUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: SiteCreateManyCompaniesInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutCompaniesInput | SiteUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutCompaniesInput | SiteUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompany_employeesInput
    connect?: AdminWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutCompany_employeesInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
  }

  export type employee_site_accessCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCompany_employeesInput
    upsert?: AdminUpsertWithoutCompany_employeesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCompany_employeesInput, AdminUpdateWithoutCompany_employeesInput>, AdminUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateOneRequiredWithoutCompany_employeesNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_employeesInput
    upsert?: companiesUpsertWithoutCompany_employeesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_employeesInput, companiesUpdateWithoutCompany_employeesInput>, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput = {
    create?: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput> | employee_site_accessCreateWithoutCompany_employeesInput[] | employee_site_accessUncheckedCreateWithoutCompany_employeesInput[]
    connectOrCreate?: employee_site_accessCreateOrConnectWithoutCompany_employeesInput | employee_site_accessCreateOrConnectWithoutCompany_employeesInput[]
    upsert?: employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput[]
    createMany?: employee_site_accessCreateManyCompany_employeesInputEnvelope
    set?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    disconnect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    delete?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    connect?: employee_site_accessWhereUniqueInput | employee_site_accessWhereUniqueInput[]
    update?: employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput | employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput[]
    updateMany?: employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput | employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput[]
    deleteMany?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
  }

  export type company_employeesCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutEmployee_site_accessInput = {
    create?: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: SiteCreateOrConnectWithoutEmployee_site_accessInput
    connect?: SiteWhereUniqueInput
  }

  export type company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: company_employeesCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: company_employeesUpsertWithoutEmployee_site_accessInput
    connect?: company_employeesWhereUniqueInput
    update?: XOR<XOR<company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput, company_employeesUpdateWithoutEmployee_site_accessInput>, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput = {
    create?: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    connectOrCreate?: SiteCreateOrConnectWithoutEmployee_site_accessInput
    upsert?: SiteUpsertWithoutEmployee_site_accessInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutEmployee_site_accessInput, SiteUpdateWithoutEmployee_site_accessInput>, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type companiesCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type companiesUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutInvitationsInput
    upsert?: companiesUpsertWithoutInvitationsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutInvitationsInput, companiesUpdateWithoutInvitationsInput>, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumResidentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableFilter<$PrismaModel> | $Enums.ResidentType | null
  }

  export type NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentType | EnumResidentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentType[] | ListEnumResidentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type companiesCreateWithoutAdminsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
  }

  export type companiesCreateManyAdminsInputEnvelope = {
    data: companiesCreateManyAdminsInput | companiesCreateManyAdminsInput[]
    skipDuplicates?: boolean
  }

  export type company_employeesCreateWithoutAdminsInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutAdminsInput = {
    id?: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutAdminsInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
  }

  export type SiteCreateWithoutAdminInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutAdminInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAdminInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput>
  }

  export type SiteCreateManyAdminInputEnvelope = {
    data: SiteCreateManyAdminInput | SiteCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithWhereUniqueWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
    create: XOR<companiesCreateWithoutAdminsInput, companiesUncheckedCreateWithoutAdminsInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutAdminsInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutAdminsInput, companiesUncheckedUpdateWithoutAdminsInput>
  }

  export type companiesUpdateManyWithWhereWithoutAdminsInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutAdminsInput>
  }

  export type companiesScalarWhereInput = {
    AND?: companiesScalarWhereInput | companiesScalarWhereInput[]
    OR?: companiesScalarWhereInput[]
    NOT?: companiesScalarWhereInput | companiesScalarWhereInput[]
    id?: IntFilter<"companies"> | number
    company_name?: StringFilter<"companies"> | string
    company_code?: StringFilter<"companies"> | string
    account_status?: EnumAccountStatusFilter<"companies"> | $Enums.AccountStatus
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    manager_id?: IntFilter<"companies"> | number
  }

  export type company_employeesUpsertWithoutAdminsInput = {
    update: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
    create: XOR<company_employeesCreateWithoutAdminsInput, company_employeesUncheckedCreateWithoutAdminsInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutAdminsInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutAdminsInput, company_employeesUncheckedUpdateWithoutAdminsInput>
  }

  export type company_employeesUpdateWithoutAdminsInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type SiteUpsertWithWhereUniqueWithoutAdminInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutAdminInput, SiteUncheckedUpdateWithoutAdminInput>
    create: XOR<SiteCreateWithoutAdminInput, SiteUncheckedCreateWithoutAdminInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutAdminInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutAdminInput, SiteUncheckedUpdateWithoutAdminInput>
  }

  export type SiteUpdateManyWithWhereWithoutAdminInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutAdminInput>
  }

  export type SiteScalarWhereInput = {
    AND?: SiteScalarWhereInput | SiteScalarWhereInput[]
    OR?: SiteScalarWhereInput[]
    NOT?: SiteScalarWhereInput | SiteScalarWhereInput[]
    id?: IntFilter<"Site"> | number
    site_id?: StringFilter<"Site"> | string
    site_name?: StringFilter<"Site"> | string
    site_address?: StringFilter<"Site"> | string
    created_at?: DateTimeFilter<"Site"> | Date | string
    updated_at?: DateTimeFilter<"Site"> | Date | string
    adminId?: IntNullableFilter<"Site"> | number | null
    apartment_count?: IntNullableFilter<"Site"> | number | null
    block_count?: IntNullableFilter<"Site"> | number | null
    company_id?: IntNullableFilter<"Site"> | number | null
    deleted_at?: DateTimeNullableFilter<"Site"> | Date | string | null
    site_status?: EnumAccountStatusFilter<"Site"> | $Enums.AccountStatus
  }

  export type AnnouncementCreateWithoutSiteInput = {
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutSiteInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutSiteInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput>
  }

  export type AnnouncementCreateManySiteInputEnvelope = {
    data: AnnouncementCreateManySiteInput | AnnouncementCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutSitesInput = {
    block_name: string
    created_at?: Date | string
    users?: UserCreateNestedManyWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutSitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBlocksInput
  }

  export type blocksCreateOrConnectWithoutSitesInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksCreateManySitesInputEnvelope = {
    data: blocksCreateManySitesInput | blocksCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutSiteInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    user: UserCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutSiteInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type ComplaintCreateOrConnectWithoutSiteInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput>
  }

  export type ComplaintCreateManySiteInputEnvelope = {
    data: ComplaintCreateManySiteInput | ComplaintCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type employee_site_accessCreateWithoutSitesInput = {
    granted_at?: Date | string
    company_employees: company_employeesCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutSitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessCreateOrConnectWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessCreateManySitesInputEnvelope = {
    data: employee_site_accessCreateManySitesInput | employee_site_accessCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutSites_createdInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
  }

  export type AdminUncheckedCreateWithoutSites_createdInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
  }

  export type AdminCreateOrConnectWithoutSites_createdInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
  }

  export type companiesCreateWithoutSitesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutSitesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutSitesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesCreateWithoutSitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesUncheckedCreateWithoutSitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type social_amenitiesCreateOrConnectWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    create: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesCreateManySitesInputEnvelope = {
    data: social_amenitiesCreateManySitesInput | social_amenitiesCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSiteInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: ComplaintCreateNestedManyWithoutUserInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSiteInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutSiteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput>
  }

  export type UserCreateManySiteInputEnvelope = {
    data: UserCreateManySiteInput | UserCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutSiteInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutSiteInput, AnnouncementUncheckedUpdateWithoutSiteInput>
    create: XOR<AnnouncementCreateWithoutSiteInput, AnnouncementUncheckedCreateWithoutSiteInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutSiteInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutSiteInput, AnnouncementUncheckedUpdateWithoutSiteInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutSiteInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutSiteInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    updated_at?: DateTimeFilter<"Announcement"> | Date | string
    siteId?: IntFilter<"Announcement"> | number
    start_date?: DateTimeFilter<"Announcement"> | Date | string
    end_date?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type blocksUpsertWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    update: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
    create: XOR<blocksCreateWithoutSitesInput, blocksUncheckedCreateWithoutSitesInput>
  }

  export type blocksUpdateWithWhereUniqueWithoutSitesInput = {
    where: blocksWhereUniqueInput
    data: XOR<blocksUpdateWithoutSitesInput, blocksUncheckedUpdateWithoutSitesInput>
  }

  export type blocksUpdateManyWithWhereWithoutSitesInput = {
    where: blocksScalarWhereInput
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyWithoutSitesInput>
  }

  export type blocksScalarWhereInput = {
    AND?: blocksScalarWhereInput | blocksScalarWhereInput[]
    OR?: blocksScalarWhereInput[]
    NOT?: blocksScalarWhereInput | blocksScalarWhereInput[]
    id?: IntFilter<"blocks"> | number
    block_name?: StringFilter<"blocks"> | string
    site_id?: IntFilter<"blocks"> | number
    created_at?: DateTimeFilter<"blocks"> | Date | string
  }

  export type ComplaintUpsertWithWhereUniqueWithoutSiteInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutSiteInput, ComplaintUncheckedUpdateWithoutSiteInput>
    create: XOR<ComplaintCreateWithoutSiteInput, ComplaintUncheckedCreateWithoutSiteInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutSiteInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutSiteInput, ComplaintUncheckedUpdateWithoutSiteInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutSiteInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutSiteInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    content?: StringFilter<"Complaint"> | string
    status?: EnumStatusFilter<"Complaint"> | $Enums.Status
    siteId?: IntFilter<"Complaint"> | number
    userId?: IntFilter<"Complaint"> | number
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    category?: EnumCategoryNullableFilter<"Complaint"> | $Enums.Category | null
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
    create: XOR<employee_site_accessCreateWithoutSitesInput, employee_site_accessUncheckedCreateWithoutSitesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutSitesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutSitesInput, employee_site_accessUncheckedUpdateWithoutSitesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutSitesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutSitesInput>
  }

  export type employee_site_accessScalarWhereInput = {
    AND?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    OR?: employee_site_accessScalarWhereInput[]
    NOT?: employee_site_accessScalarWhereInput | employee_site_accessScalarWhereInput[]
    id?: IntFilter<"employee_site_access"> | number
    employee_id?: IntFilter<"employee_site_access"> | number
    site_id?: IntFilter<"employee_site_access"> | number
    granted_at?: DateTimeFilter<"employee_site_access"> | Date | string
  }

  export type AdminUpsertWithoutSites_createdInput = {
    update: XOR<AdminUpdateWithoutSites_createdInput, AdminUncheckedUpdateWithoutSites_createdInput>
    create: XOR<AdminCreateWithoutSites_createdInput, AdminUncheckedCreateWithoutSites_createdInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSites_createdInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSites_createdInput, AdminUncheckedUpdateWithoutSites_createdInput>
  }

  export type AdminUpdateWithoutSites_createdInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateWithoutSites_createdInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
  }

  export type companiesUpsertWithoutSitesInput = {
    update: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
    create: XOR<companiesCreateWithoutSitesInput, companiesUncheckedCreateWithoutSitesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutSitesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutSitesInput, companiesUncheckedUpdateWithoutSitesInput>
  }

  export type companiesUpdateWithoutSitesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type social_amenitiesUpsertWithWhereUniqueWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    update: XOR<social_amenitiesUpdateWithoutSitesInput, social_amenitiesUncheckedUpdateWithoutSitesInput>
    create: XOR<social_amenitiesCreateWithoutSitesInput, social_amenitiesUncheckedCreateWithoutSitesInput>
  }

  export type social_amenitiesUpdateWithWhereUniqueWithoutSitesInput = {
    where: social_amenitiesWhereUniqueInput
    data: XOR<social_amenitiesUpdateWithoutSitesInput, social_amenitiesUncheckedUpdateWithoutSitesInput>
  }

  export type social_amenitiesUpdateManyWithWhereWithoutSitesInput = {
    where: social_amenitiesScalarWhereInput
    data: XOR<social_amenitiesUpdateManyMutationInput, social_amenitiesUncheckedUpdateManyWithoutSitesInput>
  }

  export type social_amenitiesScalarWhereInput = {
    AND?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
    OR?: social_amenitiesScalarWhereInput[]
    NOT?: social_amenitiesScalarWhereInput | social_amenitiesScalarWhereInput[]
    id?: StringFilter<"social_amenities"> | string
    siteId?: IntFilter<"social_amenities"> | number
    name?: StringFilter<"social_amenities"> | string
    description?: StringNullableFilter<"social_amenities"> | string | null
    status?: StringFilter<"social_amenities"> | string
    hours?: StringNullableFilter<"social_amenities"> | string | null
    rules?: StringNullableFilter<"social_amenities"> | string | null
    extra?: StringNullableFilter<"social_amenities"> | string | null
    createdAt?: DateTimeFilter<"social_amenities"> | Date | string
    updatedAt?: DateTimeFilter<"social_amenities"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutSiteInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSiteInput, UserUncheckedUpdateWithoutSiteInput>
    create: XOR<UserCreateWithoutSiteInput, UserUncheckedCreateWithoutSiteInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSiteInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSiteInput, UserUncheckedUpdateWithoutSiteInput>
  }

  export type UserUpdateManyWithWhereWithoutSiteInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSiteInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    apartment_no?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    siteId?: IntFilter<"User"> | number
    code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    phone_verification_code?: StringNullableFilter<"User"> | string | null
    reset_code?: StringNullableFilter<"User"> | string | null
    reset_code_expiry?: DateTimeNullableFilter<"User"> | Date | string | null
    account_status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    plates?: StringNullableFilter<"User"> | string | null
    resident_count?: IntNullableFilter<"User"> | number | null
    resident_type?: EnumResidentTypeNullableFilter<"User"> | $Enums.ResidentType | null
    block_id?: IntNullableFilter<"User"> | number | null
    is_password_set?: BoolFilter<"User"> | boolean
  }

  export type ComplaintCreateWithoutUserInput = {
    title: string
    content: string
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
    site: SiteCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type ComplaintCreateOrConnectWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCreateManyUserInputEnvelope = {
    data: ComplaintCreateManyUserInput | ComplaintCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type blocksCreateWithoutUsersInput = {
    block_name: string
    created_at?: Date | string
    sites: SiteCreateNestedOneWithoutBlocksInput
  }

  export type blocksUncheckedCreateWithoutUsersInput = {
    id?: number
    block_name: string
    site_id: number
    created_at?: Date | string
  }

  export type blocksCreateOrConnectWithoutUsersInput = {
    where: blocksWhereUniqueInput
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
  }

  export type SiteCreateWithoutUsersInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
  }

  export type SiteUncheckedCreateWithoutUsersInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
  }

  export type SiteCreateOrConnectWithoutUsersInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutUserInput, ComplaintUncheckedUpdateWithoutUserInput>
    create: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutUserInput, ComplaintUncheckedUpdateWithoutUserInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutUserInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    userId?: IntFilter<"payments"> | number
    siteId?: IntFilter<"payments"> | number
  }

  export type blocksUpsertWithoutUsersInput = {
    update: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
    create: XOR<blocksCreateWithoutUsersInput, blocksUncheckedCreateWithoutUsersInput>
    where?: blocksWhereInput
  }

  export type blocksUpdateToOneWithWhereWithoutUsersInput = {
    where?: blocksWhereInput
    data: XOR<blocksUpdateWithoutUsersInput, blocksUncheckedUpdateWithoutUsersInput>
  }

  export type blocksUpdateWithoutUsersInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    site_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUpsertWithoutUsersInput = {
    update: XOR<SiteUpdateWithoutUsersInput, SiteUncheckedUpdateWithoutUsersInput>
    create: XOR<SiteCreateWithoutUsersInput, SiteUncheckedCreateWithoutUsersInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutUsersInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutUsersInput, SiteUncheckedUpdateWithoutUsersInput>
  }

  export type SiteUpdateWithoutUsersInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
  }

  export type SiteUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type SiteCreateWithoutSocial_amenitiesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutSocial_amenitiesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutSocial_amenitiesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutSocial_amenitiesInput, SiteUncheckedCreateWithoutSocial_amenitiesInput>
  }

  export type SiteUpsertWithoutSocial_amenitiesInput = {
    update: XOR<SiteUpdateWithoutSocial_amenitiesInput, SiteUncheckedUpdateWithoutSocial_amenitiesInput>
    create: XOR<SiteCreateWithoutSocial_amenitiesInput, SiteUncheckedCreateWithoutSocial_amenitiesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutSocial_amenitiesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutSocial_amenitiesInput, SiteUncheckedUpdateWithoutSocial_amenitiesInput>
  }

  export type SiteUpdateWithoutSocial_amenitiesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutSocial_amenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutAnnouncementsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutAnnouncementsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutAnnouncementsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
  }

  export type SiteUpsertWithoutAnnouncementsInput = {
    update: XOR<SiteUpdateWithoutAnnouncementsInput, SiteUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<SiteCreateWithoutAnnouncementsInput, SiteUncheckedCreateWithoutAnnouncementsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutAnnouncementsInput, SiteUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type SiteUpdateWithoutAnnouncementsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutAnnouncementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateWithoutComplaintsInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutComplaintsInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutComplaintsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutComplaintsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    payments?: paymentsCreateNestedManyWithoutUsersInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutComplaintsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
  }

  export type SiteUpsertWithoutComplaintsInput = {
    update: XOR<SiteUpdateWithoutComplaintsInput, SiteUncheckedUpdateWithoutComplaintsInput>
    create: XOR<SiteCreateWithoutComplaintsInput, SiteUncheckedCreateWithoutComplaintsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutComplaintsInput, SiteUncheckedUpdateWithoutComplaintsInput>
  }

  export type SiteUpdateWithoutComplaintsInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type UserUpsertWithoutComplaintsInput = {
    update: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateWithoutComplaintsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SiteCreateWithoutBlocksInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutBlocksInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutBlocksInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
  }

  export type UserCreateWithoutBlocksInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: ComplaintCreateNestedManyWithoutUserInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutBlocksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput>
  }

  export type UserCreateManyBlocksInputEnvelope = {
    data: UserCreateManyBlocksInput | UserCreateManyBlocksInput[]
    skipDuplicates?: boolean
  }

  export type SiteUpsertWithoutBlocksInput = {
    update: XOR<SiteUpdateWithoutBlocksInput, SiteUncheckedUpdateWithoutBlocksInput>
    create: XOR<SiteCreateWithoutBlocksInput, SiteUncheckedCreateWithoutBlocksInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutBlocksInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutBlocksInput, SiteUncheckedUpdateWithoutBlocksInput>
  }

  export type SiteUpdateWithoutBlocksInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutBlocksInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBlocksInput, UserUncheckedUpdateWithoutBlocksInput>
    create: XOR<UserCreateWithoutBlocksInput, UserUncheckedCreateWithoutBlocksInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBlocksInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBlocksInput, UserUncheckedUpdateWithoutBlocksInput>
  }

  export type UserUpdateManyWithWhereWithoutBlocksInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBlocksInput>
  }

  export type AdminCreateWithoutCompaniesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_employees?: company_employeesCreateNestedOneWithoutAdminsInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCompaniesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    company_employees?: company_employeesUncheckedCreateNestedOneWithoutAdminsInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCompaniesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCompaniesInput, AdminUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesCreateWithoutCompaniesInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutCompany_employeesInput
  }

  export type company_employeesCreateOrConnectWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesCreateManyCompaniesInputEnvelope = {
    data: company_employeesCreateManyCompaniesInput | company_employeesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type invitationsCreateWithoutCompaniesInput = {
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type invitationsCreateOrConnectWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsCreateManyCompaniesInputEnvelope = {
    data: invitationsCreateManyCompaniesInput | invitationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type SiteCreateWithoutCompaniesInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessCreateNestedManyWithoutSitesInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    employee_site_access?: employee_site_accessUncheckedCreateNestedManyWithoutSitesInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput>
  }

  export type SiteCreateManyCompaniesInputEnvelope = {
    data: SiteCreateManyCompaniesInput | SiteCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCompaniesInput = {
    update: XOR<AdminUpdateWithoutCompaniesInput, AdminUncheckedUpdateWithoutCompaniesInput>
    create: XOR<AdminCreateWithoutCompaniesInput, AdminUncheckedCreateWithoutCompaniesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCompaniesInput, AdminUncheckedUpdateWithoutCompaniesInput>
  }

  export type AdminUpdateWithoutCompaniesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUncheckedUpdateOneWithoutAdminsNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type company_employeesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    update: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_employeesCreateWithoutCompaniesInput, company_employeesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_employeesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_employeesWhereUniqueInput
    data: XOR<company_employeesUpdateWithoutCompaniesInput, company_employeesUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_employeesUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_employeesScalarWhereInput
    data: XOR<company_employeesUpdateManyMutationInput, company_employeesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_employeesScalarWhereInput = {
    AND?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    OR?: company_employeesScalarWhereInput[]
    NOT?: company_employeesScalarWhereInput | company_employeesScalarWhereInput[]
    id?: IntFilter<"company_employees"> | number
    admin_id?: IntFilter<"company_employees"> | number
    company_id?: IntFilter<"company_employees"> | number
    joined_at?: DateTimeFilter<"company_employees"> | Date | string
    status?: EnumAccountStatusFilter<"company_employees"> | $Enums.AccountStatus
  }

  export type invitationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    update: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<invitationsCreateWithoutCompaniesInput, invitationsUncheckedCreateWithoutCompaniesInput>
  }

  export type invitationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: invitationsWhereUniqueInput
    data: XOR<invitationsUpdateWithoutCompaniesInput, invitationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type invitationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: invitationsScalarWhereInput
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type invitationsScalarWhereInput = {
    AND?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    OR?: invitationsScalarWhereInput[]
    NOT?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    id?: IntFilter<"invitations"> | number
    company_id?: IntFilter<"invitations"> | number
    invite_code?: StringFilter<"invitations"> | string
    invite_link?: StringFilter<"invitations"> | string
    invited_email?: StringNullableFilter<"invitations"> | string | null
    invited_by?: IntFilter<"invitations"> | number
    status?: EnumInvitationStatusFilter<"invitations"> | $Enums.InvitationStatus
    expires_at?: DateTimeFilter<"invitations"> | Date | string
    used_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    used_by?: IntNullableFilter<"invitations"> | number | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
  }

  export type SiteUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutCompaniesInput, SiteUncheckedUpdateWithoutCompaniesInput>
    create: XOR<SiteCreateWithoutCompaniesInput, SiteUncheckedCreateWithoutCompaniesInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutCompaniesInput, SiteUncheckedUpdateWithoutCompaniesInput>
  }

  export type SiteUpdateManyWithWhereWithoutCompaniesInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type AdminCreateWithoutCompany_employeesInput = {
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesCreateNestedManyWithoutAdminsInput
    sites_created?: SiteCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    full_name: string
    email: string
    password: string
    account_type: $Enums.AccountType
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tokenExpiry?: Date | string | null
    verificationToken?: string | null
    is_verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    companies?: companiesUncheckedCreateNestedManyWithoutAdminsInput
    sites_created?: SiteUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCompany_employeesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
  }

  export type companiesCreateWithoutCompany_employeesInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompaniesInput
    invitations?: invitationsCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    invitations?: invitationsUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_employeesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateWithoutCompany_employeesInput = {
    granted_at?: Date | string
    sites: SiteCreateNestedOneWithoutEmployee_site_accessInput
  }

  export type employee_site_accessUncheckedCreateWithoutCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessCreateOrConnectWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessCreateManyCompany_employeesInputEnvelope = {
    data: employee_site_accessCreateManyCompany_employeesInput | employee_site_accessCreateManyCompany_employeesInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCompany_employeesInput = {
    update: XOR<AdminUpdateWithoutCompany_employeesInput, AdminUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<AdminCreateWithoutCompany_employeesInput, AdminUncheckedCreateWithoutCompany_employeesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCompany_employeesInput, AdminUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type AdminUpdateWithoutCompany_employeesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateManyWithoutAdminsNestedInput
    sites_created?: SiteUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    account_type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUncheckedUpdateManyWithoutAdminsNestedInput
    sites_created?: SiteUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type companiesUpsertWithoutCompany_employeesInput = {
    update: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<companiesCreateWithoutCompany_employeesInput, companiesUncheckedCreateWithoutCompany_employeesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_employeesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_employeesInput, companiesUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type companiesUpdateWithoutCompany_employeesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type employee_site_accessUpsertWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    update: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
    create: XOR<employee_site_accessCreateWithoutCompany_employeesInput, employee_site_accessUncheckedCreateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateWithWhereUniqueWithoutCompany_employeesInput = {
    where: employee_site_accessWhereUniqueInput
    data: XOR<employee_site_accessUpdateWithoutCompany_employeesInput, employee_site_accessUncheckedUpdateWithoutCompany_employeesInput>
  }

  export type employee_site_accessUpdateManyWithWhereWithoutCompany_employeesInput = {
    where: employee_site_accessScalarWhereInput
    data: XOR<employee_site_accessUpdateManyMutationInput, employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput>
  }

  export type company_employeesCreateWithoutEmployee_site_accessInput = {
    joined_at?: Date | string
    status?: $Enums.AccountStatus
    admins: AdminCreateNestedOneWithoutCompany_employeesInput
    companies: companiesCreateNestedOneWithoutCompany_employeesInput
  }

  export type company_employeesUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    admin_id: number
    company_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type company_employeesCreateOrConnectWithoutEmployee_site_accessInput = {
    where: company_employeesWhereUniqueInput
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type SiteCreateWithoutEmployee_site_accessInput = {
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementCreateNestedManyWithoutSiteInput
    blocks?: blocksCreateNestedManyWithoutSitesInput
    complaints?: ComplaintCreateNestedManyWithoutSiteInput
    admin?: AdminCreateNestedOneWithoutSites_createdInput
    companies?: companiesCreateNestedOneWithoutSitesInput
    social_amenities?: social_amenitiesCreateNestedManyWithoutSitesInput
    users?: UserCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutEmployee_site_accessInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutSiteInput
    blocks?: blocksUncheckedCreateNestedManyWithoutSitesInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSiteInput
    social_amenities?: social_amenitiesUncheckedCreateNestedManyWithoutSitesInput
    users?: UserUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutEmployee_site_accessInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpsertWithoutEmployee_site_accessInput = {
    update: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<company_employeesCreateWithoutEmployee_site_accessInput, company_employeesUncheckedCreateWithoutEmployee_site_accessInput>
    where?: company_employeesWhereInput
  }

  export type company_employeesUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: company_employeesWhereInput
    data: XOR<company_employeesUpdateWithoutEmployee_site_accessInput, company_employeesUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type company_employeesUpdateWithoutEmployee_site_accessInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    companies?: companiesUpdateOneRequiredWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type SiteUpsertWithoutEmployee_site_accessInput = {
    update: XOR<SiteUpdateWithoutEmployee_site_accessInput, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
    create: XOR<SiteCreateWithoutEmployee_site_accessInput, SiteUncheckedCreateWithoutEmployee_site_accessInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutEmployee_site_accessInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutEmployee_site_accessInput, SiteUncheckedUpdateWithoutEmployee_site_accessInput>
  }

  export type SiteUpdateWithoutEmployee_site_accessInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutEmployee_site_accessInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type companiesCreateWithoutInvitationsInput = {
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    admins: AdminCreateNestedOneWithoutCompaniesInput
    company_employees?: company_employeesCreateNestedManyWithoutCompaniesInput
    sites?: SiteCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutInvitationsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    manager_id: number
    company_employees?: company_employeesUncheckedCreateNestedManyWithoutCompaniesInput
    sites?: SiteUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutInvitationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
  }

  export type companiesUpsertWithoutInvitationsInput = {
    update: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
    create: XOR<companiesCreateWithoutInvitationsInput, companiesUncheckedCreateWithoutInvitationsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutInvitationsInput, companiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type companiesUpdateWithoutInvitationsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admins?: AdminUpdateOneRequiredWithoutCompaniesNestedInput
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager_id?: IntFieldUpdateOperationsInput | number
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
    complaints?: ComplaintCreateNestedManyWithoutUserInput
    blocks?: blocksCreateNestedOneWithoutUsersInput
    site: SiteCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type companiesCreateManyAdminsInput = {
    id?: number
    company_name: string
    company_code: string
    account_status?: $Enums.AccountStatus
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type SiteCreateManyAdminInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    apartment_count?: number | null
    block_count?: number | null
    company_id?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type companiesUpdateWithoutAdminsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_employees?: company_employeesUncheckedUpdateManyWithoutCompaniesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutCompaniesNestedInput
    sites?: SiteUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateManyWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_code?: StringFieldUpdateOperationsInput | string
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteUpdateWithoutAdminInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    companies?: companiesUpdateOneWithoutSitesNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type AnnouncementCreateManySiteInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    start_date: Date | string
    end_date: Date | string
  }

  export type blocksCreateManySitesInput = {
    id?: number
    block_name: string
    created_at?: Date | string
  }

  export type ComplaintCreateManySiteInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type employee_site_accessCreateManySitesInput = {
    id?: number
    employee_id: number
    granted_at?: Date | string
  }

  export type social_amenitiesCreateManySitesInput = {
    id: string
    name: string
    description?: string | null
    status?: string
    hours?: string | null
    rules?: string | null
    extra?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserCreateManySiteInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    block_id?: number | null
    is_password_set?: boolean
  }

  export type AnnouncementUpdateWithoutSiteInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blocksUpdateWithoutSitesInput = {
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBlocksNestedInput
  }

  export type blocksUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutSiteInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    user?: UserUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type ComplaintUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type employee_site_accessUpdateWithoutSitesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_employees?: company_employeesUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_amenitiesUncheckedUpdateManyWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSiteInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    blocks?: blocksUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    block_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ComplaintCreateManyUserInput = {
    id?: number
    title: string
    content: string
    status?: $Enums.Status
    siteId: number
    created_at?: Date | string
    updated_at?: Date | string
    category?: $Enums.Category | null
  }

  export type paymentsCreateManyUsersInput = {
    id?: number
    amount: number
    payment_date: Date | string
    payment_method: $Enums.PaymentMethod
    description?: string | null
    created_at?: Date | string
    siteId: number
  }

  export type ComplaintUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    site?: SiteUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type ComplaintUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    siteId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
  }

  export type paymentsUpdateWithoutUsersInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyBlocksInput = {
    id?: number
    full_name: string
    phone_number: string
    password?: string | null
    apartment_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    siteId: number
    code_expiry?: Date | string | null
    phone_verification_code?: string | null
    reset_code?: string | null
    reset_code_expiry?: Date | string | null
    account_status?: $Enums.AccountStatus
    deleted_at?: Date | string | null
    last_login?: Date | string | null
    plates?: string | null
    resident_count?: number | null
    resident_type?: $Enums.ResidentType | null
    is_password_set?: boolean
  }

  export type UserUpdateWithoutBlocksInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    site?: SiteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    apartment_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    siteId?: IntFieldUpdateOperationsInput | number
    code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_verification_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code?: NullableStringFieldUpdateOperationsInput | string | null
    reset_code_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plates?: NullableStringFieldUpdateOperationsInput | string | null
    resident_count?: NullableIntFieldUpdateOperationsInput | number | null
    resident_type?: NullableEnumResidentTypeFieldUpdateOperationsInput | $Enums.ResidentType | null
    is_password_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type company_employeesCreateManyCompaniesInput = {
    id?: number
    admin_id: number
    joined_at?: Date | string
    status?: $Enums.AccountStatus
  }

  export type invitationsCreateManyCompaniesInput = {
    id?: number
    invite_code: string
    invite_link: string
    invited_email?: string | null
    invited_by: number
    status?: $Enums.InvitationStatus
    expires_at: Date | string
    used_at?: Date | string | null
    used_by?: number | null
    created_at?: Date | string
  }

  export type SiteCreateManyCompaniesInput = {
    id?: number
    site_id: string
    site_name: string
    site_address: string
    created_at?: Date | string
    updated_at?: Date | string
    adminId?: number | null
    apartment_count?: number | null
    block_count?: number | null
    deleted_at?: Date | string | null
    site_status?: $Enums.AccountStatus
  }

  export type company_employeesUpdateWithoutCompaniesInput = {
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    admins?: AdminUpdateOneRequiredWithoutCompany_employeesNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutCompany_employeesNestedInput
  }

  export type company_employeesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type invitationsUpdateWithoutCompaniesInput = {
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    invite_code?: StringFieldUpdateOperationsInput | string
    invite_link?: StringFieldUpdateOperationsInput | string
    invited_email?: NullableStringFieldUpdateOperationsInput | string | null
    invited_by?: IntFieldUpdateOperationsInput | number
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    used_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUpdateWithoutCompaniesInput = {
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUpdateManyWithoutSiteNestedInput
    blocks?: blocksUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUpdateManyWithoutSitesNestedInput
    admin?: AdminUpdateOneWithoutSites_createdNestedInput
    social_amenities?: social_amenitiesUpdateManyWithoutSitesNestedInput
    users?: UserUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    announcements?: AnnouncementUncheckedUpdateManyWithoutSiteNestedInput
    blocks?: blocksUncheckedUpdateManyWithoutSitesNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSiteNestedInput
    employee_site_access?: employee_site_accessUncheckedUpdateManyWithoutSitesNestedInput
    social_amenities?: social_amenitiesUncheckedUpdateManyWithoutSitesNestedInput
    users?: UserUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    site_address?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    apartment_count?: NullableIntFieldUpdateOperationsInput | number | null
    block_count?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    site_status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type employee_site_accessCreateManyCompany_employeesInput = {
    id?: number
    site_id: number
    granted_at?: Date | string
  }

  export type employee_site_accessUpdateWithoutCompany_employeesInput = {
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateOneRequiredWithoutEmployee_site_accessNestedInput
  }

  export type employee_site_accessUncheckedUpdateWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employee_site_accessUncheckedUpdateManyWithoutCompany_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: IntFieldUpdateOperationsInput | number
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}